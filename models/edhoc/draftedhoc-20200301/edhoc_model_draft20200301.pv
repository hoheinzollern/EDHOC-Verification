(* Basic assumptions and limitations:
 * - We model all cipher suites as a single fixed algorithms; no negotiation
 *   - Initiator sends a cipher suite proposal and Responder always accepts it
 * - We always send context identifiers C_I and C_R
 * - We don't model the CORR parameter
 * - We send aux data in all messages where it can occur (AD1, AD2, AD3)
 *
 * WoW: put in a DIFF tag an explain what is different or assumed compared
 *      to the specification in the place where it happens. If it affect
 *      multiple places, put it in the first palce it happens.
 *
 * TODO: CORR investigate whether it is OK to exclude it. It seems to be OK
 *       after initial back-of-the-envelope analysis.
 * WoW: put a FEEDBACK tag on comments that wants to send info back to the 
 *      spec writers about unclarities or inconsitencies etc.
 * FEEDBACK: 4.1: first four bullets state that the initiator shold be able to
 *           retrieve "the" key of the responder. Singular.  Later in the section
 *           it is stated that the responder may have to try several keys.
 *           This seems inconsitent and should at least be discussed to see
 *           what the security implications are (perhaps just add a pointer
 *           to the security considerations section).
 *
 *)
set reconstructTrace = false.

(* Macro definitions *)
letfun revealSessKeys() = false.
letfun maliciousPrincipals() = true.
letfun asymmToSymm() = false.

(* Privacy *)
(*
query x:key; attacker (idI(pk(new skU))) phase 0 ==>
  (event (LTK_Reveal(new skU)) || event (SessK3A_Reveal(x, new skU))).
query x:key; attacker (idR(pk(new skU))) phase 0 ==>
  (event (LTK_Reveal(new skU)) || event (SessK2A_Reveal(x, new skU))).

query x:key; attacker (idI(pk(new skU))) phase 1 ==>
  (event (LTK_Reveal(new skU)) || event (SessK3A_Reveal(x, new skU))).
query x:key; attacker (idR(pk(new skU))) phase 1 ==>
  (event (LTK_Reveal(new skU)) || event (SessK2A_Reveal(x, new skU))).
*)

(* Secrecy Asymmetric *)
(*
query skU:skey, skV:skey, S_V:bitstring, K_2:key;
  attacker (APP_2A(pk(skU),skV,S_V,K_2)) phase 0 ==>
   (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:skey, skV:skey, S_V:bitstring, K_2:key;
  attacker (APP_2A'(pk(skU),skV,S_V,K_2)) phase 0 ==>
   (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:skey, skV:skey, S_U:bitstring, K_3:key;
  attacker (APP_3A(skU,pk(skV),S_U,K_3)) phase 0 ==>
   (event (LTK_Reveal(skV)) || event (SessK3A_Reveal(K_3, new skU))).
*)

(* Secrecy Symmetric *)
(*
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S(PSK, S_U, K_2)) phase 0 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S'(PSK, S_U, K_2)) phase 0 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_V:bitstring, K_3 : key;
  attacker (APP_3S(PSK, S_V, K_3)) phase 0 ==>
    (event (PSK_Reveal(PSK)) || event (SessK3S_Reveal(K_3))).
*)

(* Perfect Forward Secrecy Asymmetric *)
(*
query skU:skey, skV:skey, S_V:bitstring, K_2:key;
  attacker (APP_2A(pk(skU),skV,S_V,K_2)) phase 1 ==>
    (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:skey, skV:skey, S_V:bitstring, K_2:key;
  attacker (APP_2A'(pk(skU),skV,S_V,K_2)) phase 1 ==>
    (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:skey, skV:skey, S_U:bitstring, K_3:key;
  attacker (APP_3A(skU,pk(skV),S_U,K_3)) phase 1 ==>
    (event (LTK_Reveal(skV)) || event (SessK3A_Reveal(K_3, new skU))).
*)

(* Perfect Forward Secrecy Symmetric *)
(*
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S(PSK, S_U, K_2)) phase 1 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S'(PSK, S_U, K_2)) phase 1 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_V:bitstring, K_3 : key;
  attacker (APP_3S(PSK, S_V, K_3)) phase 1 ==>
    (event (PSK_Reveal(PSK)) || event (SessK3S_Reveal(K_3))).
*)

(* Injective agreement Asymmetric *)
(*
query U: host, U': host, V: host, E_V: dhElt, skV : skey;
  inj-event (midInitiatorA(U, V, E_V)) ==>
    (inj-event (startResponderA(U', V, E_V, skV)) || event (LTK_Reveal(skV))).
query U: host, V: host, E_U: dhElt, skU : skey;
  inj-event (endResponderA(U, V, E_U)) ==>
    (inj-event (startInitiatorA(U, V, E_U, skU)) || event (LTK_Reveal(skU))).
query U: host, U': host, V: host, E_V: dhElt, skV : skey;
  inj-event (endInitiatorA(U, V, E_V)) ==>
    inj-event (startResponderA(U', V, E_V, skV)) || event (LTK_Reveal(skV)).
*)

(* Injective agreement Symmetric *)
(*
query U: host, U': host, V: host, PSK: key, E_V: dhElt;
  inj-event (midInitiatorS(U, V, PSK, E_V)) ==>
    inj-event (startResponderS(U', V, PSK, E_V)) || event (PSK_Reveal(PSK)).
query U: host, U': host, V: host, PSK: key, E_V: dhElt;
  inj-event (endInitiatorS(U, V, PSK, E_V)) ==>
    inj-event (startResponderS(U', V, PSK, E_V)) || event (PSK_Reveal(PSK)).
query U: host, V: host, PSK: key, E_U: dhElt;
  inj-event (endResponderS(U, V, PSK, E_U)) ==>
    inj-event (startInitiatorS(U, V, PSK, E_U)) || event (PSK_Reveal(PSK)).
*)

(* CONTENT (algorithm) agreement Asymmetric *)
(*
query U: host, V: host, K_2: key, skV : skey, aad_2 : bitstring;
  event (agreeHashEnd2A(U, V, K_2, aad_2)) ==>
    (event (agreeHashStart2A(U, V, K_2, aad_2, skV)) || event (LTK_Reveal(skV)) || event (SessK2A_Reveal(K_2, new skU))).
query U: host, V: host, K_3: key, skU : skey, aad_3 : bitstring;
  event (agreeHashEnd3A(U, V, K_3, aad_3)) ==>
    (event (agreeHashStart3A(U, V, K_3, aad_3, skU)) || event (LTK_Reveal(skU)) || event (SessK3A_Reveal(K_3, new skU))).
*)

(* CONTENT (algorithm) agreement Symmetric *)
(*
query U: host, V: host, K_2: key, PSK : key, aad_2 : bitstring;
  event (agreeHashEnd2S(U, V, K_2, aad_2)) ==>
    (event (agreeHashStart2S(U, V, K_2, aad_2, PSK)) || event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query U: host, V: host, K_3: key, PSK : key, aad_3 : bitstring;
  event (agreeHashEnd3S(U, V, K_3, aad_3)) ==> (event
    (agreeHashStart3S(U, V, K_3, aad_3, PSK)) || event (PSK_Reveal(PSK)) || event (SessK3S_Reveal(K_3))).
*)




(* Session key secrecy and session key independence.
 * Idea: Only way for attacker to get hold of session k key
 *       is if he has access to the LTK.
 *       Expressing this as a correspondence property we write:
 *          if attacker knows the session key it must be because he knew
 *             the LTK.
 *       We don't accept that he got it any other way.
 *       Specifically, even if he knows other session keys but not the LTK,
 *       he should still not get the session key, i.e., sesssion key independence.
 *)
(*
query skU:skey, skV:skey, S_V:bitstring, K_2:key;
  attacker(

  attacker (APP_2A(pk(skU),skV,S_V,K_2)) phase 0 ==>
   (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
*)


event startInitiatorSigSig(host, host, dhElt, skey, ctxID).

let initiatorSigSig(U: host, V: host, skU: skey, pkU: pkey, pkV: pkey) =
  new x[]: exponent; let G_X = exp(g, x) in new S_I[]: bitstring;
  new AD_1[]: bitstring; new C_I[]: ctxID;
  (* KARL: Note to self, need to cover S_I here as well, right? *)
  event startInitiatorSigSig(U, V, G_X, skU, C_I);
  (* KARL: the original model uses these Tx-tags. They don't exist in the real
   *       protocol. If we can do without them and still terminate, I think
   *       we should. Otherwise, we need a rationale why the real protocol
   *       is still secure or what our analysis will miss by using the tags
   *       I suppose.
   *)
  (* KARL: Original model did not include Mode "negotaion". I add that now,
   *       but ignore the CORR, which I think only relates to underlying
   *       transport.
   *)
  (* KARL: Original model did not include session identifiers. I don't think
   *       they affect the protocol as such, but the resulting OSCORE context
   *       is supposed to be identified by this, so presumably the identifiers
   *       need to be used as a link between EDHOC and OSCORE model in some way.
   *       Minimally, U and V must agree on the resulting values when EDHOC
   *       completes.
   *)
  let msg_1: bitstring = (EH_SIG_SIG, S_I, G_X, C_I, AD_1) in
  out(c, msg_1);
  in(c, msg_2: bitstring);
  let (data_2: bitstring, CIPHERTEXT_2: bitstring) = msg_2 in

  (* Because we don't model the CORR parameter, we assumme the worst
   * and cover the case that C_I is inlcuded in the message.
   *)
  let (=C_I, G_Y: dhElt, C_R: ctxID) = data_2 in

  (* The hash function should be the one used for the KDF, which is negotiated.
   * KARL: If we do model ciphersuite negotiation then we shold not use a
   * static hash function like this. Similar for the KDF and the AEAD.
   * As long as we do not model multi-session negotiation I see no need to model
   * anything else than static algos though.
   *)
  let TH_2: bitstring = hash((msg_1, data_2)) in
  let PRK_2e: bitstring = PRK_asym_2e(exp(G_Y, x)) in
  
  (* For now we fix the AEAD to be aead0, in the same spirit as the fixed hash *)
  let K_2ae: bitstring = K_2ae_KDF(PRK_2e, TH_2, aead0) in

  (* CIPHERTEXT_2 contains a COSE_Encrypt0 object. The COSE_Encrypt0 object
   * has three main parts, unprotected headers, protected headers and
   * ciphertext. RFC 8152 is not entirely clear, but it seems as if
   * the protected headers should be part of the AAD for the AEAD.
   * EDHOC Section 4.3.2:
   * Protected: ID_CRED_R              ==> (V in the model)
   * external_aad: TH_2, CRED_R, AD_2  ==> (TH_2, pkV, AD_2) in the model
   *)
  (* The decryption here is the XOR decryption *)
  let plainText: bitstring = decrypt(CIPHERTEXT_2, K_2ae, aad_2) in
  let (=V, signature_2:bitstring, AD_2) = plainText in
  let aad_2 = (V, TH_2, pkV, AD_2) in

  (* This AEAD decryption is the so called "inner COSE_Encrypt0", which is an
   * encryption of the empty string for the only purpose of producing a MAC.
   *)
  let ver = aeadEncrypt(emptyHexString, K_2ae, aad_2) in
     or SIGNATURE2
  if vwrifywefionweuio  then
      

  let (=idR(pkV), =aad_2, APP_2A: bitstring) = verify(signature_2, pkV) in

  event agreeHashEnd2A(U, V, K_2, aad_2);
  event midInitiatorA(U, V, xE_V);
  let data_3: bitstring = (T3, xS_V) in
  let aad_3: bitstring = hash((msg_2, data_3)) in
  let K_3: key = HKDF(K, aad_3, empty, EDHOC) in
  let APP_3A = APP_3A(skU,pkV,S_U,K_3) in
  let signature_3: bitstring = sign((idI(pk(skU)), aad_3, APP_3A), skU) in
  let COSE_ENC_3: bitstring = aeadEncrypt(signature_3, K_3, aad_3) in
  let msg_3: bitstring = (data_3, COSE_ENC_3) in
  event agreeHashStart3A(U, V, K_3, aad_3, skU);
  out(c, msg_3);
  event endInitiatorA(U, V, xE_V);
  (if revealSessKeys() then
     (event SessK2A_Reveal(K_2, skU); out(c, K_2))).

let responderAsym(V: host, U: host, skV: skey, pkV: pkey, pkU: pkey) =
  (* TODO: responder should learn its method from the METHOD parameter in
   * message 1 (static/static, static/sign etc).
   *)
  new y[]: exponent; let E_V: dhElt = exp(g, y) in new S_V[]: bitstring;
  new C_U[]: bitstring;
  event startResponderA(U, V, E_V, skV, C_U);
  in(c, msg_1: bitstring);
  let (=T1, xS_U: bitstring, xE_U: dhElt, APP_1A: bitstring) = msg_1 in
  let data_2: bitstring = (T2, xS_U, S_V, E_V) in
  let aad_2: bitstring = hash((msg_1, data_2)) in
  let K: dhElt = exp(xE_U, y) in
  let K_2: key = HKDF(K, aad_2, empty, EDHOC) in
  let APP_2A = APP_2A(pkU,skV,S_V,K_2) in
  let APP_2A' = APP_2A'(pkU,skV,S_V,K_2) in
  (* TODO: write all asym-modes in one let-expression. *)
  let verificationToken = if static then
     mac-computation
  else
     sign((idR(pk(skV)), aad_2, APP_2A), skV) in
  let COSE_ENC_2: bitstring = aeadEncrypt(signature_2, K_2, aad_2) in
  let msg_2: bitstring = (data_2, COSE_ENC_2) in

  event agreeHashStart2A(U, V, K_2, aad_2, skV);
  out(c, msg_2);

  in(c, msg_3: bitstring);
  let (data_3: bitstring, COSE_ENC_3: bitstring) = msg_3 in
  let (=T3, =S_V) = data_3 in
  let aad_3: bitstring = hash((msg_2, data_3)) in
  let K_3: key = HKDF(K, aad_3, empty, EDHOC) in
  let signature_3: bitstring = aeadDecrypt(COSE_ENC_3, K_3, aad_3) in
  let (=idI(pkU), =aad_3, APP_3A: bitstring) = verify(signature_3, pkU) in
  event agreeHashEnd3A(U, V, K_3, aad_3);
  event endResponderA(U, V, xE_U);
  let signature_2': bitstring = sign((idR(pkV), aad_2, APP_2A'), skV) in
  let COSE_ENC_2': bitstring = aeadEncrypt(signature_2', K_2, aad_2) in
  let msg_2': bitstring = (data_2, COSE_ENC_2') in
  out(c2, msg_2');
  (if asymmToSymm() then
   let PSK' = HKDF(K, hash(msg_3), empty, EDHOC_PSK_Chaining) in
   out(s2, (U, V, PSK'))) |
  (if revealSessKeys() then
    (event SessK3A_Reveal(K_3, skV); out(c, K_3))).


let initiatorSym(U: host, V: host, PSK: key) =
  new x[]: exponent; let E_U: dhElt = exp(g, x) in new S_U[]: bitstring;
  new APP_1S[]: bitstring;
  event startInitiatorS(U, V, PSK, E_U);
  let msg_1: bitstring = (T4, S_U, E_U, APP_1S) in
  out(c, msg_1); in(c, msg_2: bitstring);
  let (data_2: bitstring, COSE_ENC_2: bitstring) = msg_2 in
  let (=T5, =S_U, xS_V: bitstring, xE_V: dhElt) = data_2 in
  let aad_2: bitstring = hash((msg_1, data_2)) in
  let K: dhElt = exp(xE_V, x) in
  let K_2: key = HKDF(K, aad_2, PSK, EDHOC) in
  let (APP_2S: bitstring) = aeadDecrypt(COSE_ENC_2, K_2, aad_2) in
  event agreeHashEnd2S(U, V, K_2, aad_2);
  event midInitiatorS(U, V, PSK, xE_V);
  let data_3: bitstring = (T6, xS_V) in
  let aad_3: bitstring = hash((msg_2, data_3)) in
  let K_3: key = HKDF(K, aad_3, PSK, EDHOC) in
  let APP_3S = APP_3S(PSK, S_U, K_3) in
  let msg_3: bitstring = (data_3, aeadEncrypt(APP_3S, K_3, aad_3)) in
  event agreeHashStart3S(U, V, K_3, aad_3, PSK);
  out(c, msg_3);
  event endInitiatorS(U, V, PSK, xE_V);
  (if revealSessKeys() then
    (event SessK2S_Reveal(K_2); out(c, K_2))).

let responderSym(V: host, U: host, PSK: key) =
  new y[]: exponent; let E_V: dhElt = exp(g, y) in new S_V[]: bitstring;
  event startResponderS(U, V, PSK, E_V);
  in(c, msg_1: bitstring);
  let (=T4, xS_U: bitstring, xE_U: dhElt, APP_1S: bitstring) = msg_1 in
  let data_2: bitstring = (T5, xS_U, S_V, E_V) in
  let aad_2: bitstring = hash((msg_1, data_2)) in
  let K: dhElt = exp(xE_U, y) in
  let K_2: key = HKDF(K, aad_2, PSK, EDHOC) in
  let APP_2S = APP_2S(PSK, S_V, K_2) in
  let APP_2S' = APP_2S'(PSK, S_V, K_2) in
  let msg_2: bitstring = (data_2, aeadEncrypt(APP_2S, K_2, aad_2)) in

  event agreeHashStart2S(U, V, K_2, aad_2, PSK);
  out(c, msg_2);

  in(c, msg_3: bitstring);
  let (data_3: bitstring, COSE_ENC_3: bitstring) = msg_3 in
  let (=T6, =S_V) = data_3 in
  let aad_3: bitstring = hash((msg_2, data_3)) in
  let K_3: key = HKDF(K, aad_3, PSK, EDHOC) in
  let (APP_3S: bitstring) = aeadDecrypt(COSE_ENC_3, K_3, aad_3) in
  event agreeHashEnd3S(U, V, K_3, aad_3);
  event endResponderS(U, V, PSK, xE_U);
  let COSE_ENC_2': bitstring = aeadEncrypt(APP_2S', K_2, aad_2) in
  let msg_2': bitstring = (data_2, COSE_ENC_2') in
  out(c2, msg_2');
  (if asymmToSymm() && (getAlgorithm(PSK) = EDHOC_PRESHARED) then
   let PSK' = HKDF(K, hash(msg_3), PSK, EDHOC_PSK_Chaining) in
   out(s2, (U, V, PSK'))) |
  (if revealSessKeys() then
    (event SessK3S_Reveal(K_3); out(c, K_3))).


process
  (!new U: host;
    new skU: skey;
    let pkU = pk(skU) in
    !out(s, (U, skU, pkU)); out(s, (U, skU, pkU));
    out(c, (pkU));
    ((if maliciousPrincipals() then event LTK_Reveal(skU); out(c, skU)) | phase 1; out(c, skU)) ) |
 (* KARL: Is it so that once something is written to a channel it can be read
          infinitely many times?  Otherwise, it seems this will not capture
          that a party is tricked into running the protocol with itself (a type
          of reflection attack).
  *)
  (!in(s, (U:host, skU:skey, pkU:pkey));
    in(s, (V:host, skV:skey, pkV:pkey));
    new random[]: bitstring;
    let PSK = HKDF(g, random, empty, EDHOC_PRESHARED) in
    out(s2, (U, V, PSK)); out(s2, (U, V, PSK));
  (* KARL: is there any property we hope to be able to prove if the PSK is
           reveald before the protocol is run?
   *)
    ((if maliciousPrincipals() then event PSK_Reveal(PSK); out(c, PSK)) | phase 1; out(c, PSK)) ) |
  (!in(s, (U:host, skU:skey, pkU:pkey));
    in(s, (V:host, skV:skey, pkV:pkey));
    (initiatorAsym(U, V, skU, pkU, pkV) |
     responderAsym(V, U, skV, pkV, pkU)) ) |
  (!in(s2, (U:host, V:host, PSK:key));
    (initiatorSym(U, V, PSK) |
     responderSym(V, U, PSK)) )
