(* Basic assumptions and limitations:
 * - We model all cipher suites as a single fixed algorithms; no negotiation
 *   - Initiator sends a cipher suite proposal and Responder always accepts it
 * - We always send context identifiers C_I and C_R
 *   - C_I and C_R are chosen by EDHOC it says in 4.2.2 and 4.3.1.
 *     So, EDHOC has some control over how they are selected.
 * - We don't model the CORR parameter
 * - We send aux data in all messages where it can occur (AD1, AD2, AD3)
 *
 * WoW: put in a DIFF tag an explain what is different or assumed compared
 *      to the specification in the place where it happens. If it affect
 *      multiple places, put it in the first palce it happens.
 *
 * TODO: CORR investigate whether it is OK to exclude it. It seems to be OK
 *       after initial back-of-the-envelope analysis.
 *
 * WoW: put a FEEDBACK tag on comments that wants to send info back to the
 *      spec writers about unclarities or inconsitencies etc. Also good to
 *      write in paper to show impact on standard.
 *
 * FEEDBACK: 4.1: first four bullets state that the initiator shold be able to
 *           retrieve "the" key of the responder. Singular.  Later in the
 *           section it is stated that the responder may have to try several
 *           keys. This seems inconsitent and should at least be discussed to
 *           see what the security implications are (perhaps just add a
 *           pointer to the security considerations section).
 *
 * FEEDBACK: EDHOC protocol does not check whether combination of CI/CR is unique
 *           as requested by reqs doc.
 *
 * FEEDBACK: EDHOC accepts a set of acceptable IDs to connect to, but protocol
 *           does not enforce this and happily connects to whomever has a valid
 *           cert/raw public key/PSK.
 *
 * NOTE: capital and lowercase with underscore comes from the spec,
 *       camelCase are additions from the model
 *
 * PROPERTIES:
 * - data/key material to protect:
 *   - the final session key (PRK_4x3m, TH_4),  (inj-greement, Confidentiality)
 *   - the application data AD_1, AD_2, AD_3  (Confident/Integrity for AD_3 (and AD_2?), integrity for AD_1)
 *   - C_I and C_R  (inj-agreement)
 *   - S_I and S_R  (inj-agreement)  (take these last)
 *   - U and V      (Confidentiality, privacy(?))
 *)

set reconstructTrace = true.
set attacker = passive.

(* Macro definitions *)
letfun revealSessKeys() = false.
letfun maliciousPrincipals() = false.
letfun asymmToSymm() = false.
letfun IandRSupportSameCiphersuite() = true.

(* Privacy *)
(*
query x:key; attacker (idI(pk(new skU))) phase 0 ==>
  (event (LTK_Reveal(new skU)) || event (SessK3A_Reveal(x, new skU))).
query x:key; attacker (idR(pk(new skU))) phase 0 ==>
  (event (LTK_Reveal(new skU)) || event (SessK2A_Reveal(x, new skU))).

query x:key; attacker (idI(pk(new skU))) phase 1 ==>
  (event (LTK_Reveal(new skU)) || event (SessK3A_Reveal(x, new skU))).
query x:key; attacker (idR(pk(new skU))) phase 1 ==>
  (event (LTK_Reveal(new skU)) || event (SessK2A_Reveal(x, new skU))).
*)

(* Secrecy Asymmetric *)
(*
query skU:key, skV:key, S_V:bitstring, K_2:key;
  attacker (APP_2A(pk(skU),skV,S_V,K_2)) phase 0 ==>
   (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:key, skV:key, S_V:bitstring, K_2:key;
  attacker (APP_2A'(pk(skU),skV,S_V,K_2)) phase 0 ==>
   (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:key, skV:key, S_U:bitstring, K_3:key;
  attacker (APP_3A(skU,pk(skV),S_U,K_3)) phase 0 ==>
   (event (LTK_Reveal(skV)) || event (SessK3A_Reveal(K_3, new skU))).
*)

(* Secrecy Symmetric *)
(*
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S(PSK, S_U, K_2)) phase 0 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S'(PSK, S_U, K_2)) phase 0 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_V:bitstring, K_3 : key;
  attacker (APP_3S(PSK, S_V, K_3)) phase 0 ==>
    (event (PSK_Reveal(PSK)) || event (SessK3S_Reveal(K_3))).
*)

(* Perfect Forward Secrecy Asymmetric *)
(*
query skU:key, skV:key, S_V:bitstring, K_2:key;
  attacker (APP_2A(pk(skU),skV,S_V,K_2)) phase 1 ==>
    (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:key, skV:key, S_V:bitstring, K_2:key;
  attacker (APP_2A'(pk(skU),skV,S_V,K_2)) phase 1 ==>
    (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
query skU:key, skV:key, S_U:bitstring, K_3:key;
  attacker (APP_3A(skU,pk(skV),S_U,K_3)) phase 1 ==>
    (event (LTK_Reveal(skV)) || event (SessK3A_Reveal(K_3, new skU))).
*)

(* Perfect Forward Secrecy Symmetric *)
(*
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S(PSK, S_U, K_2)) phase 1 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_U:bitstring, K_2 : key;
  attacker (APP_2S'(PSK, S_U, K_2)) phase 1 ==>
    (event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query PSK:key, S_V:bitstring, K_3 : key;
  attacker (APP_3S(PSK, S_V, K_3)) phase 1 ==>
    (event (PSK_Reveal(PSK)) || event (SessK3S_Reveal(K_3))).
*)

(* Injective agreement Asymmetric *)
(*
query U: host, U': host, V: host, E_V: dhElt, skV : key;
  inj-event (midInitiatorA(U, V, E_V)) ==>
    (inj-event (startResponderA(U', V, E_V, skV)) || event (LTK_Reveal(skV))).
query U: host, V: host, E_U: dhElt, skU : key;
  inj-event (endResponderA(U, V, E_U)) ==>
    (inj-event (startInitiatorA(U, V, E_U, skU)) || event (LTK_Reveal(skU))).
query U: host, U': host, V: host, E_V: dhElt, skV : key;
  inj-event (endInitiatorA(U, V, E_V)) ==>
    inj-event (startResponderA(U', V, E_V, skV)) || event (LTK_Reveal(skV)).
*)

(* Injective agreement Symmetric *)
(*
query U: host, U': host, V: host, PSK: key, E_V: dhElt;
  inj-event (midInitiatorS(U, V, PSK, E_V)) ==>
    inj-event (startResponderS(U', V, PSK, E_V)) || event (PSK_Reveal(PSK)).
query U: host, U': host, V: host, PSK: key, E_V: dhElt;
  inj-event (endInitiatorS(U, V, PSK, E_V)) ==>
    inj-event (startResponderS(U', V, PSK, E_V)) || event (PSK_Reveal(PSK)).
query U: host, V: host, PSK: key, E_U: dhElt;
  inj-event (endResponderS(U, V, PSK, E_U)) ==>
    inj-event (startInitiatorS(U, V, PSK, E_U)) || event (PSK_Reveal(PSK)).
*)

(* CONTENT (algorithm) agreement Asymmetric *)
(*
query U: host, V: host, K_2: key, skV : key, aad_2 : bitstring;
  event (agreeHashEnd2A(U, V, K_2, aad_2)) ==>
    (event (agreeHashStart2A(U, V, K_2, aad_2, skV)) || event (LTK_Reveal(skV)) || event (SessK2A_Reveal(K_2, new skU))).
query U: host, V: host, K_3: key, skU : key, aad_3 : bitstring;
  event (agreeHashEnd3A(U, V, K_3, aad_3)) ==>
    (event (agreeHashStart3A(U, V, K_3, aad_3, skU)) || event (LTK_Reveal(skU)) || event (SessK3A_Reveal(K_3, new skU))).
*)

(* CONTENT (algorithm) agreement Symmetric *)
(*
query U: host, V: host, K_2: key, PSK : key, aad_2 : bitstring;
  event (agreeHashEnd2S(U, V, K_2, aad_2)) ==>
    (event (agreeHashStart2S(U, V, K_2, aad_2, PSK)) || event (PSK_Reveal(PSK)) || event (SessK2S_Reveal(K_2))).
query U: host, V: host, K_3: key, PSK : key, aad_3 : bitstring;
  event (agreeHashEnd3S(U, V, K_3, aad_3)) ==> (event
    (agreeHashStart3S(U, V, K_3, aad_3, PSK)) || event (PSK_Reveal(PSK)) || event (SessK3S_Reveal(K_3))).
*)




(* Session key secrecy and session key independence.
 * Idea: Only way for attacker to get hold of session k key
 *       is if he has access to the LTK.
 *       Expressing this as a correspondence property we write:
 *          if attacker knows the session key it must be because he knew
 *             the LTK.
 *       We don't accept that he got it any other way.
 *       Specifically, even if he knows other session keys but not the LTK,
 *       he should still not get the session key, i.e., sesssion key independence.
 *)
(*
query skU:key, skV:key, S_V:bitstring, K_2:key;
  attacker(

  attacker (APP_2A(pk(skU),skV,S_V,K_2)) phase 0 ==>
   (event (LTK_Reveal(skU)) || event (SessK2A_Reveal(K_2, new skU))).
*)


(* Entity authentication *)
(* (initiator, responder, sessionKeyMaterial) *)
event evRunningI(host, host, dhElt, dhElt, dhElt).
event evCommitI(host, host, dhElt, dhElt, dhElt).

(* (responder, sessionKeyMaterial)
 * Responder does not know who Initiator is yet, so we can't bind in I
 *)
event evRunningR(host, dhElt, dhElt, dhElt).
(* When completed Responder knows who I is, so both hostnames included *)
event evCommitR(host, host, dhElt, dhElt, dhElt).

query U: host, V: host, gxy: dhElt, giy: dhElt, grx: dhElt;
      inj-event(evCommitI(U, V, gxy, giy, grx)) ==> inj-event(evRunningR(V, gxy, giy, grx)).
query U: host, V: host, gxy: dhElt, giy: dhElt, grx: dhElt;
      inj-event(evCommitR(U, V, gxy, giy, grx)) ==> inj-event(evRunningI(U, V, gxy, giy, grx)).


(* Sanity *)
event evInitiatorCompleted(method, method).
event evResponderCompleted(method, method).
(*
query event(evInitiatorCompleted(METHOD_SIG, METHOD_SIG)).
query event(evInitiatorCompleted(METHOD_SIG, METHOD_STAT)).
query event(evInitiatorCompleted(METHOD_STAT, METHOD_SIG)).
query event(evInitiatorCompleted(METHOD_STAT, METHOD_STAT)).
query event(evResponderCompleted(METHOD_SIG, METHOD_SIG)).
query event(evResponderCompleted(METHOD_SIG, METHOD_STAT)).
query event(evResponderCompleted(METHOD_STAT, METHOD_SIG)).
query event(evResponderCompleted(METHOD_STAT, METHOD_STAT)).
*)

let initiatorAsym(U: host, V: host, skU: exponent, pkU: dhElt, pkV: dhElt,
    methodI: method, methodR: method) =
  new x[]: exponent; let G_X = exp(g, x) in new S_I[]: bitstring;
  new AD_1[]: bitstring; new C_I[]: ctxID;
  (*
  event startInitiatorSigSig(U, V, G_X, skU, C_I);
   *)
  let msg_1: bitstring = ((methodI, methodR), S_I, G_X, C_I, AD_1) in
  out(c, msg_1);
  in(c, msg_2: bitstring);
  let (data_2: bitstring, CIPHERTEXT_2: bitstring) = msg_2 in

  (* Because we don't model the CORR parameter, we assumme the worst
   * and cover the case that C_I is inlcuded in the message.
   *)
  let (=C_I, G_Y: dhElt, C_R: ctxID) = data_2 in
  let G_XY: dhElt = exp(G_Y, x) in
  let TH_2: bitstring = hash((msg_1, data_2)) in
  let PRK_2e: key = PRK_2e_asym(G_XY) in
  let K_2e: key = K_2e_KDF(PRK_2e, TH_2, aead0) in

  (* CIPHERTEXT_2 contains a COSE_Encrypt0 object. The COSE_Encrypt0 object
   * has three main parts, unprotected headers, protected headers and
   * ciphertext. RFC 8152 is not entirely clear, but it seems as if
   * the protected headers should be part of the AAD for the AEAD.
   *)
   (* The verifObj contains either a MAC_2 or a Signature_2 object *)
  let plainText2:bitstring = xorDecrypt(CIPHERTEXT_2, keyToBitstring(K_2e)) in
  let (=V, verifObj:bitstring, AD_2:bitstring) = plainText2 in
(* KARL: not sure this is in the spec or not. Either way: the spec talks
 * about protection against reflection attacks in Section 8.6, so it should be
 * inlcuded: not allowed for initator to communicate with itself.
 *)
if not (V = U) then

  let G_RX: dhElt = exp(pkV, x) in
  let PRK_3e2m: key = PRK_3e2m_asym(G_XY, G_RX, methodI, methodR) in
  let K_2m: key = K_2m_KDF(PRK_3e2m, TH_2, aead0) in

  (* MAC_2 covers aadData_2 and the empty string.
   * Signature_2 covers aadData_2 and MAC_2 itself.
   * DIFF: In spec MAC_2 is also computed over a constant "Encrypt0" and the
   * Signature_2 is computed over a constant "Signature1". We ignore that in
   * the model.
   *
   * EDHOC Section 4.3.2 defines the COSE_Encrpt0 objects content:
   * Protected: ID_CRED_R              ==> V in the model's aadData_2
   * external_aad: TH_2, CRED_R, AD_2  ==> (TH_2, pkV, AD_2) aadData_2
   *
   * The following AEAD encryption is the so called "inner COSE_Encrypt0",
   * which is an encryption of the empty string for the only purpose of
   * producing a MAC.
   * We need it both for verifying MAC_2 and for verifying Signature1.
   *)
  let protected2: host = V in (* ID_CRED_R in protected header *)
  let extAad2: bitstring = (TH_2, pkV, AD_2) in (* external_aad *)
  let assocData2: bitstring = (protected2, extAad2) in (* Associated data A *)

  (* FEEDBACK: the spec does not specify how to check the signature, depending on
     whether it's using static DH or COSE_Sign
  let MAC_2: bitstring = aeadEncrypt(emptyHexString, K_2m, aadData_2) in
  if (methodR = METHOD_SIG && verifySign((aadData_2, MAC_2), verifObj, pkV)) ||
  *)
  if (methodR = METHOD_STAT && verifyAEADSign(assocData2, verifObj, K_2m, pkV)) ||
     (methodR = METHOD_SIG && verifyAEAD(assocData2, verifObj, K_2m)) then
  (*
  event agreeHashEnd2A(U, V, K_2, aad_2);
  event midInitiatorA(U, V, xE_V);
  *)
  let data_3: ctxID = C_R in
  let TH_3: bitstring = hash((TH_2, CIPHERTEXT_2, data_3)) in
  let G_IY: dhElt = exp(G_Y, skU) in (* only used if methodI=static *)
  let PRK_4x3m: key = PRK_4x3m_asym(G_XY, G_RX, G_IY, methodI, methodR) in
  let K_3m: key = K_3m_KDF(PRK_4x3m, TH_3, aead0) in
  new AD_3[]: bitstring;
  let protected3: host = U in  (* ID_CRED_I in protected header *)
  let extAad3: bitstring = (TH_3, pkU, AD_3) in (* external_aad *)
  let assocData3: bitstring = (protected3, extAad3) in (* Associated data A *)
  let MAC_3: bitstring = aeadEncrypt(emptyHexString, K_3m, assocData3) in
  (* authI is the "inner COSE_Encrypt0" object *)
  let authI: bitstring = if methodI = METHOD_STAT then
                            sign((assocData3, MAC_3), skU)
                         else
                            MAC_3
                         in
  (* Now compute the "outer COSE_Encrypt0" object *)
  let plainText3 = (U, authI, AD_3) in
  let K_3ae: key = K_3ae_KDF(PRK_4x3m, TH_3, aead0) in
  let extAad3_outer = TH_3 in
  let CIPHERTEXT_3: bitstring = aeadEncrypt(plainText3, K_3ae, extAad3_outer) in
  let msg_3: bitstring = (data_3, CIPHERTEXT_3) in

  (* We treat (PRK_4x3m, TH_4) as the session key to be agreed upon *)
  let TH_4: bitstring = hash((TH_3, CIPHERTEXT_3)) in
  event evRunningI(U, V, G_XY, G_IY, G_RX);
  out(c, msg_3);
  (*
  event endInitiatorA(U, V, xE_V);
  (if revealSessKeys() then
     (event SessK2A_Reveal(K_2, skU); out(c, K_2))).
   *)
  event evCommitI(U, V, G_XY, G_IY, G_RX);
  event evInitiatorCompleted(methodI, methodR). (* Sanity *)

let responderAsym(V: host, U: host, skV: exponent, pkV: dhElt, pkU: dhElt) =
  new y[]: exponent;
  let G_Y: dhElt = exp(g, y) in
  new S_R[]: bitstring;
  new C_R[]: bitstring;
  (*
  event startResponderA(U, V, E_V, skV, C_U);
   *)
  in(c, msg_1: bitstring);
  let ((methodI: method, methodR: method), S_I: bitstring, G_X: dhElt, C_I: ctxID, AD_1: bitstring) = msg_1 in
  (* DIFF: model does not send an error message back if R does not support
   * the proposed ciphersuite.  Instead the model just halts.
   *)
  if IandRSupportSameCiphersuite() = true then
  let data_2: bitstring = (C_I, G_Y, C_R) in
  let TH_2: bitstring = hash((msg_1, data_2)) in
  let G_IY: dhElt = exp(pkU, y) in   (* only used if methodI=static *)
  let G_RX: dhElt = exp(G_X, skV) in (* only used if methodR=static *)
  let G_XY: dhElt = exp(G_X, y) in
  let PRK_3e2m: key = PRK_3e2m_asym(G_XY, G_RX, methodI, methodR) in
  let K_2m: key = K_2m_KDF(PRK_3e2m, TH_2, aead0) in
  new AD_2: bitstring;
  let protected2: host = V in (* ID_CRED_R in protected header *)
  let extAad2: bitstring = (TH_2, pkV, AD_2) in (* external_aad *)
  let assocData2: bitstring = (protected2, extAad2) in (* Associated data A *)
  (* TODO: assocData2 should map to arrays of COSE structs similar to spec *)
  let MAC_2: bitstring = aeadEncrypt(emptyHexString, K_2m, assocData2) in
  let authR: bitstring = if methodR = METHOD_STAT then
                            sign((assocData2, MAC_2), skV)
                         else (* i.e., METHOD_SIG *)
                            MAC_2
                         in
  let plainText2: bitstring = (V, authR, AD_2) in
  let PRK_2e: key = PRK_2e_asym(G_XY) in
  let K_2e: key = K_2e_KDF(PRK_2e, TH_2, aead0) in
  let CIPHERTEXT_2: bitstring = xorEncrypt(plainText2, keyToBitstring(K_2e)) in
  let msg_2: bitstring = (data_2, CIPHERTEXT_2) in
(* event agreeHashStart2A(U, V, K_2, aad_2, skV); *)
  event evRunningR(V, G_XY, G_IY, G_RX);
  out(c, msg_2);
  in(c, msg_3: bitstring);
  let (data_3: bitstring, CIPHERTEXT_3: bitstring) = msg_3 in
  let (=C_R) = data_3 in
  let TH_3: bitstring = hash((TH_2, CIPHERTEXT_2, data_3)) in
  let PRK_4x3m: key = PRK_4x3m_asym(G_XY, G_RX, G_IY, methodI, methodR) in
  let K_3ae: key = K_3ae_KDF(PRK_4x3m, TH_3, aead0) in
  let extAad3_outer: bitstring = TH_3 in
  let plainText3: bitstring = aeadDecrypt(CIPHERTEXT_3, K_3ae, extAad3_outer) in
  let (=U, verifObj: bitstring, AD_3: bitstring) = plainText3 in
  let K_3m: key = K_3m_KDF(PRK_4x3m, TH_3, aead0) in
  let protected3: host = U in (* ID_CRED_I in protected header *)
  let extAad3: bitstring = (TH_3, pkU, AD_3) in (* external_aad *)
  let assocData3: bitstring = (protected3, extAad3) in (* Associated data A *)
  if (methodI = METHOD_STAT && verifyAEADSign(assocData3, verifObj, K_3m, pkU)) ||
     (methodI = METHOD_SIG && verifyAEAD(assocData3, verifObj, K_3m)) then
  let TH_4: bitstring = hash((TH_3, CIPHERTEXT_3)) in

  event evCommitR(U, V, G_XY, G_IY, G_RX);
  event evResponderCompleted(methodI, methodR). (* Sanity *)


let initiatorSym(U: host, V: host, PSK: key, ID_PSK: bitstring) =
  new x: exponent;
  let E_U: dhElt = exp(g, x) in
  new C_I: ctxID;
  new S_U: bitstring;
  new AD_1: bitstring;
  new AD_3: bitstring;
  new Mc: bitstring;
  event startInitiatorS(U, V, PSK, E_U);
  let msg_1: bitstring = (Mc, S_U, E_U, C_I, ID_PSK, AD_1) in
  out(c, msg_1);
  (* event evInitiatorStarted; *)
  in(c, msg_2: bitstring);
  let (data_2: bitstring, COSE_enc_2: bitstring) = msg_2 in
  let (=C_I, xE_V: dhElt, xC_R: ctxID) = data_2 in
  let TH_2: bitstring = hash((msg_1, data_2)) in
  let G_XY: dhElt = exp(xE_V, x) in
  let PRK_2e: key = PRK_2e_sym(PSK, G_XY) in
  let K_2: key = K_2e_KDF(PRK_2e, TH_2, aead0) in (* ALE: using a default ciphersuite *)
  let aad_2: bitstring = (emptyHexString, TH_2) in
  let AD_2: bitstring = aeadDecrypt(COSE_enc_2, K_2, aad_2) in
  event midInitiatorS(U, V, PSK, xE_V);
  let data_3: ctxID = xC_R in
  let TH_3: bitstring = hash((hash((msg_1, msg_2)), data_3)) in
  let aad_3: bitstring = (emptyHexString, TH_3) in
  let PRK_3e2m: key = PRK_3e2m_sym(PSK, G_XY) in
  let K_3: key = K_3ae_KDF(PRK_3e2m, TH_3, aead0) in
  let COSE_enc_3: bitstring = aeadEncrypt(AD_3, K_3, aad_3) in
  let msg_3: bitstring = (data_3, COSE_enc_3) in
  out(c, msg_3);
  let TH_4: bitstring = hash((TH_3, COSE_enc_3)) in
  event endInitiatorS(U, V, PSK, xE_V).

let responderSym(V: host, U: host, PSK: key, ID_PSK: bitstring) =
  new y: exponent;
  let E_V: dhElt = exp(g, y) in
  new C_R: ctxID;
  new AD_2: bitstring;
  new AD_2': bitstring;
  event startResponderS(U, V, PSK, E_V);
  in(c, msg_1: bitstring);
  (* event evResponderStarted; *)
  let (Mc: bitstring, xS_U: bitstring, xE_U: dhElt, xC_I: ctxID, =ID_PSK, AD_1: bitstring) = msg_1 in
  if IandRSupportSameCiphersuite() = true then
  let data_2: bitstring = (xC_I, E_V, C_R) in
  let TH_2: bitstring = hash((msg_1, data_2)) in
  let G_XY: dhElt = exp(xE_U, y) in
  let PRK_2e: key = PRK_2e_sym(PSK, G_XY) in
  let K_2: key = K_2e_KDF(PRK_2e, TH_2, aead0) in (* ALE: using a default ciphersuite *)
  let aad_2: bitstring = (emptyHexString, TH_2) in
  let COSE_enc_2: bitstring = aeadEncrypt(AD_2, K_2, aad_2) in
  let msg_2: bitstring = (data_2, COSE_enc_2) in
	  (* event evStart((U, V, PRK_2e)); *)  (* KARL: I removed this to be able to compile *)
  out(c, msg_2);
  in(c, msg_3: bitstring);
  let (=C_R, COSE_enc_3: bitstring) = msg_3 in
  let TH_3: bitstring = hash((hash((msg_1, msg_2)), C_R)) in
  let PRK_3e2m: key = PRK_3e2m_sym(PSK, G_XY) in
  let K_3: key = K_3ae_KDF(PRK_3e2m, TH_3, aead0) in
  let aad_3: bitstring = (emptyHexString, TH_3) in
  let AD_3: bitstring = aeadDecrypt(COSE_enc_3, K_3, aad_3) in
  let TH_4: bitstring = hash((TH_3, COSE_enc_3)) in
  event endResponderS(U, V, PSK, xE_U).


(*
  event agreeHashEnd3A(U, V, K_3, aad_3);
  event endResponderA(U, V, xE_U);
*)

process
  (!new U: host;              (* In EDHOC: ID_CRED_R or ID_CRED_I *)
    new skU: exponent;        (* private key *)
    let pkU = exp(g, skU) in  (* In EDHOC: CRED_R or CRED_I *)
    (!out(s, (U, skU, pkU))) | out(c, (pkU)) |
    (if maliciousPrincipals() then event LTK_Reveal(skU); out(c, skU))
  ) | (
   !in(s, (U:host, skU:exponent, pkU:dhElt));
    in(s, (V:host, skV:exponent, pkV:dhElt));
    new ID_PSK: bitstring;
    new PSK: key;
    out(s2, (U, V, PSK, ID_PSK));
    (if maliciousPrincipals() then event PSK_Reveal(PSK); out(c, PSK))
  ) | (
   !in(s, (methodI:method, methodR:method));
    in(s, (U:host, skU:exponent, pkU:dhElt));
    in(s, (V:host, skV:exponent, pkV:dhElt));
    initiatorAsym(U, V, skU, pkU, pkV, methodI, methodR) |
    responderAsym(V, U, skV, pkV, pkU)
  ) | (
   !in(s2, (U:host, V:host, PSK: key, ID_PSK: bitstring));
    initiatorSym(U, V, PSK, ID_PSK) | responderSym(V, U, PSK, ID_PSK)
  ) | !(
(*    out(s, (METHOD_SIG, METHOD_SIG)) |
    out(s, (METHOD_SIG, METHOD_STAT)) |
    out(s, (METHOD_STAT, METHOD_SIG)) | *)
    out(s, (METHOD_STAT, METHOD_STAT))
  )

(*
process
  (!new U: host;
    new skU: exponent;
    let pkU = exp(g, skU) in
    !out(s, (U, skU, pkU)); out(s, (U, skU, pkU));
    out(c, (pkU));
    ((if maliciousPrincipals() then event LTK_Reveal(skU); out(c, skU)) | phase 1; out(c, skU)) ) |
  (!in(s, (U:host, skU:key, pkU:key));
    in(s, (V:host, skV:key, pkV:key));
    new random[]: bitstring;
    let PSK = HKDF(g, random, empty, EDHOC_PRESHARED) in
    out(s2, (U, V, PSK)); out(s2, (U, V, PSK))
    ((if maliciousPrincipals() then event PSK_Reveal(PSK); out(c, PSK)) | phase 1; out(c, PSK)) ) |
  (!in(s, (U:host, skU:key, pkU:key));
    in(s, (V:host, skV:key, pkV:key));
    (initiatorAsym(U, V, skU, pkU, pkV) |
     responderAsym(V, U, skV, pkV, pkU)) ) |
  (!in(s2, (U:host, V:host, PSK:key));
    (initiatorSym(U, V, PSK) |
     responderSym(V, U, PSK)) )
*)

