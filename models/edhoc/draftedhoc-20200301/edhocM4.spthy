changequote(`<!', `!>')
ifelse(m4ATTACKER, PASSIVE, <!define(Out, Msg($1)) define(In, Msg($1))!>, )
theory <!edhoc_!>m4METHODI<!_!>m4METHODR<!_!>m4ATTACKER
begin
builtins: diffie-hellman, xor, signing, hashing

/* WoW: Naming conventions:
 *  - camelCase for functions and properties
 *  - constants (0-arity functions) begin with "c"
 *  - do not use variable/constant names: x, y, vk (used by Tamarin internally,
 *                                                  and show up in the trace)
 *  - m4 macros are prefixed with m4 and the rest is all caps
 *  - begin sanity properties with "santity"    -- helps oracle
 *  - begin secrecy properties with "secrecy"   -- helps oracle
 *  - begin agreement properties with "agree"   -- helps oracle
 *
 */
functions:
    aeadEncrypt/4,  // Input: Key, plain-text, aad, cAEADx (AEAD algo ID)
    aeadDecrypt/4,  // Input: Key, cipher-text, aad, cAEADx (AEAD algo ID)
    decrypt/3,      // Input: Key, cipher-text, cAEADx (AEAD algo ID);
    //xorEncrypt/2,   // Input: Key, plain-text
    //xorDecrypt/2,   // Input: Key, cipher-text
    hkdfExtract/2,  // Input: Salt, random source
    hkdfExpand/2,   // Input: Salt, uniform random source
    cEmptyStr/0,
    cSUITE0/0,
        cAEAD0/0,   // cAEAD0 is part of cSUITE0 is the idea
        cHash0/0,   // cHash0 is part of cSUITE0 is the idea
    cSUITE1/0,
        cAEAD1/0,
        cHash1/0

equations:
    aeadDecrypt(key, aeadEncrypt(key, pt, aad, algoId), aad, algoId) = pt,
    decrypt(key, aeadEncrypt(key, pt, aad, algoID), algoId) = pt
    //xorDecrypt(k, xorEncrypt(k, pt)) = pt   // Too strong


restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"

/* ifelse(<!SIG!>, m4METHODI, */
/*     <!restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"!>, */
/*     <!ifelse(<!SIG!>, m4METHODR, */
/*         <!restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"!>, */
/*         <!!> /1* NOTHING *1/ */
/*     )!> */
/* ) */


//restriction Neq:
    //"All x y #i. Neq(x, y)@i ==> not(x = y)"

rule <!I1_!>m4METHODI<!_!>m4METHODR:
    let gx = 'g'^~xx
 //    ifdef(<!m4CI!>,
	//    <!cI = ~C_I!>
	// )
	// ifdef(<!m4AD1!>,
	// 	<!plainText1 = ~AD_1!>
	// )
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <!
        	ID_PSK = <$U, $V>
        	ifdef(<!m4CI!>,	
        		<! 
                    ifdef(<!m4AD1!>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I, ID_PSK, ~AD_1> !>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I, ID_PSK> !>
                    )
                !>,
        		<! 
                    ifdef(<!m4AD1!>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ID_PSK, ~AD_1> !>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ID_PSK> !>
                    )
                !>
        	)
        !>,
        <! 
        	ifdef(<!m4~C_I!>,
        		<! 
                    ifdef(<!m4AD1!>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I, ~AD_1> !>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I> !>
                    )
                !>,
        		<! 
                    ifdef(<!m4AD1!>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~AD_1> !>,
                        <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx> !>
                    )
                !>
        	)
        !>
)
    in
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        [ !<!LTK_!>m4METHODI<!!>(<$U, $V>, ~ltk),
        [ !<!LTK_!>m4METHODI<!!>($U, ~ltk)
)
        , Fr(~xx)
        ifdef(<!m4CI!>,
        	<! , Fr(~C_I) !>
        )
        ifdef(<!m4AD1!>,
        	<! , Fr(~AD_1) !>
        )
        , Fr(~tid)  /* Thread ID */
        ]
        --[ I1(~tid, $U, $V, m1)
          , DHInvI1(~tid, 'g', ~xx, 'g'^inv(~xx), 'g'^~xx, 'g'^inv(~ltk))
          , InvI1(~tid, ~xx, inv(~xx), ~ltk, inv(~ltk))
          ]->
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
		<!
		    ifdef(<!m4CI!>,
                <! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, ~C_I, m1, ~tid) !>,
                <! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, m1, ~tid) !>
            )
        !>,
        <!
            ifdef(<!m4CI!>,
                <! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, ~C_I, m1, ~tid) !>,
                <! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, m1, ~tid) !>
            )
        !>
)
        , Out(m1)
        ]

rule <!R2_!>m4METHODI<!_!>m4METHODR:
		let
    	// ifdef(<!m4CR!>,
    	// 	<!cR = ~C_R!>
    	// )
        // ifdef(<!m4CI!>,
	    //   <!cI = ~C_I!>
		// )
        //ifdef(<!m4AD1!>,
		//<!~AD_1 = ~AD_1!>
		//)
    	ifdef(<!m4CI!>,
    		<!ifdef(<!m4CR!>,
         		<!data_2 = <~C_I, 'g'^~yy, ~C_R>!>,
         		<!data_2 = <~C_I, 'g'^~yy>!>
         	)!>,
         	<!ifdef(<!m4CR!>,
         		<!data_2 = <'g'^~yy, ~C_R>!>,
         		<!data_2 = <'g'^~yy>!>
         	)!>
        )
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <!ID_PSK = <$U, $V>
        ifdef(<!m4CI!>,
         	<! 
                ifdef(<!m4AD1!>,
                    <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I, ID_PSK, ~AD_1> !>,
                    <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I, ID_PSK> !>
                )
            !>,
         	<! 
                ifdef(<!m4AD1!>,
                    <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ID_PSK, ~AD_1> !>,
                    <! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ID_PSK> !>
                )
            !>
         )
         TH_2 = h(<$cHash0, m1, data_2>)
         prk_2e = hkdfExtract(~ltk, gx^~yy)
         prk_3e2m = prk_2e
         extAad2 = TH_2
         ifdef(<!m4AD2!>,
         	<!plainText2 = ~AD_2!>,
         	<!plainText2 = 'emptyStr'!>
         )
         K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
         CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)
        !>,
        <!
        ifdef(<!m4CI!>,
        	<! 
        		ifdef(<!m4AD1!>,
        			<! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I, ~AD_1> !>,
        			<! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~C_I> !>
        		)
        	!>,
        	<!
        		ifdef(<!m4AD1!>,
        			<! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx, ~AD_1> !>,
        			<! m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $cSUITE0, gx> !>
        		)
        	!>
        )
         TH_2 = h(<$cHash0, m1, data_2>)
         prk_2e = hkdfExtract('emptyStr', gx^~yy)
         ifelse(<!STAT!>, m4METHODR,
                 <!grx = gx^~ltk
                  prk_3e2m = hkdfExtract(prk_2e, grx)!>,
                 <!prk_3e2m = prk_2e!>
         )
         K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
         protected2 = $V // ID_CRED_V
         CRED_V = pkV
         extAad2 = <TH_2, CRED_V>
         assocData2 = <protected2, extAad2>
         MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
         ifelse(<!SIG!>, m4METHODR,
            <!authV = sign(<assocData2, MAC_2>, ~ltk)!>,
            <!authV = MAC_2!>
         )
         ifdef(<!m4AD2!>,
         	<!plainText2 = <$V, authV, ~AD_2>!>,
         	<!plainText2 = <$V, authV>!>
         )
         K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
         /* K_2e is split in two parts to allow attacker to attack them
          * individually
          */
         K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
         K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
         CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2>
         /* VAISHNAVI: CIPHERTEXT_2 is actually plainText2 XOR K_2e. How do I deal with this when plainText2 can also have AD_2? */
        !>
)
         m2 = <data_2, CIPHERTEXT_2>



/* Def of session key exp_sk we can get explicit auth (agreement) on */
/* I.e., exp_sk does not include G_IY */
ifelse(<!STAT_SIG!>, m4METHODI<!_!>m4METHODR,
    <!exp_sk = <gx^~yy>!>,  // Responder does not know G_IY when sending m2
    <!ifelse(<!SIG_STAT!>, m4METHODI<!_!>m4METHODR,
        <!exp_sk = <gx^~yy, grx>!>,
        <!ifelse(<!STAT_STAT!>, m4METHODI<!_!>m4METHODR,
            <!exp_sk = <gx^~yy, grx>!>, // Responder does not know G_IY when sending m2
            <!exp_sk = <gx^~yy>!> // SIG_SIG or PSK_PSK
        )!>
    )!>
)

    in
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        [ <!!LTK_!>m4METHODR<!(<$U, $V>, ~ltk)!>,
        [ <!!LTK_!>m4METHODR<!($V, ~ltk)
        ,  !PK_!>m4METHODR<!($V, pkV)!>
)
        , In(m1)
        , Fr(~yy)
        ifdef(<!m4CR!>,
        	<! , Fr(~C_R) !>
        )
        ifdef(<!m4AD2!>,
        	<! , Fr(~AD_2) !>
        )
        , Fr(~tid)
        ]
        ifdef(<!m4CI!>,
        <! 
        	ifdef(<!m4CR!>,
        		<!--[ ExpRunningR(~tid, $V, exp_sk, ~C_I, ~C_R)!>,
        		<!--[ ExpRunningR(~tid, $V, exp_sk, ~C_R)!>
        	)
        !>,
        <!
        	ifdef(<!m4CR!>,
        		<!--[ ExpRunningR(~tid, $V, exp_sk, ~C_R)!>,
        		<!--[ ExpRunningR(~tid, $V, exp_sk)!>
        	)
        !>
        )
          , R2(~tid, $V, m1, m2)
          , InvR2(~tid, ~yy, inv(~yy), ~ltk, inv(~ltk))
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
          <!!>,
          <!!> //<!, R2Mac(~tid, MAC_2, gx, 'g'^~yy, gx^~yy, K_2m)!>
)
          ]->
ifelse(<!STAT!>, m4METHODR,
		ifdef(<!m4CI!>,
        <! 
        	ifdef(<!m4CR!>,
        		<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_I, ~C_R, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2)!>,
        		<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_I, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2)!>
        	)
        !>,
        <!
        	ifdef(<!m4CR!>,
        		<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2)!>,
        		<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2)!>
        	)
        !>
        )
        ,
        <! ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
            <! 
            	ifdef(<!m4CI!>, 
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~C_R, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>
            			)
            		!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~C_R, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>
            			)
            		!>
            	)
            !>,
            <! 
            	ifdef(<!m4CI!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>
            			)
            		!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) !>
            			)
            		!>
            	)
            !>
        )!>
)
        , Out(m2)
        ]


rule <!I3_!>m4METHODI<!_!>m4METHODR<!!>:
    let
    	ifdef(<!m4CI!>,
        		<! 
        			ifdef(<!m4CR!>,
        				<! data_2 = <~C_I, gy, ~C_R> !>,
        				<! data_2 = <~C_I, gy> !>
        			)
        		!>,
        		<! 
        			ifdef(<!m4CR!>,
        				<! data_2 = <gy, ~C_R> !>,
        				<! data_2 = <gy> !>
        			)
        		!>
            )
    /* Message 2 handling */
         TH_2 = h(<$cHash0, m1, data_2>)
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <!prk_2e = hkdfExtract(~ltk, gy^~xx)
         prk_3e2m = prk_2e
         ifdef(<!m4AD2!>, 
         	<! plainText2 = ~AD_2 !>,
         	<! plainText2 = 'emptyStr' !>
         )
         extAad2 = TH_2     // KARL: Why is not AD_2 covered in PSK case? Not necesssary, but it is included for the ASYM cases
         K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
         CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0) // MAC check by pattern matching
         m2 = <data_2, CIPHERTEXT_2>
        !>,
         /* STAT and SIG methods */
        <!prk_2e = hkdfExtract('emptyStr', gy^~xx)
        ifdef(<!m4AD2!>,
         	<! plainText2 = <$V, authR, ~AD_2> !>,
         	<! plainText2 = <$V, authR> !>
         )
         CRED_V = pkV
         ifelse(<!STAT!>, m4METHODR,
            <!grx = CRED_V^~xx
             prk_3e2m = hkdfExtract(prk_2e, grx)!>
             ,
            <!prk_3e2m = prk_2e!>
         )
         /* K_2e is split in two parts to allow attacker to attack them
          * individually
          */
         K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
         K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
         

         ifdef(<!m4AD2!>,
            <! 
                K_2e_3 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '3'>, prk_2e)
                CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2, ~AD_2 XOR K_2e_3> 
            !>,
            <! CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2> !>
         )
         /* VAISHNAVI: When we have the AD_2 flag set, the ciphertext is a 3-tuple. It's a 2-tuple otherwise. This is only a modelling artefact, and not "exploitable", but it might perhaps be nice to have some uniformity in this as well? */
         
         m2 = <data_2, CIPHERTEXT_2>

         K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
         protected2 = $V // ID_CRED_V
         ifdef(<!m4AD2!>, 
         	<! extAad2 = <TH_2, CRED_V, ~AD_2> !>,
         	<! extAad2 = <TH_2, CRED_V> !>
         )
         assocData2 = <protected2, extAad2>
         MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
        !>
)

    /* Message 3 handling */
    	ifdef(<!m4CR!>,
         	<! data_3 = ~C_R !>,
         	<! data_3 = 'emptyStr' !>
         ) 
         TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
         K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <!extAad3 = TH_3
ifdef(<!m4AD3!>,
         <!plainText3 = ~AD_3!>,
         <!plainText3 = 'emptyStr'!>
)
         CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)!>,
         /* STAT and SIG methods */
        <!ifelse(<!STAT!>, m4METHODI,
            <!giy = gy^~ltk
             prk_4x3m = hkdfExtract(prk_3e2m, giy)!>,
            <!prk_4x3m = prk_3e2m!>
         )
         K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
         protected3 = $U // ID_CRED_U
         CRED_U = pkU
ifdef(<!m4AD3!>,
         <!extAad3 = <TH_3, CRED_U, ~AD_3>!>,
         <!extAad3 = <TH_3, CRED_U>!>
)
         assocData3 = <protected3, extAad3>
         MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
         ifelse(<!SIG!>, m4METHODI,
            <!authU = sign(<assocData3, MAC_3>, ~ltk)!>,
            <!authU = MAC_3!>
         )
ifdef(<!m4AD3!>,
         <!plainText3 = <$U, authU, ~AD_3>!>,
         <!plainText3 = <$U, authU>!>
)
         extAad3Outer = TH_3
         CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
         !>
)
         m3 = <data_3, CIPHERTEXT_3>

/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(<!STAT_SIG!>, m4METHODI<!_!>m4METHODR,
    <!exp_sk = <gy^~xx>!>,  // Responder does not know G_IY when sending m2
    <!ifelse(<!SIG_STAT!>, m4METHODI<!_!>m4METHODR,
        <!exp_sk = <gy^~xx, grx>!>,
        <!ifelse(<!STAT_STAT!>, m4METHODI<!_!>m4METHODR,
            <!exp_sk = <gy^~xx, grx>!>, // Responder does not know G_IY when sending m2
            <!exp_sk = <gy^~xx>!> // SIG_SIG or PSK_PSK
        )!>
    )!>
)

/* Def of session key imp_sk we can get explicit auth (agreement) on I->R, but only
 * implicitly on R->I because R does not know G_IY when sending message 2,
 * so I cannot deduce that R is using the same value of GIY when I completes.
 */
/* ifelse(<!STAT_SIG!>, m4METHODI<!_!>m4METHODR, */
/*     <!imp_sk = <gy^~xx, giy>!>, */
/*     <!ifelse(<!SIG_STAT!>, m4METHODI<!_!>m4METHODR, */
/*         <!imp_sk = <gy^~xx, grx>!>, */
/*         <!ifelse(<!STAT_STAT!>, m4METHODI<!_!>m4METHODR, */
/*             <!imp_sk = <gy^~xx, giy, grx>!>, */
/*             <!imp_sk = <gy^~xx>!> // SIG_SIG or PSK_PSK */
/*         )!> */
/*     )!> */
/* ) */

ifelse(<!STAT!>, m4METHODI,
    <!imp_sk = <exp_sk, giy>!>,
    <!imp_sk =  exp_sk!>
)

    in
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <! 
        	ifdef(<!m4CI!>,
        		<! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, ~C_I, m1, ~tid) !>,
        		<!  [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, m1, ~tid) !>
        	)
        !>
        ,
        <! 
        	ifdef(<!m4CI!>,
	        	<! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, ~C_I, m1, ~tid) !>,
	        	<! [ <!StI1_!>m4METHODI<!_!>m4METHODR<!!>($U, ~ltk, $V, ~xx, m1, ~tid) !>
	        )
	        <!, !PK_!>m4METHODR<!!>($V, pkV)
	        <!, !PK_!>m4METHODI<!!>($U, pkU)
        !>
)
        , In(m2)
ifdef(<!m4AD3!>,
        <!, Fr(~AD_3)!>
)
        ]
        ifdef(<!m4CI!>,
	       	<! 
	       		ifdef(<!m4CR!>,
	       			<!
	       				--[ ExpCommitI(~tid, $U, $V, exp_sk, ~C_I, ~C_R)  // standard running/commit
	          			, CommitI(~tid, $U, $V, imp_sk, ~C_I, ~C_R)  // Requires R to complete
	          		!>,
	          		<!
	          			--[ ExpCommitI(~tid, $U, $V, exp_sk, ~C_I)  // standard running/commit
	          			, CommitI(~tid, $U, $V, imp_sk, ~C_I)  // Requires R to complete
	          		!>
	          	)
	        !>,
	        <! 
	        	ifdef(<!m4CR!>,
	        		<! 
	        			--[ ExpCommitI(~tid, $U, $V, exp_sk, ~C_R)  // standard running/commit
	          			, CommitI(~tid, $U, $V, imp_sk, ~C_R)  // Requires R to complete
	          		!>,
	          		<!
	          			--[ ExpCommitI(~tid, $U, $V, exp_sk)  // standard running/commit
	          			, CommitI(~tid, $U, $V, imp_sk)  // Requires R to complete
	          		!>
	          	)
	        !> 
	    )
          , I3(~tid, $U, $V, m1, m2, m3)
          , DHInvI3(~tid, 'g'^~xx)
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
          <!!>,
          <!!> //<!, I3Mac(~tid, MAC_2, 'g'^~xx, gy, gy^~xx, K_2m)!>
)
ifelse(<!SIG!>, m4METHODR,
         <!, Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)!>,
         <!ifelse(<!STAT!>, m4METHODR,
             <!, Eq(authR, MAC_2)!>,
             <!, Eq('1', '1')!>  /* nothing; to avoid tamrarin complainging for PSK */
         )!>
)
          ]->
        [ Out(m3) ]

rule <!R4_!>m4METHODI<!_!>m4METHODR<!!>:
    let
    	ifdef(<!m4CR!>,
    		<! data_3 = ~C_R !>,
        	<! data_3 = 'emptyStr' !>
        )
        TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
        K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
       <!extAad3 = TH_3
ifdef(<!m4AD3!>,
        <!plainText3 = ~AD_3!>,
        <!plainText3 = 'emptyStr'!>
)
        CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0) // MAC check by pattern matching
       !>,
        /* STAT and SIG methods */
       <!CRED_U = pkU
        extAad3 = TH_3
ifdef(<!m4AD3!>,
        <!plainText3 = <$U, authI, ~AD_3>!>,
        <!plainText3 = <$U, authI>!>
)
        CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0) // MAC check by pattern matching
        ifelse(<!STAT!>, m4METHODI,
           <!giy = CRED_U^~yy
            prk_4x3m = hkdfExtract(prk_3e2m, giy)!>,
           <!prk_4x3m = prk_3e2m!>
        )
        K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
        protected3 = $U // ID_CRED_U
ifdef(<!m4AD3!>,
        <!extAad3 = <TH_3, CRED_U, ~AD_3>!>,
        <!extAad3 = <TH_3, CRED_U>!>
)
        assocData3 = <protected3, extAad3>
        MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
       !>
)
        m3 = <data_3, CIPHERTEXT_3>

/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(<!STAT_SIG!>, m4METHODI<!_!>m4METHODR,
    <!exp_sk = <gxy>!>,  // Responder does not know G_IY when sending m2
    <!ifelse(<!SIG_STAT!>, m4METHODI<!_!>m4METHODR,
        <!exp_sk = <gxy, grx>!>,
        <!ifelse(<!STAT_STAT!>, m4METHODI<!_!>m4METHODR,
            <!exp_sk = <gxy, grx>!>, // Responder does not know G_IY when sending m2
            <!exp_sk = <gxy>!> // SIG_SIG or PSK_PSK
        )!>
    )!>
)

/* Def of session key imp_sk we can get explicit auth (agreement) on I->R, but only
 * implicitly on R->I because R does not know G_IY when sending message 2,
 * so I cannot deduce that R is using the same value of GIY when I completes.
 */
/* ifelse(<!STAT_SIG!>, m4METHODI<!_!>m4METHODR, */
/*     <!imp_sk = <gxy, giy>!>, */
/*     <!ifelse(<!SIG_STAT!>, m4METHODI<!_!>m4METHODR, */
/*         <!imp_sk = <gxy, grx>!>, */
/*         <!ifelse(<!STAT_STAT!>, m4METHODI<!_!>m4METHODR, */
/*             <!imp_sk = <gxy, giy, grx>!>, */
/*             <!imp_sk = <gxy>!> // SIG_SIG or PSK_PSK */
/*         )!> */
/*     )!> */
/* ) */

ifelse(<!STAT!>, m4METHODI,
    <!imp_sk = <exp_sk, giy>!>,
    <!imp_sk =  exp_sk!>
)
    in
ifelse(<!STAT!>, m4METHODR,
		<!
			ifdef(<!m4CI!>,
        		<! 
        			ifdef(<!m4CR!>,
        				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, ~C_I, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>,
        				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_I, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>
        			)
        		!>,
        		<! 
        			ifdef(<!m4CR!>,
        				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>,
        				<!  [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>
        			)
        		!>
        	)
        !>,
        <!ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
            <!
            	ifdef(<!m4CI!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~C_R, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>
            			)
            		!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~C_R, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>
            			)
            		!>
            	)
            !>,
            <!
            	ifdef(<!m4CI!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>
            			) 
            		!>,
            		<! 
            			ifdef(<!m4CR!>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~C_R, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>,
            				<! [ <!StR2_!>m4METHODI<!_!>m4METHODR<!!>($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) !>
            			)
            		!>
            	)
            !>
        )!>
)
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <!!> /* NOTHING */
        , /* All other methods */
        <!, !PK_!>m4METHODI<!!>($U, pkU)
        <!, !PK_!>m4METHODR<!!>($V, pkV)
)
        , In(m3)
        ]
        ifdef(<!m4CI!>,
        	<! 
        		ifdef(<!m4CR!>,
        			<! 
        				--[ ExpCommitR(~tid, $U, $V, exp_sk, ~C_I, ~C_R)
          				, CommitR(~tid, $U, $V, imp_sk, ~C_I, ~C_R)
          			!>,
          			<! 
        				--[ ExpCommitR(~tid, $U, $V, exp_sk, ~C_I)
          				, CommitR(~tid, $U, $V, imp_sk, ~C_I)
          			!>
          		)
        	!>,
        	<!
        		ifdef(<!m4CR!>,
					<! 
						--[ ExpCommitR(~tid, $U, $V, exp_sk, ~C_R)
          				, CommitR(~tid, $U, $V, imp_sk, ~C_R)
          			!>,
          			<! 
          				--[ ExpCommitR(~tid, $U, $V, exp_sk)
          				, CommitR(~tid, $U, $V, imp_sk)
          			!>
          		)
        	!>
        )
          , R4(~tid, $U, $V, m1, m2, m3)
ifelse(<!SIG!>, m4METHODI,
         <!, Eq(verify(authI, <assocData3, MAC_3>, CRED_U), true)!>,
         <!ifelse(<!STAT!>, m4METHODI,
             <!, Eq(authI, MAC_3)!>,
             <!!>  /* nothing */
         )!>
)
          ]->
        []

/*
 * Environment and adversary model additions to standard Dolev-Yao
 */
/* Register LTK for SIG key based authentication */
rule registerLTK_SIG:
    [Fr(~ltk)] --[UniqLTK($A, ~ltk)]-> [!LTK_SIG($A, ~ltk),
                                        !PK_SIG($A, pk(~ltk)),
                                        Out(<!<$A, pk(~ltk)>!>)]

/* Register LTK for STAT key based authentication */
rule registerLTK_STAT:
    [Fr(~ltk)]
    --[UniqLTK($A, 'g'^~ltk)]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]

/* Register LTK for PSK key based authentication */
rule registerLTK_PSK:
    [Fr(~ltk)] --[UniqLTK(<$A, $B>, ~ltk)]-> [!LTK_PSK(<$A, $B>, ~ltk)]

/* Assume binding between identities and their credentials */
restriction uniqLTKs:
    "All id k1 k2 #i #j. (UniqLTK(id, k1)@i & UniqLTK(id, k2)@j) ==> k1 = k2"

/* Reveal LTK for all methods */
rule revealLTK_SIG:
    [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT:
    [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_PSK:
    [!LTK_PSK(<$A, $B>, ~ltk)] --[LTKRev(<$A, $B>)]-> [Out(~ltk)]

/* Reveal session key for all methods.
 * Explicit authentication possible for:
 * sk = <gxy> for PSK and SIG_SIG methods
 * sk = <gxy, grx> for SIG_STAT method
 * sk = <gxy> for STAT_SIG method           -- GIY not known to R for msg2
 * sk = <gxy, grx> for STAT_STAT method     -- GIY not known to R for msg2
 * Implicit authentication *possible* for:
 * sk = <gxy> for PSK and SIG_SIG methods
 * sk = <gxy, grx> for SIG_STAT method
 * sk = <gxy, giy> for STAT_SIG method
 * sk = <gxy, grx, giy> for STAT_STAT method
 */
ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR, 
<!
	ifdef(<!m4CI!>,
		<! 
			ifdef(<!m4CR!>,
				<! rule revealSessionKeyPSK:
    				[CommitI(tid, u, v, sk, ~C_I, ~C_R)] --[SKRev(sk)]-> [Out(sk)]
    			!>,
    			<! rule revealSessionKeyPSK:
    				[CommitI(tid, u, v, sk, ~C_I)] --[SKRev(sk)]-> [Out(sk)]
    			!>
    		)
    	!>,
    	<! 
    		ifdef(<!m4CR!>,
				<! rule revealSessionKeyPSK:
    					[CommitI(tid, u, v, sk, ~C_R)] --[SKRev(sk)]-> [Out(sk)]
    			!>,
    			<! rule revealSessionKeyPSK:
    					[CommitI(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
    			!>
    		)
    	!>
    )
!>, 
<!
	ifdef(<!m4CI!>,
		<!
			ifdef(<!m4CR!>,
				<!
					rule revealSessionKeyI:
    					[CommitI(tid, u, v, sk, ~C_I, ~C_R)] --[SKRev(sk)]-> [Out(sk)]
					rule revealSessionKeyR:
    					[CommitR(tid, u, v, sk, ~C_I, ~C_R)] --[SKRev(sk)]-> [Out(sk)]
				!>,
				<!
					rule revealSessionKeyI:
    					[CommitI(tid, u, v, sk, ~C_I)] --[SKRev(sk)]-> [Out(sk)]
					rule revealSessionKeyR:
    					[CommitR(tid, u, v, sk, ~C_I)] --[SKRev(sk)]-> [Out(sk)]	
				!>
			)
		!>,
		<!
			ifdef(<!m4CR!>,
				<!
					rule revealSessionKeyI:
    					[CommitI(tid, u, v, sk, ~C_R)] --[SKRev(sk)]-> [Out(sk)]
					rule revealSessionKeyR:
    					[CommitR(tid, u, v, sk, ~C_R)] --[SKRev(sk)]-> [Out(sk)]
				!>,
				<!
					rule revealSessionKeyI:
    					[CommitI(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
					rule revealSessionKeyR:
    					[CommitR(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]	
				!>
			)
		!>
	)

!>
)


/*
 * Invariants - Helper lemmas
 */

/*
 * Sanity - Correct exectution trace exists
 *
 * NOTE: this allows u = v. Is that what we want?
 */
lemma sanityExecutableToTheEnd:
    ifdef(<!m4CI!>,
    	<! 
    		ifdef(<!m4CR!>,
				<!
				    exists-trace
				    "(Ex tidI tidR u v m1 m2 m3 ci cr sk sk2 #i #j #k #l.
				       I1(tidI, u, v, m1)@i
				     & R2(tidR, v, m1, m2)@j & #i < #j
				     & I3(tidI, u, v, m1, m2, m3)@k &  #j < #k
				     & CommitI(tidI, u, v, sk, ci, cr)@k
				     & ExpCommitI(tidI, u, v, sk2, ci, cr)@k
				     & R4(tidR, u, v, m1, m2, m3)@l &  #k < #l
				     & CommitR(tidR, u, v, sk, ci, cr)@l
				     & ExpCommitR(tidR, u, v, sk2, ci, cr)@l
				     )
				    "
				!>,
				<!
					exists-trace
				    "(Ex tidI tidR u v m1 m2 m3 ci sk sk2 #i #j #k #l.
				       I1(tidI, u, v, m1)@i
				     & R2(tidR, v, m1, m2)@j & #i < #j
				     & I3(tidI, u, v, m1, m2, m3)@k &  #j < #k
				     & CommitI(tidI, u, v, sk, ci)@k
				     & ExpCommitI(tidI, u, v, sk2, ci)@k
				     & R4(tidR, u, v, m1, m2, m3)@l &  #k < #l
				     & CommitR(tidR, u, v, sk, ci)@l
				     & ExpCommitR(tidR, u, v, sk2, ci)@l
				     )
				    "
				!>
			)
		!>,
		<!
			ifdef(<!m4CR!>,
				<!
					exists-trace
				    "(Ex tidI tidR u v m1 m2 m3 cr sk sk2 #i #j #k #l.
				       I1(tidI, u, v, m1)@i
				     & R2(tidR, v, m1, m2)@j & #i < #j
				     & I3(tidI, u, v, m1, m2, m3)@k &  #j < #k
				     & CommitI(tidI, u, v, sk, cr)@k
				     & ExpCommitI(tidI, u, v, sk2, cr)@k
				     & R4(tidR, u, v, m1, m2, m3)@l &  #k < #l
				     & CommitR(tidR, u, v, sk, cr)@l
				     & ExpCommitR(tidR, u, v, sk2, cr)@l
				     )
				    "
				!>,
				<!
					exists-trace
				    "(Ex tidI tidR u v m1 m2 m3 sk sk2 #i #j #k #l.
				       I1(tidI, u, v, m1)@i
				     & R2(tidR, v, m1, m2)@j & #i < #j
				     & I3(tidI, u, v, m1, m2, m3)@k &  #j < #k
				     & CommitI(tidI, u, v, sk)@k
				     & ExpCommitI(tidI, u, v, sk2)@k
				     & R4(tidR, u, v, m1, m2, m3)@l &  #k < #l
				     & CommitR(tidR, u, v, sk)@l
				     & ExpCommitR(tidR, u, v, sk2)@l
				     )
				    "
				!>
			)
		!>
	)


/* Note that this only shows agreement on a reduced session key from R to I
 * since Responder does not know GIY when sending message 2, i.e., when Initiator
 * uses STAT method for authentication towards Responder.
 * This is for the session key we can explicitly show agreement for.
 * Also: Initiator gets no guarantee that R knows u (that should in fact
 * not be possible due to identity protection).
 */
lemma authInjAgreeGuaranteeForI:
	ifdef(<!m4CI!>,
		<!  
			ifdef(<!m4CR!>,
				<!	all-traces
				    "All tidI u v expSk ci cr #i.
				         ExpCommitI(tidI, u, v, expSk, ci, cr)@i ==>
				         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk, ci, cr)@j & #j < #i)
				           & not( Ex tidI2 u2 v2 ci2 cr2 #i2. ExpCommitI(tidI2, u2, v2, expSk, ci2, cr2)@i2
				                & not(#i = #i2)
				                )
				           )
				!>,
				<!	all-traces
				    "All tidI u v expSk ci #i.
				         ExpCommitI(tidI, u, v, expSk, ci)@i ==>
				         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk, ci)@j & #j < #i)
				           & not( Ex tidI2 u2 v2 ci2 #i2. ExpCommitI(tidI2, u2, v2, expSk, ci2)@i2
				                & not(#i = #i2)
				                )
				           )
				!>
			)
		!>,
		<!	
			ifdef(<!m4CR!>,
				<!	all-traces
				    "All tidI u v expSk cr #i.
				         ExpCommitI(tidI, u, v, expSk, cr)@i ==>
				         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk, cr)@j & #j < #i)
				           & not( Ex tidI2 u2 v2 cr2 #i2. ExpCommitI(tidI2, u2, v2, expSk, cr2)@i2
				                & not(#i = #i2)
				                )
				           )
				!>,
				<!
					all-traces
				    "All tidI u v expSk #i.
				         ExpCommitI(tidI, u, v, expSk)@i ==>
				         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
				           & not( Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2
				                & not(#i = #i2)
				                )
				           )
				!>
			)
		!>
	)
    ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
    <!
             | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
    !>,
    <!
             | (Ex #j. LTKRev(u)@j & #j < #i)
             | (Ex #j. LTKRev(v)@j & #j < #i)
    !>
    )
         )
    "

/* This shows agreement on the full session key and both u and v */
/*lemma authInjAgreeGuaranteeForR:
    ifdef(<!m4CI!>,
		<!  
			ifdef(<!m4CR!>,
				<!	all-traces
				    "All tidR u v sk ci cr #i.
				         CommitR(tidR, u, v, sk, ci, cr)@i ==>
				         ( ( (Ex tidI #j. CommitI(tidI, u, v, sk, ci, cr)@j & #j < #i)
				           & not( Ex tidR2 u2 v2 ci2 cr2 #i2. CommitR(tidR2, u2, v2, sk, ci2, cr2)@i2
				                & not(#i = #i2)
				                )
				           )
				!>,
				<!	all-traces
				    "All tidR u v sk ci #i.
				         CommitR(tidR, u, v, sk, ci)@i ==>
				         ( ( (Ex tidI #j. CommitI(tidI, u, v, sk, ci)@j & #j < #i)
				           & not( Ex tidR2 u2 v2 ci2 #i2. CommitR(tidR2, u2, v2, sk, ci2)@i2
				                & not(#i = #i2)
				                )
				           )
				!>
			)
		!>,
		<!  
			ifdef(<!m4CR!>,
				<!	all-traces
				    "All tidR u v sk cr #i.
				         CommitR(tidR, u, v, sk, cr)@i ==>
				         ( ( (Ex tidI #j. CommitI(tidI, u, v, sk, cr)@j & #j < #i)
				           & not( Ex tidR2 u2 v2 cr2 #i2. CommitR(tidR2, u2, v2, sk, cr2)@i2
				                & not(#i = #i2)
				                )
				           )
				!>,
				<!	all-traces
				    "All tidR u v sk #i.
				         CommitR(tidR, u, v, sk)@i ==>
				         ( ( (Ex tidI #j. CommitI(tidI, u, v, sk)@j & #j < #i)
				           & not( Ex tidR2 u2 v2 #i2. CommitR(tidR2, u2, v2, sk)@i2
				                & not(#i = #i2)
				                )
				           )
				!>
			)
		!>
	)

    ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
        <!
            | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
        !>,
        <!
            | (Ex #j. LTKRev(u)@j & #j < #i)
            | (Ex #j. LTKRev(v)@j & #j < #i)
        !>
    )
    )
    "*/

/* If we include G_IY in the session key material, we will not get (injective)
 * agreement on the session key material from the responder to the initator.
 * We instead show implicit authentication of the key material.
 * This is a weaker guarantee than injective agreement that essentially
 * guarantees to a party U that has completed its protocol run and believes
 * the protocol is run with party V, that *if* there is anybody out there who
 * has computed this session key (at some point), then that party is V and
 * V believes it ran the protocol with U.
 *
 * Note that we already proved injective agreement guarantee on the full
 * session key material (including G_IY) from Initiator to Responder above, so
 * we only have to fall back to implicit authentication "from" Responder to
 * Initiator.
 *
 * Second note: This is only interesting when the Initiator is using STAT
 * method.  In all other cases we have no G_IY and hence have injective
 * agreement on the entire key material becasue expSK is equal to impSK.
 *
 * KARL: Intuitively inj-agree should imply this one. Should we prove that?
 *       Then we can say all methods fulfill the implicit auth at least and
 *       some of them fulfill the stronger inj-agree.
 */
 
/*lemma authGIYImplicitAuthGuaranteeForI:
	ifdef(<!m4CI!>,
	<!  
		ifdef(<!m4CR!>,
			<!	all-traces
			    "All tidI u v impSk ci cr #i.
			         CommitI(tidI, u, v, impSk, ci, cr)@i ==>
			         ( 
                        ( 
                            (
                                All tidR u2 v2 ci2 cr2 #j. CommitR(tidR, u2, v2, impSk, ci2, cr2)@j ==>
			                     (u = u2  &  v = v2 & ci = ci2 & cr = cr2)
			                )
    			            &
    			            (not Ex #k. K(impSk)@k)
                            &
                            (
                                not( Ex tidR u v ci1 cr1 #j tidR2 u2 v2 ci2 cr2 #j2.
                                     ( 
                                        CommitR(tidR, u, v, impSk, ci1, cr1)@j
                                        & CommitR(tidR2, u2, v2, impSk, ci2, cr2)@j2
                                        & not(#j = #j2)
                                     )
                                    )
                            )
			           )
			         | (Ex #k. LTKRev(u)@k)
			         | (Ex #k. LTKRev(v)@k)
                     | (Ex #k. LTKRev(<u, v>)@k)
			         )
			    "
			!>,
			<!	all-traces
			    "All tidI u v impSk ci #i.
			         CommitI(tidI, u, v, impSk, ci)@i ==>
			         ( ( (All tidR u2 v2 ci2 #j. CommitR(tidR, u2, v2, impSk, ci2)@j ==>
			                (u = u2  &  v = v2 & ci = ci2)
			             )
			           &
			             (not Ex #k. K(impSk)@k)
                         &
                            (
                                not( Ex tidR u v ci1 #j tidR2 u2 v2 ci2 #j2.
                                     ( 
                                        CommitR(tidR, u, v, impSk, ci1)@j
                                        & CommitR(tidR2, u2, v2, impSk, ci2)@j2
                                        & not(#j = #j2)
                                     )
                                    )
                            )
			           )
			         | (Ex #k. LTKRev(u)@k)
			         | (Ex #k. LTKRev(v)@k)
                     | (Ex #k. LTKRev(<u, v>)@k)
			         )
			    "
			!>
		)
	!>,
	<!  
		ifdef(<!m4CR!>,
			<!	all-traces
			    "All tidI u v impSk cr #i.
			         CommitI(tidI, u, v, impSk, cr)@i ==>
			         ( ( (All tidR u2 v2 cr2 #j. CommitR(tidR, u2, v2, impSk, cr2)@j ==>
			                (u = u2  &  v = v2 & cr = cr2)
			             )
			           &
			             (not Ex #k. K(impSk)@k)
                        &
                            (
                                not( Ex tidR u v cr1 #j tidR2 u2 v2 cr2 #j2.
                                     ( 
                                        CommitR(tidR, u, v, impSk, cr1)@j
                                        & CommitR(tidR2, u2, v2, impSk, cr2)@j2
                                        & not(#j = #j2)
                                     )
                                    )
                            )
			           )
			         | (Ex #k. LTKRev(u)@k)
			         | (Ex #k. LTKRev(v)@k)
                     | (Ex #k. LTKRev(<u, v>)@k)
			         )
			    "
			!>,
			<!	all-traces
			    "All tidI u v impSk #i.
			         CommitI(tidI, u, v, impSk)@i ==>
			         ( ( (All tidR u2 v2 #j. CommitR(tidR, u2, v2, impSk)@j ==>
			                (u = u2  &  v = v2)
			             )
			           &
			             (not Ex #k. K(impSk)@k)
                        &
                            (
                                not( Ex tidR u v #j tidR2 u2 v2 #j2.
                                     ( 
                                        CommitR(tidR, u, v, impSk)@j
                                        & CommitR(tidR2, u2, v2, impSk)@j2
                                        & not(#j = #j2)
                                     )
                                    )
                            )
			           )
			         | (Ex #k. LTKRev(u)@k)
			         | (Ex #k. LTKRev(v)@k)
                     | (Ex #k. LTKRev(<u, v>)@k)
			         )
			    "
			!>
		)
	!>
	)*/


/* PFS (implying regular secrecy) of session key (**including G_IY**).
 */
/*ifelse(<!PSK_PSK!>, m4METHODI<!_!>m4METHODR,
    <!lemma secrecyPFSGIYSessionKey:
        ifdef(<!m4CI!>,
		    <!
		    	ifdef(<!m4CR!>,
				    <!    
				    	all-traces
				        "(All tid u v sk ci cr #i #j. (K(sk)@i & CommitI(tid, u, v, sk, ci, cr)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk ci cr #i #j. (K(sk)@i & CommitR(tid, u, v, sk, ci, cr)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>,
				    <!    
				    	all-traces
				        "(All tid u v sk ci #i #j. (K(sk)@i & CommitI(tid, u, v, sk, ci)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk ci #i #j. (K(sk)@i & CommitR(tid, u, v, sk, ci)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>
				)
		    !>,
		    <! 
		    	ifdef(<!m4CR!>,
				    <!    
				    	all-traces
				        "(All tid u v sk cr #i #j. (K(sk)@i & CommitI(tid, u, v, sk, cr)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk cr #i #j. (K(sk)@i & CommitR(tid, u, v, sk, cr)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>,
				    <!    
				    	all-traces
				        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
				            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>
				)
		    !>
		)
    !>,*/
    
/*<!ifelse(<!STAT!>, m4METHODR,  // STAT_STAT or SIG_STAT -- THIS SHOULD FAIL!
    <!lemma secrecyPFSGIYSessionKey:
    	ifdef(<!m4CI!>,
		    <!
		    	ifdef(<!m4CR!>,
				    <!
				        all-traces
				        "(All tid u v sk ci cr #i #j. (K(sk)@i & CommitI(tid, u, v, sk, ci, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk ci cr #i #j. (K(sk)@i & CommitR(tid, u, v, sk, ci, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>,
				    <!
				        all-traces
				        "(All tid u v sk ci #i #j. (K(sk)@i & CommitI(tid, u, v, sk, ci)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk ci #i #j. (K(sk)@i & CommitR(tid, u, v, sk, ci)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>
				)
		    !>,
		    <!
		        ifdef(<!m4CR!>,
				    <!
				        all-traces
				        "(All tid u v sk cr #i #j. (K(sk)@i & CommitI(tid, u, v, sk, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk cr #i #j. (K(sk)@i & CommitR(tid, u, v, sk, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>,
				    <!
				        all-traces
				        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>
				)
		    !>
		)
    !>,*/
/*<!ifelse(<!STAT!>, m4METHODI,  // STAT_SIG
    <!
    	ifdef(<!m4CI!>,
    		<!
    			ifdef(<!m4CR!>,
				    <!
				    	lemma secrecyPFSGIYSessionKey:
				        all-traces
				        "(All tid u v sk ci cr #i #j. (K(sk)@i & CommitI(tid, u, v, sk, ci, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk ci cr #i #j. (K(sk)@i & CommitR(tid, u, v, sk, ci, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>,
				    <!
				    	lemma secrecyPFSGIYSessionKey:
				        all-traces
				        "(All tid u v sk ci #i #j. (K(sk)@i & CommitI(tid, u, v, sk, ci)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk ci #i #j. (K(sk)@i & CommitR(tid, u, v, sk, ci)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>
				)
		    !>,
		    <!
		    	ifdef(<!m4CR!>,
				    <!
				    	lemma secrecyPFSGIYSessionKey:
				        all-traces
				        "(All tid u v sk cr #i #j. (K(sk)@i & CommitI(tid, u, v, sk, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk cr #i #j. (K(sk)@i & CommitR(tid, u, v, sk, cr)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>,
				    <!
				    	lemma secrecyPFSGIYSessionKey:
				        all-traces
				        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )
				         &
				         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
				            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
				         )"
				    !>
				)
		    !>
		)

    !>,
    // else: SIG_SIG
    //////////////// HERE ////////////////
    <!
    	lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
         )
         &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l))
         )"
    !>
)!>
)!>
)
*/
end


