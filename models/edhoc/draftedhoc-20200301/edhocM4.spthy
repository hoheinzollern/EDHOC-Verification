changequote(`«', `»')
ifelse(m4ATTACKER, PASSIVE, «define(Out, Msg($1)) define(In, Msg($1))», )
theory «edhoc_»m4METHODI«_»m4METHODR«_»m4ATTACKER
begin
builtins: diffie-hellman, xor, signing, hashing

/* WoW: Naming conventions:
 *  - camelCase for functions and properties
 *  - constants (0-arity functions) begin with "c"
 *  - do not use variable/constant names: x, y, vk (used by Tamarin internally,
 *                                                  and show up in the trace)
 *  - m4 macros are prefixed with m4 and the rest is all caps
 *  - begin sanity properties with "santity"    -- helps oracle
 *  - begin secrecy properties with "secrecy"   -- helps oracle
 *  - begin agreement properties with "agree"   -- helps oracle
 *
 */
functions:
    aeadEncrypt/4,  // Input: Key, plain-text, aad, cAEADx (AEAD algo ID)
    aeadDecrypt/4,  // Input: Key, cipher-text, aad, cAEADx (AEAD algo ID)
    decrypt/3,      // Input: Key, cipher-text, cAEADx (AEAD algo ID);
    xorEncrypt/2,   // Input: Key, plain-text
    xorDecrypt/2,   // Input: Key, cipher-text
    hkdfExtract/2,  // Input: Salt, random source
    hkdfExpand/2,   // Input: Salt, uniform random source
    cEmptyStr/0,
    cSUITE0/0,
        cAEAD0/0,   // cAEAD0 is part of cSUITE0 is the idea
        cHash0/0,   // cHash0 is part of cSUITE0 is the idea
    cSUITE1/0,
        cAEAD1/0,
        cHash1/0

equations:
    aeadDecrypt(key, aeadEncrypt(key, pt, aad, algoId), aad, algoId) = pt,
    decrypt(key, aeadEncrypt(key, pt, aad, algoID), algoId) = pt,
    xorDecrypt(k, xorEncrypt(k, pt)) = pt   // Too strong


ifelse(«SIG», m4METHODI,
    «restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"»,
    «ifelse(«SIG», m4METHODR,
        «restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"»,
        «» /* NOTHING */
    )»
)


restriction Neq:
    "All x y #i. Neq(x, y)@i ==> not(x = y)"

rule «I1_»m4METHODI«_»m4METHODR:
    let gx = 'g'^~xx
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «ID_PSK = <$U, $V>
         m1 = <$«»m4METHODI«», $«»m4METHODR«», $cSUITE0, gx, ~C_I, ID_PSK, ~AD_1>»,
        «m1 = <$«»m4METHODI«», $«»m4METHODR«», $cSUITE0, gx, ~C_I,         ~AD_1>»
)
    in
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        [ !«LTK_»m4METHODI«»(<$U, $V, $idPSK>, ~ltk),
        [ !«LTK_»m4METHODI«»($U, ~ltk)
)
        , Fr(~xx)
        , Fr(~C_I)
        , Fr(~AD_1)
        , Fr(~tid)  /* Thread ID */
        ]
        --[
            I1(~tid, ~AD_1, ~C_I, 'g'^~xx)
        ]->
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        [ «StI1_»m4METHODI«_»m4METHODR«»($U, ~ltk, $V, ~xx, ~C_I, m1, ~AD_1, $idPSK, ~tid),
        [ «StI1_»m4METHODI«_»m4METHODR«»($U, ~ltk, $V, ~xx, ~C_I, m1, ~AD_1,         ~tid)
)
        , Out(m1)
        ]

rule «R2_»m4METHODI«_»m4METHODR:
    let
         data_2 = <~C_I, 'g'^~yy, ~C_R>
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «ID_PSK = <$U, $V>
         m1 = <$«»m4METHODI«», $«»m4METHODR«», $cSUITE0, gx, ~C_I, ID_PSK, ~AD_1>
         TH_2 = h(<$cHash0, m1, data_2>)
         prk_2e = hkdfExtract(~ltk, gx^~yy)
         prk_3e2m = prk_2e
         extAad2 = TH_2
         plainText2 = ~AD_2
         K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
         CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)»,
        «m1 = <$«»m4METHODI«», $«»m4METHODR«», $cSUITE0, gx, ~C_I,         ~AD_1>
         TH_2 = h(<$cHash0, m1, data_2>)
         prk_2e = hkdfExtract($cEmptyStr, gx^~yy)
         ifelse(«STAT», m4METHODR,
                 «grx = gx^~ltk
                  prk_3e2m = hkdfExtract(prk_2e, grx)»,
                 «prk_3e2m = prk_2e»
         )
         K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
         protected2 = $V // ID_CRED_V
         CRED_V = pkV
         extAad2 = <TH_2, CRED_V, ~AD_2>
         assocData2 = <protected2, extAad2>
         /* We don't use proper XOR to beging with
         K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
         K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
         K_2e_3 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '3'>, prk_2e)
         CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2, ~AD_2 XOR K_2e_3>
         */
         MAC_2 = aeadEncrypt($cEmptyStr, K_2m, assocData2, $cAEAD0)
         ifelse(«SIG», m4METHODR,
            «authV = sign(<assocData2, MAC_2>, ~ltk)»,
            «authV = MAC_2»
         )
         plainText2 = <$V, authV, ~AD_2>
         K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
         CIPHERTEXT_2 = xorEncrypt(K_2e, plainText2)»
)
         m2 = <data_2, CIPHERTEXT_2>


/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(«STAT_SIG», m4METHODI«_»m4METHODR,
    «exp_sk = <gx^~yy>»,  // Responder does not know G_IY when sending m2
    «ifelse(«SIG_STAT», m4METHODI«_»m4METHODR,
        «exp_sk = <gx^~yy, grx>»,
        «ifelse(«STAT_STAT», m4METHODI«_»m4METHODR,
            «exp_sk = <gx^~yy, grx>», // Responder does not know G_IY when sending m2
            «exp_sk = <gx^~yy>» // SIG_SIG or PSK_PSK
        )»
    )»
)

    in
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        [ «!LTK_»m4METHODR«(<$U, $V, $idPSK>, ~ltk)»,
        [ «!LTK_»m4METHODR«($V, ~ltk)
        ,  !PK_»m4METHODR«($V, pkV)»
)
        , In(m1)
        , Fr(~yy)
        , Fr(~C_R)
        , Fr(~AD_2)
        , Fr(~tid)
        ]
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «--[ RunningR(~tid, $U, $V, exp_sk)
          , InvKDFR2(~tid, ~ltk, ~yy, K_2ae, 'DUMMYKEY')»,
        «--[ RunningR(~tid, $V, exp_sk)
          , InvKDFR2(~tid, ~ltk, ~yy, K_2e, K_2m)»
)
          , Neq(gx, 'g')
          , R2(~tid, ~AD_2, ~C_R, gx, 'g'^~yy, exp_sk)
          ]->
ifelse(«STAT», m4METHODR,
        [ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltk, ~C_R, ~C_I, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~AD_2, ~tid)
        ,
        «ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
            [ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltk, ~C_R, ~C_I,      ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, $idPSK, ~AD_2, ~tid),
            [ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltk, ~C_R, ~C_I,      ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy,         ~AD_2, ~tid)
        )»
)
        , Out(m2)
        ]


rule «I3_»m4METHODI«_»m4METHODR«»:
    let
         data_2 = <~C_I, gy, ~C_R>
    /* Message 2 handling */
         TH_2 = h(<$cHash0, m1, data_2>)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «prk_2e = hkdfExtract(~ltk, gy^~xx)
         prk_3e2m = prk_2e
         plainText2 = ~AD_2
         extAad2 = TH_2     // KARL: Why is not AD_2 covered in PSK case? Not necesssary, but it is included for the ASYM cases
         K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
         CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0) // MAC check by pattern matching
         m2 = <data_2, CIPHERTEXT_2>
        »,
         /* STAT and SIG methods */
        «prk_2e = hkdfExtract($cEmptyStr, gy^~xx)
         plainText2 = <$V, authR, ~AD_2>
         CRED_V = pkV
         ifelse(«STAT», m4METHODR,
            «grx = CRED_V^~xx
             prk_3e2m = hkdfExtract(prk_2e, grx)»
             ,
            «prk_3e2m = prk_2e»
         )
         /* We don't use proper XOR to beging with
         K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
         K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
         K_2e_3 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '3'>, prk_2e)
         CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2, ~AD_2 XOR K_2e_3> */
         K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
         CIPHERTEXT_2 = xorEncrypt(K_2e, plainText2) // Decryption by pattern matching
         m2 = <data_2, CIPHERTEXT_2>

         K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
         protected2 = $V // ID_CRED_V
         extAad2 = <TH_2, CRED_V, ~AD_2>
         assocData2 = <protected2, extAad2>
         MAC_2 = aeadEncrypt($cEmptyStr, K_2m, assocData2, $cAEAD0) // MAC check by pattern matching
        »
)

    /* Message 3 handling */
         data_3 = ~C_R
         TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
         K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «extAad3 = TH_3
         plainText3 = ~AD_3
         CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)»,
         /* STAT and SIG methods */
        «ifelse(«STAT», m4METHODI,
            «giy = gy^~ltk
             prk_4x3m = hkdfExtract(prk_3e2m, giy)»,
            «prk_4x3m = prk_3e2m»
         )
         K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
         protected3 = $U // ID_CRED_U
         CRED_U = pkU
         extAad3 = <TH_3, CRED_U, ~AD_3>
         assocData3 = <protected3, extAad3>
         MAC_3 = aeadEncrypt($cEmptyStr, K_3m, assocData3, $cAEAD0)
         ifelse(«SIG», m4METHODI,
            «authU = sign(<assocData3, MAC_3>, ~ltk)»,
            «authU = MAC_3»
         )
         plainText3 = <$U, authU, ~AD_3>
         extAad3Outer = TH_3
         CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
         »
)
         m3 = <data_3, CIPHERTEXT_3>

/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(«STAT_SIG», m4METHODI«_»m4METHODR,
    «exp_sk = <gy^~xx>»,  // Responder does not know G_IY when sending m2
    «ifelse(«SIG_STAT», m4METHODI«_»m4METHODR,
        «exp_sk = <gy^~xx, grx>»,
        «ifelse(«STAT_STAT», m4METHODI«_»m4METHODR,
            «exp_sk = <gy^~xx, grx>», // Responder does not know G_IY when sending m2
            «exp_sk = <gy^~xx>» // SIG_SIG or PSK_PSK
        )»
    )»
)

/* Def of session key imp_sk we can get explicit auth (agreement) on I->R, but only
 * implicitly on R->I because R does not know G_IY when sending message 2,
 * so I cannot deduce that R is using the same value of GIY when I completes.
 */
ifelse(«STAT_SIG», m4METHODI«_»m4METHODR,
    «imp_sk = <gy^~xx, giy>»,
    «ifelse(«SIG_STAT», m4METHODI«_»m4METHODR,
        «imp_sk = <gy^~xx, grx>»,
        «ifelse(«STAT_STAT», m4METHODI«_»m4METHODR,
            «imp_sk = <gy^~xx, giy, grx>»,
            «imp_sk = <gy^~xx>» // SIG_SIG or PSK_PSK
        )»
    )»
)

    in
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        [ «StI1_»m4METHODI«_»m4METHODR«»($U, ~ltk, $V, ~xx, ~C_I, m1, ~AD_1, $idPSK, ~tid)
        ,
        [ «StI1_»m4METHODI«_»m4METHODR«»($U, ~ltk, $V, ~xx, ~C_I, m1, ~AD_1,         ~tid)
        «, !PK_»m4METHODR«»($V, pkV)
        «, !PK_»m4METHODI«»($U, pkU)
)
        , Fr(~AD_3)
        , In(m2)
        ]
        --[ RunningI(~tid, $U, $V, imp_sk)        // For agreement of all params
          , I3(~tid, ~AD_1, ~C_I, 'g'^~xx, gy, imp_sk)
ifelse(«SIG», m4METHODR,
         «, Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)»,
         «»  /* nothing */
)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
         «, CommitI(~tid, $U, $V, imp_sk, $idPSK)  // For agreement of all params
          , InvKDFI3(~ltk, ~xx, K_2ae, 'DUMMYKEY')»,
         «, CommitI(~tid, $U, $V, imp_sk)   // For agreement of all params
          , InvKDFI3(~ltk, ~xx, K_2e, K_2m)»
)
          ]->
        [ Out(m3) ]

rule «R4_»m4METHODI«_»m4METHODR«»:
    let
        data_3 = ~C_R
        TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
        K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
       «extAad3 = TH_3
        plainText3 = ~AD_3
        CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0) // MAC check by pattern matching
       »,
        /* STAT and SIG methods */
       «CRED_U = pkU
        extAad3 = TH_3
        plainText3 = <$U, authI, ~AD_3>
        CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0) // MAC check by pattern matching
        ifelse(«STAT», m4METHODI,
           «giy = CRED_U^~yy
            prk_4x3m = hkdfExtract(prk_3e2m, giy)»,
           «prk_4x3m = prk_3e2m»
        )
        K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
        protected3 = $U // ID_CRED_U
        extAad3 = <TH_3, CRED_U, ~AD_3>
        assocData3 = <protected3, extAad3>
        MAC_3 = aeadEncrypt($cEmptyStr, K_3m, assocData3, $cAEAD0)
       »
)
        m3 = <data_3, CIPHERTEXT_3>

/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(«STAT_SIG», m4METHODI«_»m4METHODR,
    «exp_sk = <gxy>»,  // Responder does not know G_IY when sending m2
    «ifelse(«SIG_STAT», m4METHODI«_»m4METHODR,
        «exp_sk = <gxy, grx>»,
        «ifelse(«STAT_STAT», m4METHODI«_»m4METHODR,
            «exp_sk = <gxy, grx>», // Responder does not know G_IY when sending m2
            «exp_sk = <gxy>» // SIG_SIG or PSK_PSK
        )»
    )»
)

/* Def of session key imp_sk we can get explicit auth (agreement) on I->R, but only
 * implicitly on R->I because R does not know G_IY when sending message 2,
 * so I cannot deduce that R is using the same value of GIY when I completes.
 */
ifelse(«STAT_SIG», m4METHODI«_»m4METHODR,
    «imp_sk = <gxy, giy>»,
    «ifelse(«SIG_STAT», m4METHODI«_»m4METHODR,
        «imp_sk = <gxy, grx>»,
        «ifelse(«STAT_STAT», m4METHODI«_»m4METHODR,
            «imp_sk = <gxy, giy, grx>»,
            «imp_sk = <gxy>» // SIG_SIG or PSK_PSK
        )»
    )»
)

    in
ifelse(«STAT», m4METHODR,
        «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltk, ~C_R, ~C_I, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~AD_2, ~tid)»,
        «ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
            «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltk, ~C_R, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, $idPSK, ~AD_2, ~tid)»,
            «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltk, ~C_R, ~C_I, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy,         ~AD_2, ~tid)»
        )»
)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «» /* NOTHING */
        , /* All other methods */
        «, !PK_»m4METHODI«»($U, pkU)
        «, !PK_»m4METHODR«»($V, pkV)
)
        , In(m3)
        ]
        --[ R4(~tid, ~AD_2, ~C_R, prk_3e2m)
ifelse(«SIG», m4METHODI,
         «, Eq(verify(authI, <assocData3, MAC_3>, CRED_U), true)»,
         «»  /* nothing */
)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
         «, CommitR(~tid, $U, $V, imp_sk, $idPSK)
          , InvKDFR4(~tid, ~ltk, ~yy, K_3ae, 'DUMMYKEY')»,
         «, CommitR(~tid, $U, $V, imp_sk)»        // For agreement of all params
          , InvKDFR4(~tid, ~ltk, ~yy, K_3ae, K_3m)
            
)
          ]->
        []

/*
 * Environment and adversary model additions to standard Dolev-Yao
 */
/* Register LTK for SIG key based authentication */
rule registerLTK_SIG:
    [Fr(~ltk)] --[]-> [!LTK_SIG($A, ~ltk),
                       !PK_SIG($A, pk(~ltk)),
                       Out(«<$A, pk(~ltk)>»)]

/* Register LTK for STAT key based authentication */
rule registerLTK_STAT:
    [Fr(~ltk)]
    --[]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(«<$A, 'g'^~ltk>»)]

/* Register LTK for PSK key based authentication */
rule registerLTK_PSK:
    [Fr(~ltk)] --[]-> [!LTK_PSK(<$A, $B, $idPSK>, ~ltk)]

/* Reveal LTK for all methods.
 * NOTE: leaks before run complete. More is needed for PFS.
 */
rule revealLTK_SIG:
    [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT:
    [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_PSK:
    [!LTK_PSK(<$A, $B, $idPSK>, ~ltk)] --[LTKRev($idPSK)]-> [Out(~ltk)]

/* Reveal session key for all methods.
 * sk = <gxy> for PSK and SIG_SIG methods
 * sk = <gxy, grx> for SIG_STAT method
 * sk = <gxy, giy> for STAT_SIG method
 * sk = <gxy, grx, giy> for STAT_STAT method
 */
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR, «
rule revealSessionKeyPSK:
    [CommitI(tid, u, v, sk, $idPSK)] --[SKRev(sk)]-> [Out(sk)]
», «
rule revealSessionKeyI:
    [CommitI(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
rule revealSessionKeyR:
    [CommitR(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
»)


/*
 * Invariants - Helper lemmas
 */
/*
 KARL: Why does this not reduce the number of invariants to check?
lemma helpInvReduceInvs [reuse]:
    all-traces
    "All tidI tidR ad1 ad2 ad1p ci cr cip gx gy gxp gxb sk #i #j #k.
         ( I1(tidI, ad1p, cip, gxp)@i
         & R2(tidR, ad2, cr, gxb, gy, sk)@j
         & I3(tidI, ad1, ci, gx, gy, sk)@k
         )
         ==>
         (ad1 = ad1p & ci = cip & gx = gxp & gx = gxb & #i < #j & #j < #k)
    "
*/

/*
 * helpInvLtkKDF
 *   Is only true for when methods with no STAT-peer
 *   PSKPSK: verifies in 36 seconds
 *   SIGSIG: verifies in 31 seconds
 */
ifelse(m4METHODI, m4METHODR,
    «lemma helpInvLtkKDF [reuse]:
        all-traces
        "All s1 s2 k #i. !KU(hkdfExpand(s1, hkdfExtract(s2, k)))@i
                             ==> Ex #j. !KU(k)@j & (#j < #i)"
    »
    ,
    «» /* NOTHING */
)


/*
 * Sanity - Correct exectution trace exists
 * Verifies for all methods in 7 minutes (ACTIVE) and 33 secs (PASSIVE)
 *
 * NOTE: this allows u = v. Is that what we want?
 */
/*
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
«
lemma sanityExecutableToTheEnd:
    exists-trace
    "Ex tidI tidR  u v gxy #i #j. CommitI(tidI, u, v, gxy, idPSK)@i &
                                  CommitR(tidR, u, v, gxy, idPSK)@j &
                                  #i < #j"
»,
«
lemma sanityExecutableToTheEnd:
    exists-trace
    "Ex tidI tidR  u v gxy #i #j. CommitI(tidI, u, v, gxy)@i &
                                  CommitR(tidR, u, v, gxy)@j &
                                  #i < #j"
»)
*/

/*
 * Old explicit-session key secrecy and session key independence
 * Verifies for all methods in ? minutes (ACTIVE) and 40 secs (PASSIVE)
 * PSKPSK: verifies in 11 minutes (ACTIVE)
 * SIGSTAT: verifies in 5 minutes (ACTIVE)
 * SIGSIG: verifies in 9 minutes 46 seconds (ACTIVE)
 * STATSTAT: falsifies in 14 minutes (ACTIVE)   -- Peculiar! modeling error?
 */
/*
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
«
lemma secrecyExpAuthSessionKey:
    all-traces
    "(All tid u v idPSK sk #i #j #k.
         K(sk)@i & CommitI(tid, u, v, sk, idPSK)@j ==>
            ((Ex #l. LTKRev(idPSK)@l) | (Ex #l. SKRev(sk)@l)))
    &   // Can't have OR before implication, so need two clauses
     (All tid u v sk idPSK #i #j #k.
         K(sk)@i & CommitR(tid, u, v, sk, idPSK)@j ==>
            ((Ex #l. LTKRev(idPSK)@l) | (Ex #l. SKRev(sk)@l)))"
»,
«
lemma secrecyExpAuthSessionKey:
    all-traces
    "(All tid u v sk #i #j. K(sk)@i & CommitI(tid, u, v, sk)@j ==>
        ((Ex #k. LTKRev(u)@k) | (Ex #k. LTKRev(v)@k) | (Ex #k. SKRev(sk)@k)))
    &   // Can't have OR before implication, so need two clauses
     "(All tid u v sk #i #j. K(sk)@i & CommitR(tid, u, v, sk)@j ==>
        ((Ex #k. LTKRev(u)@k & #k < #j) | (Ex #k. LTKRev(v)@k) | (Ex #k. SKRev(sk)@k)))"
»)
*/


/* PFS (implying regular secrecy) of session key.
 * With matching sessions proof as well, we get "symbolic CK-security".
 *
 * Verifies for:
 * PSK_PSK in 59 seconds
 * SIG_STAT in 1 minutes 46 seconds
 * SIG_SIG in 1 minutes 38 seconds
 * STAT_STAT in 3 minutes 18 seconds
 *
 * Note the implicit flavor: it only holds *if* *both* parties commit to the
 *  parameters then
 */
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
«
lemma secrecyImpSessionKeyPFS:
    all-traces
    "All tidI tidR u v sk idPSK #i #j #k. (K(sk)@i & CommitI(tidI, u, v, sk, idPSK)@j & CommitR(tidR, u, v, sk, idPSK)@k) ==>
        ((Ex #l. LTKRev(idPSK)@l & #l < #k) | (Ex #l. SKRev(sk)@l))"
»,
«
lemma secrecyImpSessionKeyPFS:
    all-traces
    "All tidI tidR u v sk #i #j #k. (K(sk)@i & CommitI(tidI, u, v, sk)@j & CommitR(tidR,u, v, sk)@k) ==>
        ((Ex #l. LTKRev(u)@l & #l < #k) | (Ex #l. LTKRev(v)@l & #l < #k) | (Ex #l. SKRev(sk)@l))"
»)

/*
 * Implicit agreement - at least on session key, u, v.
 * FIXME: PSKPSK falsified in 34 minutes
 */
/*
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
«
lemma impAgreement:
    "All tidI u v sk idPSK #i. CommitI(tidI, u, v, sk, idPSK)@i ==>
        (All tidR up vp skp idPSKp #j. CommitR(tidR, up, vp, skp, idPSKp)@j ==>
            ( (u = up & v = vp & sk = skp & idPSK = idPSKp)
            | (Ex #k. LTKRev(idPSK)@k & #k < #i)
            | (Ex #k. LTKRev(idPSKp)@k & #k < #j)
            )
        )
    "
»,
«
    "All tidI u v sk #i. CommitI(tidI, u, v, sk)@i ==>
        (All tidR up vp skp #j. CommitR(tidR, up, vp, skp)@j ==>
            ( (u = up & v = vp & sk = skp)
            | (Ex #k. LTKRev(u)@k & #k < #i)
            | (Ex #k. LTKRev(v)@k & #k < #i)
            | (Ex #k. LTKRev(up)@k & #k < #j)
            | (Ex #k. LTKRev(vp)@k & #k < #j)
            )
        )
    "

»)
*/
end


