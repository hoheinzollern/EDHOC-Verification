changequote(`«', `»')
ifelse(m4ATTACKER, PASSIVE, «define(Out, Msg($1)) define(In, Msg($1))», )
theory «edhoc_»m4METHODI«_»m4METHODR«_»m4ATTACKER
begin
builtins: diffie-hellman, xor, signing, hashing

/* WoW: Naming conventions:
 *  - camelCase for functions and properties
 *  - constants (0-arity functions) begin with "c"
 *  - do not use variable/constant names: x, y, vk (used by Tamarin internally,
 *                                                  and show up in the trace)
 *  - m4 macros are prefixed with m4 and the rest is all caps
 *  - begin sanity properties with "santity"    -- helps oracle
 *  - begin secrecy properties with "secrecy"   -- helps oracle
 *  - begin agreement properties with "agree"   -- helps oracle
 *
 */
functions:
    aeadEncrypt/4,  // Input: Key, plain-text, aad, cAEADx (AEAD algo ID)
    aeadDecrypt/4,  // Input: Key, cipher-text, aad, cAEADx (AEAD algo ID)
    decrypt/3,      // Input: Key, cipher-text, cAEADx (AEAD algo ID);
    xorEncrypt/2,   // Input: Key, plain-text
    xorDecrypt/2,   // Input: Key, cipher-text
    hkdfExtract/2,  // Input: Salt, random source
    hkdfExpand/2,   // Input: Salt, uniform random source
    cEmptyStr/0,
    cSUITE0/0,
        cAEAD0/0,   // cAEAD0 is part of cSUITE0 is the idea
        cHash0/0,   // cHash0 is part of cSUITE0 is the idea
    cSUITE1/0,
        cAEAD1/0,
        cHash1/0

equations:
    aeadDecrypt(key, aeadEncrypt(key, pt, aad, algoId), aad, algoId) = pt,
    decrypt(key, aeadEncrypt(key, pt, aad, algoID), algoId) = pt,
    xorDecrypt(k, xorEncrypt(k, pt)) = pt   // Too strong

restriction Eq:
    "All x y #i. Eq(x, y)@i ==> x = y"
restriction Neq:
    "All x y #i. Neq(x, y)@i ==> not(x = y)"

rule «I1_»m4METHODI«_»m4METHODR:
    let gx = 'g'^~xx
ifelse(«PSK_PSK», m4METHODI_m4METHODR,
        «m1 = <$«»m4METHODI«», $«»m4METHODR«», $cSUITE0, gx, ~C_I, ~ID_PSK, ~AD_1>»,
        «m1 = <$«»m4METHODI«», $«»m4METHODR«», $cSUITE0, gx, ~C_I,          ~AD_1>»
)dnl
    in
        [ !«LTK_»m4METHODR«»(<$U>, ~ltkU)  // $U is ID_PSK in PSK case
        , Fr(~xx)
        , Fr(~C_I)
        , Fr(~AD_1)
        ]
        --[
        ]->
        [ «StI1_»m4METHODI«_»m4METHODR«»($U, ~ltkU, <$U>, $V, ~xx, ~C_I, m1)
        , Out(m1)
        ]

rule «R2_»m4METHODI«_»m4METHODR:
    let m1 = <$m4METHODI, $m4METHODR, $cSUITE0, gx, ~C_I, ~AD_1>
        data_2 = <~C_I, 'g'^~yy, ~C_R>
        TH_2 = h(<$cHash0, m1, data_2>)
ifelse(«PSK_PSK», m4METHODI_m4METHODR,
        «prk_2e = hkdfExtract(~ltkV, gx^~yy)»,
        «prk_2e = hkdfExtract($cEmptyStr, gx^~yy)»
)dnl
ifelse(«STAT», m4METHODR,
        «grx = gx^~ltkV
         prk_3e2m = hkdfExtract(prk_2e, grx)»,
        «prk_3e2m = prk_2e»
)
        K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
        protected2 = $V // ID_CRED_V
ifelse(«STAT», m4METHODR,
        «CRED_V = 'g'^~ltkV»,
        «ifelse(«SIG», m4METHODR,
            «CRED_V = pk(~ltkV)»,
            «CRED_V = ~ltkV»
        )»
)
        extAad2 = <TH_2, CRED_V, ~AD_2>
        assocData2 = <protected2, extAad2>
        MAC_2 = aeadEncrypt($cEmptyStr, K_2m, assocData2, $cAEAD0)
ifelse(«SIG», m4METHODR,
        «authV = sign(<assocData2, MAC_2>, CRED_V)»,
        «authV = MAC_2»
)
        plainText2 = <$V, authV, ~AD_2>
        /* We don't use proper XOR to beging with
        K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
        K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
        K_2e_3 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '3'>, prk_2e)
        CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2, ~AD_2 XOR K_2e_3>
         */
        K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
        CIPHERTEXT_2 = xorEncrypt(K_2e, <$V, authV, ~AD_2>)
        m2 = <data_2, CIPHERTEXT_2>
ifelse(m4METHODI, m4METHODR,
        «sk = gx^~yy»,
        «ifelse(«STAT_SIG», m4METHODI«_»m4METHODR«»,
            «sk = gx^~yy»,   // Responder does not know G_IY here
            «ifelse(«SIG_STAT», m4METHODI«_»m4METHODR,
                «sk = <gx^~yy, grx>»,
                «sk = <gx^~yy, grx>» // STAT_STAT; also here no G_IY known to R
            )»
        )»
)
    in
        [ !«LTK_»m4METHODR«»($V, ~ltkV)
        , In(m1)
        , Fr(~yy)
        , Fr(~C_R)
        , Fr(~AD_2)
        ]
        --[ RunningR($V, sk)    // For PSK_PSK case we could get $U as well
          , Neq(gx, 'g')
          ]->
ifelse(«STAT», m4METHODR,
        «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltkV, ~C_R, ~C_I,
                             grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy)»,
        «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltkV, ~C_R, ~C_I,
                                  ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy)»
)
        , Out(m2)
        ]

rule «I3_»m4METHODI«_»m4METHODR«»:
    let
        data_2 = <~C_I, gy, ~C_R>
        TH_2 = h(<$cHash0, m1, data_2>)
ifelse(«PSK_PSK», m4METHODI«_»m4METHODR,
        «prk_2e = hkdfExtract(~ltkV, gy^~xx)»,
        «prk_2e = hkdfExtract($cEmptyStr, gy^~xx)»
)dnl
        /* We don't use proper XOR to beging with
        K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
        K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
        K_2e_3 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '3'>, prk_2e)
        CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2, ~AD_2 XOR K_2e_3> */
        K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
        CIPHERTEXT_2 = xorDecrypt(K_2e, <$V, authR, ~AD_2>)
        m2 = <data_2, CIPHERTEXT_2>
ifelse(«STAT», m4METHODR,
        «CRED_V = 'g'^~ltkV»,
        «ifelse(«SIG», m4METHODR,
            «CRED_V = pk(~ltkV)»,
            «CRED_V = ~ltkV»
        )»
)
ifelse(«STAT», m4METHODR,
        «grx = CRED_V^~xx
         prk_3e2m = hkdfExtract(prk_2e, grx)»,
        «prk_3e2m = prk_2e»
)
        K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
        protected2 = $V // ID_CRED_V
        extAad2 = <TH_2, ~ltkV, ~AD_2>
        assocData2 = <protected2, extAad2>
        MAC_2 = aeadEncrypt($cEmptyStr, K_2m, assocData2, $cAEAD0)
        data_3 = ~C_R
        TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
ifelse(«STAT», m4METHODI,
        «giy = gy^~ltkU
         prk_4x3m = hkdfExtract(prk_3e2m, giy)»,
        «prk_4x3m = prk_3e2m»
)
        K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
        protected3 = $U // ID_CRED_U
ifelse(«STAT», m4METHODI,
        «CRED_U = 'g'^~ltkU»,
        «ifelse(«SIG», m4METHODI,
            «CRED_U = pk(~ltkU)»,
            «CRED_U = ~ltkU»
        )»
)
        extAad3 = <TH_3, CRED_U, ~AD_3>
        assocData3 = <protected3, extAad3>
        MAC_3 = aeadEncrypt($cEmptyStr, K_3m, assocData3, $cAEAD0)
ifelse(«STAT», m4METHODI,
        «authU = sign(<assocData3, MAC_3>, CRED_U)»,
        «authU = MAC_3»
)
        plainText3 = <$U, authU, ~AD_3>
        K_3ae = hkdfExpand(<$cAEAD0, TH_3, 'K_3ae'>, prk_4x3m)   // uniq
        extAad3Outer = <TH_3>
        CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
        m3 = <data_3, CIPHERTEXT_3>
ifelse(m4METHODI, m4METHODR,
        «sk = gy^~xx»,
        «ifelse(«STAT_SIG», m4METHODI«»_«»m4METHODR,
            «sk = gy^~xx»,   // Responder does not know G_IY here
            «ifelse(«SIG_STAT», m4METHODI«»_«»m4METHODR,
                «sk = <gy^~xx, grx>»,
                «sk = <gy^~xx, grx>» // STAT_STAT; also here no G_IY known to R
            )»
        )»
)
    in
        [ «StI1_»m4METHODI«_»m4METHODR«»($U, ~ltkU, <$U>, $V, ~xx, ~C_I, m1)
        ,
ifelse(«STAT», m4METHODR,
          «!PK_STAT($V, 'g'^~ltkV)»,
          «ifelse(«SIG», m4METHODR,
            «!PK_SIG($V, pk(~ltkV))»,
            «!PK_PSK(<$U, $V>, ~ltkV)»
          )»
)
        , Fr(~AD_3)
        , In(m2)
        ]
        --[
ifelse(«SIG», m4METHODR,
        «Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)»,
        «Eq(authR, MAC_2)»
)
          , RunningI($U, $V, sk)        // For agreement of all params
          , CommitI($U, $V, sk)         // For agreement of all params
          , SessKeyCommitI($U, $V, sk)  // For sk secrecy
          ]->
        [ Out(m3) ]

rule «R4_»m4METHODI«_»m4METHODR«»:
    let
        TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
        extAad3Outer = <TH_3>
ifelse(«STAT», m4METHODI,
        «prk_4x3m = hkdfExtract(prk_3e2m, giy)»,
        «prk_4x3m = prk_3e2m»
)
        K_3ae = hkdfExpand(<$cAEAD0, TH_3, 'K_3ae'>, prk_4x3m)   // uniq
        plainText3 = <$U, authI, AD_3>
        CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
        K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
        protected3 = $U // ID_CRED_U
ifelse(«STAT», m4METHODI,
        «CRED_U = 'g'^~ltkU
         giy = CRED_U^~yy»,
        ifelse(«SIG», m4METHODI,
            «CRED_U = pk(~ltkU)»,
            «CRED_U = ~ltkU»
))
        extAad3 = <TH_3, CRED_U, AD_3>
        assocData3 = <protected3, extAad3>
        MAC_3 = aeadEncrypt($cEmptyStr, K_3m, assocData3, $cAEAD0)
        m3 = <data_3, CIPHERTEXT_3>
ifelse(m4METHODI, m4METHODR,
        «sk = gxy»,
        «ifelse(«STAT_SIG», «»m4METHODI«»_«»m4METHODR«»,
            «sk = gxy»,   // Responder does not know G_IY here
            «ifelse(«SIG_STAT», «»m4METHODI«»_«»m4METHODR«»,
                «sk = <gxy, grx>»,
                «sk = <gxy, grx>» // STAT_STAT; also here no G_IY known to R
            )»
        )»
)
    in
ifelse(«STAT», m4METHODR,
        «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltkV, ~C_R, ~C_I,
                             grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy)»,
        «[ «StR2_»m4METHODI«_»m4METHODR«»($V, ~ltkV, ~C_R, ~C_I,
                                  ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy)»
)
        ,
ifelse(«STAT», m4METHODI,
          «!PK_STAT($U, 'g'^~ltkU)»,
          «ifelse(«SIG», m4METHODI,
            «!PK_SIG($U, pk(~ltkU))»,
            «!PK_PSK(<$U, $V>, ~ltkU)»
           )»
)
        , In(m3)
        ]
        --[
ifelse(«SIG», m4METHODR,
            «Eq(verify(authI, <assocData3, MAC_3>, CRED_U), true)»,
            «Eq(authI, MAC_3)»
)
          , CommitR($U, $V, sk)         // For agreement of all params
          , SessKeyCommitR($U, $V, sk)  // For sk secrecy
          ]->
        []


/*
 * Environment and adversary model additions to standard Dolev-Yao
 */
/* Register LTK for SIG key based authentication */
rule registerLTK_SIG:
    [Fr(~ltk)] --[]-> [!LTK_SIG($A, ~ltk),
                       !PK_SIG($A, pk(~ltk)),
                       Out(«<$A, pk(~ltk)>»)]

/* Register LTK for STAT key based authentication */
rule registerLTK_STAT:
    [Fr(~ltk)]
    --[]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(«<$A, 'g'^~ltk>»)]

/* Register LTK for PSK key based authentication */
rule registerLTK_PSK:
    [Fr(~ltk)] --[]-> [!LTK_PSK(<$A, $B>, ~ltk), !PK_PSK(<$A, $B>, ~ltk)]

/* Reveal LTK for all methods.
 * NOTE: leaks before run complete. More is needed for PFS.
 */
rule revealLTK_SIG:
    [!LTK_SIG($A, ltk)] --[LTKRev($A)]-> [Out(ltk)]
rule revealLTK_STAT:
    [!LTK_STAT($A, ltk)] --[LTKRev($A)]-> [Out(ltk)]
rule revealLTK_PSK:
    [!LTK_PSK($A, ltk)] --[LTKRev($A)]-> [Out(ltk)]

/* Reveal session key for all methods.
 * sk = <gxy> for PSK and SIG_SIG methods
 * sk = <gxy, grx> for SIG_STAT method
 * sk = <gxy, giy> for STAT_SIG method
 * sk = <gxy, grx, giy> for STAT_STAT method
 */
rule revealSessionKeyI:
    [SessKeyCommitI(u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
rule revealSessionKeyR:
    [SessKeyCommitR(u, v, sk)] --[SKRev(sk)]-> [Out(sk)]


/*
 * Invariants - Helper lemmas
 */
/* lemma invariantIntractRel: */
/*     "All p q #t0 #t1. InvIntractImpK(p, q)@t0 & K(p)@t1 ==> (Ex #t2. K(q)@t2)" */


/*
 * Sanity - Correct exectution trace exists
 * NOTE: this allows u = v. Is that what we want?
 */

lemma sanityComplete:
    exists-trace
    "Ex u v gxy #i #j. SessKeyCommitI(u, v, gxy)@i &
                       SessKeyCommitR(u, v, gxy)@j &
                       #i < #j &
                       not (Ex #k. K(gxy)@k)"


/*
 * Session key secrecy
 */
/*
lemma secrecySessionKey_SIG_SIG:
    all-traces
    "(All u v gxy #i #j. K(gxy)@i & CommitAsymI(«SIG_SIG», u, v, gxy)@j ==>
        (Ex #k. LTKRev(u)@k) | (Ex #k. SKRev(gxy)@k))
    &
     (All u v gxy #i #j. K(gxy)@i & CommitAsymR(«SIG_SIG», u, v, gxy)@j ==>
        (Ex #k. LTKRev(v)@k) | (Ex #k. SKRev(gxy)@k))"
*/


/*
 * Agreement - at least on session key, u, v.
 */
/* lemma agreement: */
/*     "All u v gxy #i. CommitAsymI(u, v, gxy)@i ==> */
/*         ( (Ex #j. AuthRSent(v, gxy, authR)@j) */
/*         | ((Ex #j. LTKRev(v)@j) | (Ex #j. LTKRev(u)@j) | (Ex #j. SKRev(gxy)@j)) */
/*         )" */

end


