changequote(`<!', `!>') ifelse(m4ATTACKER, PASSIVE, <!define(Out, Msg($1)) define(In, Msg($1))!>, ) theory <!edhoc_!>m4METHODI<!_!>m4METHODR<!_!>m4ATTACKER
define(m4METHODIR, m4METHODI<!_!>m4METHODR)
/* We tag the names in case we want to merge all methods in one model */
define(m4RULEI1, <!I1_!>m4METHODIR)
define(m4RULER2, <!R2_!>m4METHODIR)
define(m4RULEI3, <!I3_!>m4METHODIR)
define(m4RULER4, <!R4_!>m4METHODIR)
define(m4STATEI1, <!StI1_!>m4METHODIR)
define(m4STATER2, <!StR2_!>m4METHODIR)
/* Shorthands */
define(m4EMPTYSTR, <!'e'!>)

begin
builtins: diffie-hellman, xor, signing, hashing

/* WoW: Naming conventions:
 *  - camelCase for functions and properties
 *  - constants (0-arity functions) begin with "c"
 *  - do not use variable/constant names: x, y, vk (used by Tamarin internally,
 *                                                  and show up in the trace)
 *  - m4 macros are prefixed with m4 and the rest is all caps
 *  - begin sanity properties with "santity"    -- helps oracle
 *  - begin secrecy properties with "secrecy"   -- helps oracle
 *  - begin agreement properties with "agree"   -- helps oracle
 *
 */

/* Swapped order of key and plain-text for aead to match usage in model.
 */
functions:
    aead/4,         // Input: Plain-text, key, aad, cAEADx (AEAD algo ID)
    aeadDecrypt/4,  // Input: Cipher-text, key, aad, cAEADx (AEAD algo ID)
    decrypt/3,      // Input: Cipher-text, key, cAEADx (AEAD algo ID);
    extr/2,  // Input: Salt, random source
    expa/2    // Input: Salt, uniform random source

equations:
    aeadDecrypt(aead(pt, key, aad, algoId), key, aad, algoId) = pt,
    decrypt(aead(pt, key, aad, algoID), key, algoId) = pt

restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"

/* The attack where the attacker uses yy=1 works, so Initiater must check that
 * it is not the case. Same should be true for xx */
/*restriction VerifyGEs: "All ge #i. VerifyGE(ge)@i ==> not(ge ='g')"*/

rule m4RULEI1<!!>:
    let gx = 'g'^~xx
ifelse(<!PSK_PSK!>, m4METHODIR,
        <!ID_PSK = <$U, $V>
         m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $CS0, gx, ID_PSK>!>,
        <!m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $CS0, gx>!>
)
    in
ifelse(<!PSK_PSK!>, m4METHODIR,
        [ !<!LTK_!>m4METHODI<!!>(<$U, $V>, ~ltk),
        [ !<!LTK_!>m4METHODI<!!>($U, ~ltk)
)
        , Fr(~xx)
        , Fr(~tid)  /* Thread ID */
        ]
        --[ I1(~tid, $U, $V, m1)
          ]->
        [ m4STATEI1<!!>($U, ~ltk, $V, ~xx, m1, ~tid)
        , Out(m1)
        ]

rule m4RULER2<!!>:
    let
         gx = 'g'^xx       // This removes partial deconstructions
         data_2 = <'g'^~yy>
ifelse(<!PSK_PSK!>, m4METHODIR,
        <!ID_PSK = <$U, $V>
         m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $CS0, gx, ID_PSK>
         TH_2 = h(<$H0, m1, data_2>)
         prk_2e = extr(~ltk, gx^~yy)
         prk_3e2m = prk_2e
         extAad2 = TH_2
         plainText2 = m4EMPTYSTR //~AD_2
         K_2ae = expa(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
         CIPHERTEXT_2 = aead(plainText2, K_2ae, extAad2, $cAEAD0)
        !>,
        <!m1 = <'<!!>m4METHODI<!!>', '<!!>m4METHODR<!!>', $CS0, gx>
         TH_2 = h(<$H0, m1, data_2>)
         prk_2e = extr(m4EMPTYSTR, gx^~yy)
         ifelse(<!STAT!>, m4METHODR,
                 <!grx = gx^~ltk
                  prk_3e2m = extr(prk_2e, grx)!>,
                 <!prk_3e2m = prk_2e!>
         )
         K_2m = expa(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
         protected2 = $V // ID_CRED_V
         CRED_V = pkV
         extAad2 = <TH_2, CRED_V>
         assocData2 = <protected2, extAad2>
         MAC_2 = aead(m4EMPTYSTR, K_2m, assocData2, $cAEAD0)
         ifelse(<!SIG!>, m4METHODR,
            <!authV = sign(<assocData2, MAC_2>, ~ltk)!>,
            <!authV = MAC_2!>
         )
         plainText2 = <$V, authV>
         K_2e = expa(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
         /* K_2e is split in two parts to allow attacker to attack them
          * individually
          */
         K_2e_1 = expa(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
         K_2e_2 = expa(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
         CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2>
        !>
)
         m2 = <data_2, CIPHERTEXT_2>


/* Def of session key exp_sk we can get explicit auth (agreement) on */
/* I.e., exp_sk does not include G_IY */
ifelse(<!STAT_SIG!>, m4METHODIR,
    <!exp_sk = <gx^~yy>!>,  // Responder does not know G_IY when sending m2
    <!ifelse(<!SIG_STAT!>, m4METHODIR,
        <!exp_sk = <gx^~yy, grx>!>,
        <!ifelse(<!STAT_STAT!>, m4METHODIR,
            <!exp_sk = <gx^~yy, grx>!>, // Responder does not know G_IY when sending m2
            <!exp_sk = <gx^~yy>!> // SIG_SIG or PSK_PSK
        )!>
    )!>
)

    in
ifelse(<!PSK_PSK!>, m4METHODIR,
        [ !<!LTK_!>m4METHODR<!!>(<$U, $V>, ~ltk),
        [ !<!LTK_!>m4METHODR<!($V, ~ltk)
        ,  !PK_!>m4METHODR<!($V, pkV)!>
)
        , In(m1)
        , Fr(~yy)
        , Fr(~tid)
        ]
        --[ ExpRunningR(~tid, $V, exp_sk)
          , R2(~tid, $V, m1, m2)
          , VerifyGE(gx)
          , DH('g'^(~yy * xx), ~yy, xx, inv(~yy))
          //, RTypeI1(gx, m1)
          , RTypeO2(m2)
          //, RLTKinv($V, ~ltk, inv(~ltk), ~yy, inv(~yy))
ifelse(<!PSK_PSK!>, m4METHODIR,
          <!!>,
          <!!>
)
          ]->
ifelse(<!STAT!>, m4METHODR,
        [ m4STATER2<!!>($V, ~ltk, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2)
        ,
        <!ifelse(<!PSK_PSK!>, m4METHODIR,
            [ m4STATER2<!!>($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2),
            [ m4STATER2<!!>($V,     ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2)
        )!>
)
        , Out(m2)
        ]


rule m4RULEI3<!!>:
    let
         gy = 'g'^yy       // This removes partial deconstructions
         data_2 = <gy>
    /* Message 2 handling */
         TH_2 = h(<$H0, m1, data_2>)
ifelse(<!PSK_PSK!>, m4METHODIR,
        <!prk_2e = extr(~ltk, gy^~xx)
         prk_3e2m = prk_2e
         plainText2 = m4EMPTYSTR //~AD_2
         extAad2 = TH_2     // KARL: Why is not AD_2 covered in PSK case? Not necesssary, but it is included for the ASYM cases
         K_2ae = expa(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
         CIPHERTEXT_2 = aead(plainText2, K_2ae, extAad2, $cAEAD0) // MAC check by pattern matching
         m2 = <data_2, CIPHERTEXT_2>
        !>,
         /* STAT and SIG methods */
        <!prk_2e = extr(m4EMPTYSTR, gy^~xx)
         plainText2 = <$V, authR>
         CRED_V = pkV
         ifelse(<!STAT!>, m4METHODR,
            <!grx = CRED_V^~xx
             prk_3e2m = extr(prk_2e, grx)!>
             ,
            <!prk_3e2m = prk_2e!>
         )
         /* K_2e is split in two parts to allow attacker to attack them
          * individually
          */
         K_2e_1 = expa(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
         K_2e_2 = expa(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
         CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2>
         m2 = <data_2, CIPHERTEXT_2>

         K_2m = expa(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
         protected2 = $V // ID_CRED_V
         extAad2 = <TH_2, CRED_V>
         assocData2 = <protected2, extAad2>
         MAC_2 = aead(m4EMPTYSTR, K_2m, assocData2, $cAEAD0)
        !>
)

    /* Message 3 handling */
         data_3 = m4EMPTYSTR //~C_R
         TH_3 = h(<$H0, TH_2, CIPHERTEXT_2, data_3>)
         K_3ae = expa(<$cAEAD0, TH_3, 'K_3ae'>, prk_3e2m)
ifelse(<!PSK_PSK!>, m4METHODIR,
        <!extAad3 = TH_3
ifdef(<!m4AD3!>,
         <!plainText3 = ~AD_3!>,
         <!plainText3 = m4EMPTYSTR!>
)
         CIPHERTEXT_3 = aead(plainText3, K_3ae, extAad3, $cAEAD0)!>,
         /* STAT and SIG methods */
        <!ifelse(<!STAT!>, m4METHODI,
            <!giy = gy^~ltk
             prk_4x3m = extr(prk_3e2m, giy)!>,
            <!prk_4x3m = prk_3e2m!>
         )
         K_3m = expa(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
         protected3 = $U // ID_CRED_U
         CRED_U = pkU
ifdef(<!m4AD3!>,
         <!extAad3 = <TH_3, CRED_U, ~AD_3>!>,
         <!extAad3 = <TH_3, CRED_U>!>
)
         assocData3 = <protected3, extAad3>
         MAC_3 = aead(m4EMPTYSTR, K_3m, assocData3, $cAEAD0)
         ifelse(<!SIG!>, m4METHODI,
            <!authU = sign(<assocData3, MAC_3>, ~ltk)!>,
            <!authU = MAC_3!>
         )
ifdef(<!m4AD3!>,
         <!plainText3 = <$U, authU, ~AD_3>!>,
         <!plainText3 = <$U, authU>!>
)
         extAad3Outer = TH_3
         CIPHERTEXT_3 = aead(plainText3, K_3ae, extAad3Outer, $cAEAD0)
         !>
)
         m3 = <data_3, CIPHERTEXT_3>

/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(<!STAT_SIG!>, m4METHODIR,
    <!exp_sk = <gy^~xx>!>,  // Responder does not know G_IY when sending m2
    <!ifelse(<!SIG_STAT!>, m4METHODIR,
        <!exp_sk = <gy^~xx, grx>!>,
        <!ifelse(<!STAT_STAT!>, m4METHODIR,
            <!exp_sk = <gy^~xx, grx>!>, // Responder does not know G_IY when sending m2
            <!exp_sk = <gy^~xx>!> // SIG_SIG or PSK_PSK
        )!>
    )!>
)

/* Def of session key imp_sk we can get explicit auth (agreement) on I->R, but only
 * implicitly on R->I because R does not know G_IY when sending message 2,
 * so I cannot deduce that R is using the same value of GIY when I completes.
 */
ifelse(<!STAT!>, m4METHODI,
    <!imp_sk = <exp_sk, giy>!>,
    <!imp_sk =  exp_sk!>
)

    in
ifelse(<!PSK_PSK!>, m4METHODIR,
        [ m4STATEI1<!!>($U, ~ltk, $V, ~xx, m1, ~tid)
        ,
        [ m4STATEI1<!!>($U, ~ltk, $V, ~xx, m1, ~tid)
        <!, !PK_!>m4METHODR<!!>($V, pkV)
        <!, !PK_!>m4METHODI<!!>($U, pkU)
)
        , In(m2)
ifdef(<!m4AD3!>,
        <!, Fr(~AD_3)!>
)
        ]
        --[ ExpCommitI(~tid, $U, $V, exp_sk)  // standard running/commit
          , CommitI(~tid, $U, $V, imp_sk)  // Requires R to complete
          , ExpRunningI(~tid, $U, $V, exp_sk)  // Sugar for standard running/commit
          , RunningI(~tid, $U, $V, imp_sk)  // Sugar for standard running/commit
          , I3(~tid, $U, $V, m1, m2, m3)
          , VerifyGE(gy)
          , DH('g'^(~ltk*yy), ~ltk, yy, inv(~ltk))
ifelse(<!STAT!>, m4METHODI,
          <!, ITypeI3('g', 'g'^~xx, gy, giy, ~xx, m2)!>, <!!>)
          , ITypeGxy(gy^~xx, ~xx, gy, 'g'^inv(~xx), m2)
ifelse(<!PSK_PSK!>, m4METHODIR,
          <!!>,
          <!!>
)
ifelse(<!SIG!>, m4METHODR,
         <!, Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)!>,
         <!ifelse(<!STAT!>, m4METHODR,
             <!, Eq(authR, MAC_2)!>,
             <!, Eq('1', '1')!>  /* nothing; to avoid tamrarin complainging for PSK */
         )!>
)
          ]->
        [ Completed(imp_sk, ~xx)
        , Out(m3)
        ]

rule m4RULER4:
    let
        data_3 = m4EMPTYSTR //~C_R
        TH_3 = h(<$H0, TH_2, CIPHERTEXT_2, data_3>)
        K_3ae = expa(<$cAEAD0, TH_3, 'K_3ae'>, prk_3e2m)
ifelse(<!PSK_PSK!>, m4METHODIR,
       <!extAad3 = TH_3
ifdef(<!m4AD3!>,
        <!plainText3 = ~AD_3!>,
        <!plainText3 = m4EMPTYSTR!>
)
        CIPHERTEXT_3 = aead(plainText3, K_3ae, extAad3, $cAEAD0) // MAC check by pattern matching
       !>,
        /* STAT and SIG methods */
       <!CRED_U = pkU
        extAad3 = TH_3
ifdef(<!m4AD3!>,
        <!plainText3 = <$U, authI, ~AD_3>!>,
        <!plainText3 = <$U, authI>!>
)
        CIPHERTEXT_3 = aead(plainText3, K_3ae, extAad3Outer, $cAEAD0) // MAC check by pattern matching
        ifelse(<!STAT!>, m4METHODI,
           <!giy = CRED_U^~yy
            prk_4x3m = extr(prk_3e2m, giy)!>,
           <!prk_4x3m = prk_3e2m!>
        )
        K_3m = expa(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
        protected3 = $U // ID_CRED_U
ifdef(<!m4AD3!>,
        <!extAad3 = <TH_3, CRED_U, ~AD_3>!>,
        <!extAad3 = <TH_3, CRED_U>!>
)
        assocData3 = <protected3, extAad3>
        MAC_3 = aead(m4EMPTYSTR, K_3m, assocData3, $cAEAD0)
       !>
)
        m3 = <data_3, CIPHERTEXT_3>

/* Def of session key exp_sk we can get explicit auth (agreement) on */
ifelse(<!STAT_SIG!>, m4METHODIR,
    <!exp_sk = <gxy>!>,  // Responder does not know G_IY when sending m2
    <!ifelse(<!SIG_STAT!>, m4METHODIR,
        <!exp_sk = <gxy, grx>!>,
        <!ifelse(<!STAT_STAT!>, m4METHODIR,
            <!exp_sk = <gxy, grx>!>, // Responder does not know G_IY when sending m2
            <!exp_sk = <gxy>!> // SIG_SIG or PSK_PSK
        )!>
    )!>
)

/* Def of session key imp_sk we can get explicit auth (agreement) on I->R, but only
 * implicitly on R->I because R does not know G_IY when sending message 2,
 * so I cannot deduce that R is using the same value of GIY when I completes.
 */
ifelse(<!STAT!>, m4METHODI,
    <!imp_sk = <exp_sk, giy>!>,
    <!imp_sk =  exp_sk!>
)

    in
ifelse(<!STAT!>, m4METHODR,
        <![ m4STATER2<!!>($V, ~ltk, grx, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2)!>,
        <!ifelse(<!PSK_PSK!>, m4METHODIR,
            <![ m4STATER2<!!>($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2)!>,
            <![ m4STATER2<!!>($V,     ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2)!>
        )!>
)
ifelse(<!PSK_PSK!>, m4METHODIR,
        <!!> /* NOTHING */
        , /* All other methods */
        <!, !PK_!>m4METHODI<!!>($U, pkU)
        <!, !PK_!>m4METHODR<!!>($V, pkV)
)
        , In(m3)
        ]
        --[ ExpCommitR(~tid, $U, $V, exp_sk)
          , CommitR(~tid, $U, $V, imp_sk)
          , R4(~tid, $U, $V, m1, m2, m3)
ifelse(<!SIG!>, m4METHODI,
         <!, Eq(verify(authI, <assocData3, MAC_3>, CRED_U), true)!>,
         <!ifelse(<!STAT!>, m4METHODI,
             <!, Eq(authI, MAC_3)!>,
             <!!>  /* nothing */
         )!>
)
          ]->
        [ Completed(imp_sk, ~yy) ]

/*
 * Environment and adversary model additions to standard Dolev-Yao
 */
/* Assume binding between identities and their credentials */
restriction uniqLTKs:
    "All id k1 k2 #i #j. (UniqLTK(id, k1)@i & UniqLTK(id, k2)@j) ==> k1 = k2"


/* LTK Registration and LTK-reveal per */
ifelse(<!STAT_SIG!>, m4METHODIR,                   // STAT_SIG
    <!
rule registerLTK_SIG:
    [Fr(~ltk)] --[UniqLTK($A, ~ltk)]-> [!LTK_SIG($A, ~ltk),
                                        !PK_SIG($A, pk(~ltk)),
                                        Out(<!<$A, pk(~ltk)>!>)]
rule registerLTK_STAT:
    [Fr(~ltk)]
    --[UniqLTK($A, 'g'^~ltk)]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]

rule revealLTK_SIG:
    [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT:
    [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
    !>,
    <!ifelse(<!SIG_STAT!>, m4METHODIR,             // SIG_STAT
        <!
rule registerLTK_SIG:
    [Fr(~ltk)] --[UniqLTK($A, ~ltk)]-> [!LTK_SIG($A, ~ltk),
                                        !PK_SIG($A, pk(~ltk)),
                                        Out(<!<$A, pk(~ltk)>!>)]
rule registerLTK_STAT:
    [Fr(~ltk)]
    --[UniqLTK($A, 'g'^~ltk)]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]

rule revealLTK_SIG:
    [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT:
    [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
        !>,
        <!ifelse(<!STAT_STAT!>, m4METHODIR,       // STAT_STAT
            <!
rule registerLTK_STAT:
    [Fr(~ltk)]
    --[UniqLTK($A, 'g'^~ltk)]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]

rule revealLTK_STAT:
    [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
            !>,
            <!ifelse(<!SIG_SIG!>, m4METHODIR,     // SIG_SIG
            <!
rule registerLTK_SIG:
    [Fr(~ltk)] --[UniqLTK($A, ~ltk)]-> [!LTK_SIG($A, ~ltk),
                                        !PK_SIG($A, pk(~ltk)),
                                        Out(<!<$A, pk(~ltk)>!>)]
rule revealLTK_SIG:
    [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
            !>,
            <!                                                 // PSK_PSK
rule registerLTK_PSK:
    [Fr(~ltk)] --[UniqLTK(<$A, $B>, ~ltk)]-> [!LTK_PSK(<$A, $B>, ~ltk)]
rule revealLTK_PSK:
    [!LTK_PSK(<$A, $B>, ~ltk)] --[LTKRev(<$A, $B>)]-> [Out(~ltk)]
            !>
            )!>
        )!>
    )!>
)

/* PCS interface */
ifelse(ifelse(<!SIG!>, m4METHODI, 1, ifelse(<!SIG!>, m4METHODR, 1, 0)), 1,
<!rule forge_SIG:
    [!LTK_SIG($A, ~ltk), In(xx)] --[TEE($A)]-> [Out(sign(xx, ~ltk))]!>
)
ifelse(ifelse(<!STAT!>, m4METHODI, 1, ifelse(<!STAT!>, m4METHODR, 1, 0)), 1,
<!rule exp_STAT:
    [!LTK_STAT($A, ~ltk), In('g'^x)] --[TEE($A)]-> [Out(('g'^x)^~ltk)]!>
)
ifelse(<!PSK!>, m4METHODI,
<!rule forge_PSK:
    [!LTK_PSK(<$A, $B>, ~ltk), In(xx)] --[TEE($A), TEE($B)]-> [Out(extr(~ltk, xx))]!>
)

/* Reveal session key for all methods.
 * Explicit authentication possible for:
 * sk = <gxy> for PSK and SIG_SIG methods
 * sk = <gxy, grx> for SIG_STAT method
 * sk = <gxy> for STAT_SIG method           -- GIY not known to R for msg2
 * sk = <gxy, grx> for STAT_STAT method     -- GIY not known to R for msg2
 * Implicit authentication *possible* for:
 * sk = <gxy> for PSK and SIG_SIG methods
 * sk = <gxy, grx> for SIG_STAT method
 * sk = <gxy, giy> for STAT_SIG method
 * sk = <gxy, grx, giy> for STAT_STAT method
 */
rule revealSessionKey:
    [Completed(sk, ~xx)] --[SKRev(sk)]-> [Out(~xx)]

/*
 * Invariants - Helper lemmas
 */
 /* --> Reduces partial deconstructions from 481 to 273 when g^xx and g^yy
    are not explicitly matched by the ruels.

lemma typingGiy [sources]:
    all-traces
    "All g gx gy giy xx m2 #i. ITypeI3(g, gx, gy, giy, xx, m2)@i ==>
        ((Ex #j. KU(giy)@j & #j < #i) | (Ex #j. RTypeO2(m2)@j & #j < #i))
    "
*/

/*ifelse(<!PSK_PSK!>, m4METHODIR,
<!
lemma gxySplitter [reuse]:
    all-traces
    "All gxy x gy gyinvx m2 #i. ITypeGxy(gxy, x, gy, gyinvx, m2)@i ==>
        ((Ex #j. KU(gxy)@j & #j < #i) | (Ex #j. RTypeO2(m2)@j & #j < #i))
    "
lemma gxySplitter2 [reuse]:
    all-traces
    "All gxy x gy gyinvx m2 #i #j.
        ((ITypeGxy(gxy, x, gy, gyinvx, m2)@i & KU(gxy)@j & #j < #i) ==>
         (Ex #k. SKRev(gxy)@k & #k < #j))
    "
!>,<!!>
)
ifelse(<!STAT!>, m4METHODI,
<!
lemma giyTyping [reuse]:
    all-traces
    "All g gx gy giy xx m2 #i. ITypeI3(g, gx, gy, giy, xx, m2)@i ==>
        ((Ex #j. KU(giy)@j & #j < #i) | (Ex #j. RTypeO2(m2)@j & #j < #i))
    "
lemma giySplitter [reuse]:
    "All gab a b inva #i #j.
         ((DH(gab, a, b, inva)@i & KU(a*b*inva)@j) ==>
            ( (Ex #k. KU(a)@k & #k < #j)
            | (Ex #k. KU(b*inva)@k & #k < #j)
            )
         )"
lemma giySplitter2 [reuse]:
    "All gab a b inva #t0 #t1 #t2 #t3.
         //((DH(gab, a, b, inva)@t0 & KU(a*b*inva)@t1 & KU(a)@t2 & KU(b*inva)@t3)
         ((DH(gab, a, b, inva)@t0 & KU(b*inva)@t3)
             ==>
            ( (Ex #i. KU(b)@i & #i < #t1)
            | (Ex #i. KU(inva)@i & #i < #t1)
            )
         )"
lemma giySplitter3 [reuse]:
    "All gab a b inva #t0 #t1 #t2 #t3.
         ((DH(gab, a, b, inva)@t0 & KU(gab)@t1) ==>
            ( (Ex #i. KU(b*inva)@i & #i < #t1))
         )"
!>,<!!>
)*/

/*
 * Sanity - Correct exectution trace exists
 */
lemma sanityExecutableToTheEnd:
    exists-trace
    "(Ex tidI tidR u v m1 m2 m3 sk sk2 #i #j #k #l.
       I1(tidI, u, v, m1)@i
     & R2(tidR, v, m1, m2)@j & #i < #j
     & I3(tidI, u, v, m1, m2, m3)@k &  #j < #k
     & CommitI(tidI, u, v, sk)@k
     & ExpCommitI(tidI, u, v, sk2)@k
     & RunningI(tidI, u, v, sk)@k
     & ExpRunningI(tidI, u, v, sk2)@k
     & R4(tidR, u, v, m1, m2, m3)@l &  #k < #l
     & CommitR(tidR, u, v, sk)@l
     & ExpCommitR(tidR, u, v, sk2)@l
     )
    "

lemma sanitySKRev:
    exists-trace
    "Ex sk #i. SKRev(sk)@i"

lemma sanityLTKRev:
    exists-trace
    "Ex u #i. LTKRev(u)@i"


/* Note that this only shows agreement on a reduced session key from R to I
 * since Responder does not know GIY when sending message 2, i.e., when Initiator
 * uses STAT method for authentication towards Responder.
 * This is for the session key we can explicitly show agreement for.
 * Also: Initiator gets no guarantee that R knows u (that should in fact
 * not be possible due to identity protection).
 */
/*lemma authInjAgreeGuaranteeForI:
    all-traces
    "All tidI u v expSk #i.
         (ExpCommitI(tidI, u, v, expSk)@i
          ==>
         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
           & not(Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2 & not(#i = #i2) ) )
ifelse(<!PSK_PSK!>, m4METHODIR,
          <! | (Ex #j. LTKRev(<u, v>)@j & #j < #i) !>,
          <! | (Ex #j. LTKRev(u)@j & #j < #i)
             | (Ex #j. LTKRev(v)@j & #j < #i)!>
)
         ))"*/
/* PCS version */
lemma authInjAgreeGuaranteeForI:
    all-traces
    "All tidI u v expSk #i.
         ((ExpCommitI(tidI, u, v, expSk)@i
	        & (All #j m1. I1(tidI, u, v, m1) @ j ==> (All #k. TEE(u)@k ==> k < j) & (All #k. TEE(v)@k ==> k < j))
            & (All tidR #j m1 m2. R2(tidR, v, m1, m2) @ j ==> (All #k. TEE(u)@k ==> k < j) & (All #k. TEE(v)@k ==> k < j))
         )
          ==>
         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
           & not(Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2 & not(#i = #i2) ) )
ifelse(<!PSK_PSK!>, m4METHODIR,
          <! | (Ex #j. LTKRev(<u, v>)@j & #j < #i) !>,
          <! | (Ex #j. LTKRev(u)@j & #j < #i)
             | (Ex #j. LTKRev(v)@j & #j < #i)!>
)
         ))"


/* This shows agreement on the full session key and both u and v.
 * Note that this holds both for the key material we call explicitly
 * authenticated (excluding G_IY) and for the key material we call
 * implicitly authenticated (which includes G_IY).
 * The name "implicit" comes from that I can only get impilicit agreement on
 * it even though R can get explicit dito.
 */
/*lemma authInjAgreeGuaranteeForR:
    all-traces
    "All tidR u v expSk #i.
         (ExpCommitR(tidR, u, v, expSk)@i
          ==>
         ( ( (Ex tidI #j. ExpRunningI(tidI, u, v, expSk)@j & #j < #i)
           & not(Ex tidR2 u2 v2 #i2. ExpCommitR(tidR2, u2, v2, expSk)@i2 & not(#i = #i2) ) )
ifelse(<!PSK_PSK!>, m4METHODIR,
          <! | (Ex #j. LTKRev(<u, v>)@j & #j < #i) !>,
          <! | (Ex #j. LTKRev(u)@j & #j < #i)
             | (Ex #j. LTKRev(v)@j & #j < #i)!>
)
         ))"*/
/* PCS version */
lemma authInjAgreeGuaranteeForR:
    all-traces
    "All tidR u v sk #i.
         ((CommitR(tidR, u, v, sk)@i
	        & (All tidI #j m1. I1(tidI, u, v, m1) @ j ==> (All #k. TEE(u)@k ==> k < j) & (All #k. TEE(v)@k ==> k < j))
            & (All #j m1 m2. R2(tidR, v, m1, m2) @ j ==> (All #k. TEE(u)@k ==> k < j) & (All #k. TEE(v)@k ==> k < j)) )
         )
         ==>
         ( ( (Ex tidI #j. ExpRunningI(tidI, u, v, sk)@j & #j < #i)
           & not(Ex tidR2 u2 v2 #i2. ExpCommitR(tidR2, u2, v2, sk)@i2 & not(#i = #i2)) )
ifelse(<!PSK_PSK!>, m4METHODIR,
          <! | (Ex #j. LTKRev(<u, v>)@j & #j < #i) !>,
          <! | (Ex #j. LTKRev(u)@j & #j < #i)
             | (Ex #j. LTKRev(v)@j & #j < #i)!>
)
         )"


/* If we include G_IY in the session key material, we will not get (injective)
 * agreement on the session key material from the responder to the initator.
 * We instead show implicit authentication of the key material.
 * This is a weaker guarantee than injective agreement that essentially
 * guarantees to a party U that has completed its protocol run and believes
 * the protocol is run with party V, that *if* there is anybody out there who
 * has computed this session key (at some point), then that party is V and
 * V believes it ran the protocol with U.
 *
 * Note that we already proved injective agreement guarantee on the full
 * session key material (including G_IY) from Initiator to Responder above, so
 * we only have to fall back to implicit authentication "from" Responder to
 * Initiator.
 *
 * Second note: This is only interesting when the Initiator is using STAT
 * method.  In all other cases we have no G_IY and hence have injective
 * agreement on the entire key material becasue expSK is equal to impSK.
 * Nontheless, we prove it for all methods. This gives a common security
 * level that users can expect from all methods.
 *
 */
lemma authGIYImplicitAuthGuaranteeForI:
    all-traces
    "All tidI u v impSk #i.
         CommitI(tidI, u, v, impSk)@i ==>
         ( ( (All tidR u2 v2 #j. CommitR(tidR, u2, v2, impSk)@j ==>
                (u = u2  &  v = v2)
             )
           &
             (not Ex #k. SKRev(impSk)@k)
           &
             (not( Ex tidR u v #j tidR2 u2 v2 #j2.
                      ( CommitR(tidR,  u,  v,  impSk)@j
                      & CommitR(tidR2, u2, v2, impSk)@j2
                      & not(#j = #j2)
                      )
                 )
             )
           )
         | (Ex #k. LTKRev(u)@k) | (Ex #k. TEE(u)@k)
         | (Ex #k. LTKRev(v)@k) | (Ex #k. TEE(v)@k)
         )
    "

/* PFS (implying regular secrecy) of session key (**including G_IY**).
 */
ifelse(<!PSK_PSK!>, m4METHODIR,
    <!lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )
         &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & LTKRev(v)@l  & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )"
    !>,
<!ifelse(<!STAT!>, m4METHODR,  // REALLY? --> STAT_STAT or SIG_STAT -- THIS SHOULD FAIL!
    <!lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )
         &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )"
    !>,
<!ifelse(<!STAT!>, m4METHODI,  // STAT_SIG
    <!lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )
         &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )"
    !>,
    // else: SIG_SIG
    <!lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )
         &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l) | (Ex w #l. TEE(w)@l))
         )"
    !>
)!>
)!>
)

/* Because G_IY only exists when Initator uses STAT method, we only verify
 * the lemmas for those two cases.  All other cases are covered by the
 * regular injective agreement lemma.
 *
 * We cannot model that the injective agreement guarantee fails for
 * the initator, because that would require adding a Running event including
 * G_IY in rule R2, which it does not have at that point.
 *
 * Because we use the pre-specified peer setting, we could cheat in the model
 * and add such an event.  This would result in that R2 "guesses" the initiator's
 * identity and emmits a Eunning event based on the guess.
 * Since there wil be one run of R for each G_IY, R will try all identities for
 * I, but at least one of them will fail.
 * This seems a useless and contrived we to "prove" that there is no agreement
 * on G_IY, so we won't do it.  Maybe something to describe in the paper.
 *
 * A more accurate model would be to use the post-specified peer setting,
 * in which R learns the identity of I during the protocol run.
 * Likely that setting would result in even more complex task for Tamarin
 * to handle.
 */

/* KCI - for SIGSIG it is ridicuolus, but we show it anyway */
/*

lemma authKCIInjAgreeGuaranteeForI:
    all-traces
    "All tidI u v expSk #i.
         ExpCommitI(tidI, u, v, expSk)@i ==>
         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
           & not( Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2
                & not(#i = #i2)
                )
           )
         //| (Ex #j. TEE(v)@j)
         | (Ex #j. LTKRev(v)@j & #j < #i)
         )
    "
lemma authKCIInjAgreeGuaranteeForR:
    all-traces
    "All tidR u v sk #i.
         CommitR(tidR, u, v, sk)@i
         ==>
         ( ( (Ex tidI #j. ExpRunningI(tidI, u, v, sk)@j & #j < #i)
           & not( Ex tidR2 u2 v2 #i2. ExpCommitR(tidR2, u2, v2, sk)@i2
                & not(#i = #i2)
                )
           )
         //| (Ex #j. TEE(u)@j)
         | (Ex #j. LTKRev(u)@j & #j < #i)
	     )
    "

/* KCI for STAT-based methods */
lemma authKCIImpGIYImplicitAuthGuaranteeForI:
    all-traces
    "All tidI u v impSk #i.
         CommitI(tidI, u, v, impSk)@i ==>
         ( ( (All tidR u2 v2 #j. CommitR(tidR, u2, v2, impSk)@j ==>
                (u = u2  &  v = v2)
             )
           &
             (not Ex #k. K(impSk)@k)
           &
             (not( Ex tidR u v #j tidR2 u2 v2 #j2.
                      ( CommitR(tidR,  u,  v,  impSk)@j
                      & CommitR(tidR2, u2, v2, impSk)@j2
                      & not(#j = #j2)
                      )
                 )
             )
           )
         //| (Ex #k. TEE(v)@k)
         | (Ex #k. LTKRev(v)@k & #k < #i)
         )
    "
*/
end
