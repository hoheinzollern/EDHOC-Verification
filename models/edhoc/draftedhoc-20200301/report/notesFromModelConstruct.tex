%-------------------------------------------------------------------------- sec
\section{Methods}
\knote{The text that follows was written during the model construction. The
    intention is to keep it here fore reference until we have lifted up what is
    needed to the real report/paper and then delete this annex.
}
%-------------------------------------------------------------------------- sec
\section{Properties}
%-------------------------------------------------------------------------- sub
\subsection{Secrecy}
%-------------------------------------------------------------------------- sub
\subsubsection{Sessions}
\label{sec:mail-notes-secrecy-sessions}
%
We use $U, V, g^{xy}$ as \textbf{session identifier}.
%
Because $x$ and $y$ are large and drawn from a uniform distribution at every
protocol run, this identifier is unique with high probability.
%
In our model, $x$ and $y$ are represented by new names and therefore guaranteed
to be unique.
%
\knote{We may want to include $g^{Iy}$ and $g^{Rx}$ also when static keys are
    involved, in case the adversary manages to make some party accept a correct
    $g^{x,y}$ with a wrong $g^{Iy}$ or $g^{Rx}$, or vice versa.}
%


We are interested in \textbf{session key independence}, but
the way we have defined session key secrecy, makes it unclear what that means.
%
See session key below.
%

%-------------------------------------------------------------------------- sub
\subsubsection{Session key material}
\label{sec:mail-notes-session-key-mtrl}
%
By \textbf{session key material}, or session keys for short,  we mean the
keying material derived by an initiator or responder during a run of the
protocol in presence of an active adversary.
%

As session key material for the PSK method we consider $g^{xy}$.
%
The reason is that to show key agreement using correspondence properties, we
cannot include \mConstStyle{TH\_4}, which covers the hash of the third message.
%
So, when the initiator completes, there is not yet a corresponding event in
the responder trace which includes \mConstStyle{TH\_4}.
%
Because binding in \mConstStyle{TH\_4} does not add any further secrecy, there
is no harm in focusing on $g^{xy}$.
%

The same argument goes for the method where both parts authenticate via
signatures, but not when one or both parties use static DH key authentication.
%
When the Initiator is using a static DH key, the session key material is
$g^{xy}$, $g^{Iy}$ and $g^{Rx}$.
%
\knote{This is because EDHOC copied it from OPTLS. However, OPTLS was designed
    for the CK-model and differentiates between compromise and session state
    reveal queries. EDHOC is not as structurally designed and don't care about
separating the two and it may be sufficient to use only $g^{xy}$ in that case.
However: I suspect the authentication in OPTLS comes from the signatures
Krawczyk designed for HMQV, and in that case the signatures \emph{are} the key.
I need to investigate this.
}
%
%-------------------------------------------------------------------------- sub
\subsection{Authentication}
%-------------------------------------------------------------------------- sub
\subsubsection{Session key authentication}
\label{sec:mail-notes-session-key-auth}
%
When both parties use signatures, there is no $g^{Iy}$ or $g^{Rx}$, but instead
the key and entity authentication is based on that each party explicitly signs
the data they are supposed to agree on.
%
So in that case the session key material established consists of $g^{xy}$
only.
% 
This means that the initiator will, when receiving message 2, get a signature
covering $g^{xy}$ and $V$, and this is the main point: the Initiator can
verify this signature.
%
So when the Initiator completes, it knows:
%
\begin{itemize}
    \item that it communicated with party $V$,
    \item that $V$ has access to the session key material $g^{xy}$.
\end{itemize}
%
That is, the Initiator explicitly authenticated $V$ and the session key
material.
%
The corresponding holds for the Responder when it completes after receiving
message 3.
%
Therefore, when each party has completed their respective protocol
runs, they know that they agree on each others' identities and on which session
key material has been established.
%
 
When the Initiator is using a static DH key, the session key material is
$g^{xy}$, $g^{Iy}$ and $g^{Rx}$.
%
When sending message 2, the Responder does not know who the Initiator is, so
he cannot perform a computation that depends on the public key $g^{I}$ of the
Initiator and include that in message 2.
%
Specifically, when sending message 2, the Responder does not know $g^{Iy}$, so
he cannot inform the Initiator which value he will use for that part of the
session key and he cannot commit to it.
%
When the Initiator sends message 3 he performs a computation based on $g^I$
(i.e., resulting in $g^{Iy}$), sends this to the Responder and then completes.
%
So when the Initiator completes the protocol run, he has not received any
confirmation from the Responder which session key material they should use,
i.e., they have not agreed on it and hence the Responder has not authenticated
the key material to the Initiator.
%
But: The Initiator knows that \emph{if} his message 3 reaches the Responder
correctly, \emph{then} only if the Responder is $V$, will the Responder have
access to the session key material $g^{xy}, g^{Iy}, g^{Rx}$.
%
Without confirmation from $V$ in the Responder role, the Initiator cannot know
that they actually have agreed on the session key material when he completes
the run.
%
 
This situation does not occur in the OPTLS paper, because Krawczyk is not
taking client authentication into account.
%
Without client authentication in EDHOC, the corresponding session key material
would be only $g^{xy}$, $g^{Rx}$ and both the client/Initiator and
server/Responder have a access to that when processing message 2.
%
 
So, on the top of my head there are three options when the Initiator uses a
static DH-key (unless I missed something above):
\begin{enumerate}
    \item Accept implicit authentication,
    \item Sacrifice Initiator identity protection and include
        \mConstStyle{ID\_CRED\_I} in message 1, and, e.g., include
        \mConstStyle{ID\_CRED\_I} and/or \mConstStyle{CRED\_I}
        in \mConstStyle{TH\_2} or in \mConstStyle{AAD\_2},
    \item Include a fourth confirmation message from Responder to Initiator
        proving to the Initiator that the Responder knows $g^{Iy}$ (a MAC using
        the session key is enough).
\end{enumerate}
% 
\knote{John find 1 acceptable and would also like to use only $g^{xy}$ and
    session key for the STATIC methods. I would prefer not to use only $g^{xy}$,
    because Krawzcyk's proof for OPTLS is based on $g^{Rx}$ and uses $g^{xy}$
    only to get PFS. Note that responder can only compute $g^{Rx}$ if he has
    access to his private key, so the link to $g^{Rx}$ is stronger. However,
    indirectly it affects also the $g^{xy}$ via the \mConstStyle{MAC\_3}, so it
    may be OK still. But, using $g^{xy}$ to protect against session state
    reveal queries in addition to compromise queries revealing $g^{Rx}$ is
    useful with TPMs (c.f., the signature operation using the private key is
    done in the TPM for the SIG-SIG method).
}
There does not seem to be a similar issue with $g^{Rx}$.
%
When receiving message 2, the Initiator verifies \mConstStyle{MAC\_2}, which is
based on a key derived from $g^{Rx}$.
%
The \mConstStyle{MAC\_2} also covers \mConstStyle{CRED\_R} and
\mConstStyle{ID\_CRED\_R}, so the Initiator knows after verifying
\mConstStyle{MAC\_2} that $g^{Rx}$ is known to and coming from $V$.
%
An attacker would have to compute the discrete log of $g^{x}$ from the first
message to be able to forge that MAC.
% 

%-------------------------------------------------------------------------- sub
\subsubsection{Property: Implicit session key authentication}
\label{sec:mail-notes-session-key-imp-auth}
%

For the cases where the Initiator uses a static DH key, we prove implicit
authentication of Responder to initiator:
$$
\forall l. \mConstStyle{accept(l)} ==>
    \forall l'. \mConstStyle{sameKey}(l, l') ==> l'.pid = l.id
$$
which is an adaption from Delpech de Saint Guilheim
et.~al.~\cite{DBLP:journals/iacr/GuilhemFW19}.
%
The term $l.id$ is the identity of $l$, and $l.pid$ is the identity of $l$'s
peer.
%
The Initiator can still be explicitly authenticated to the Responder using
normal running/commit technique.
%



%-------------------------------------------------------------------------- sub
\subsection{Identity privacy}
%
Identity privacy does not apply to the PSK method.
%
For asymmetric methods, identity privacy means hiding \mConstStyle{ID\_CRED} and
\mConstStyle{ID\_CRED\_X}.

%-------------------------------------------------------------------------- sub
\subsubsection{Property identity privacy}
TBD

%-------------------------------------------------------------------------- sec
\section{Primitives}
%-------------------------------------------------------------------------- sub
\section{Encryption}
\label{sec:mail-notes-encr}
%
We model authenticated encryption with additional data (AEAD) in the standard
way.
%
We consider an AEAD transform as a single primitive providing both integrity
protection and encryption.
%

Message 2 is however encrypted using an XOR-pad that is generated using the KDF.
%
Even though the protocol intends for message to to enjoy integrity protection by
means of the signature, we cannot consider the signature in combination with
XOR as a single primitive.
%
We model XOR encryption using \mTamarin's built in xor operation, with one
xor-pad-term for each term in the message.
%
%-------------------------------------------------------------------------- sub
\section{Mixed issues}
%
%-------------------------------------------------------------------------- sub
\subsection{Unclear/underspecified identity handling}
\label{sec:mail-notes-identity}
%
This is a follow-up to my whining about that is unclear what an identity is
for the purpose of EDHOC, and what EDHOC is actually authenticating.
%
Casually, an AKE must guarantee that the session key is established with a
certain identity.
%
That is, a party must authenticate to the other: its identity and that it is
the one who shares the session key (explicitly or implicitly).
%
I think there is a "not-authenticated-whom-I-intended-attack".
%
It is there because:
\begin{itemize}
    \item It is not clear what the intention is with identities and
            authentication.
    \item The spec mixes up the concepts of roles (initiator/responder) and
        identities (parties who acts in a role).
\end{itemize}
%
The Initiator is assumed to know the identity V it is initiating the protocol
run with.
%
One identity V may have more than one \mConstStyle{CRED\_R}.
%
That is, the spec only RECOMMENDs that a one-to-one mapping between
\mConstStyle{CRED\_R}
and identity exists (Section 4.1), so that means the protocol must be secure
also when no one-to-one mapping exists.
%
Section 3.2 of EDHOC states:
\begin{itemize}
    \item Identity when PKI is used: name in certificate
    \item Identity when no PKI: the public key (bound to subject name?)
\end{itemize}

I did not find any text describing that the Initiator verifies that
\mConstStyle{ID\_CRED\_R} matches the intended identity in the responder role.
%
It only describes that the initiator should verify that the identity of the
responder is within an allowed set.
%
The latter is what I asked for earlier, so thanks for that.
%
But it is not enough.
%
Attack:
%
\begin{itemize}
    \item I configure my phone, printer and toaster as allowed set of parties
        to communicate with in my home network.
    \item Assume my phone sends message 1 to the intended responder printer.
    \item My toaster is hacked and replies with a message 2 and its
        own \mConstStyle{ID\_CRED\_R}.
    \item My phone verifies that the \mConstStyle{ID\_CRED\_R} is in the allowed set and
        continues.
    \item EDHOC completes and my phone is securely connected to my toaster,
        but that was not its intention.
\end{itemize}
%
I did not find any text that the Initiator verifies that the identity carried
in the \mConstStyle{ID\_CRED\_R} actually is the intended one.
%
It only describes that the initiator should verify that the identity of the
responder is within an allowed set.
%
The latter is what I asked for earlier, so thanks for that.
%
But it is not enough.
%
Attack:
%
\begin{itemize}
    \item I configure my phone, printer and toaster as allowed set of parties
        to communicate with in my home network.
    \item Assume my phone sends message 1 to the intended responder printer.
    \item My toaster is hacked and replies with a message 2 and its
        own \mConstStyle{ID\_CRED\_R}.
    \item My phone verifies that the \mConstStyle{ID\_CRED\_R} is in the allowed set and
        continues.
    \item EDHOC completes and my phone is securely connected to my toaster,
        but that was not its intention.
\end{itemize}
%
One could argue that the application should have configured the allowed set to
be only \mConstStyle{ID\_CRED\_R}s that matches the printer.
%
But this is not stated in the spec that I found.
%

For the responder role this does not matter, because the responder is reactive
and does not have an intention to communicate with a specific party.
%

Depending on what the intended use cases are for EDHOC I see two options:
\begin{itemize}
    \item The spec says that the allowed set must only contain \mConstStyle{ID\_CRED\_R}s
            that map to the same identity. Or
    \item The spec says that the allowed set may contain \mConstStyle{ID\_CRED\_R}s that map
            to different identities. This may be useful if, for example, I
            have two printers and my phone is OK with connecting to any of
            them. In the latter case, the spec need to state the Initiator
            does not know which identity it is initiating the connection to,
            but that it is connecting to one of the identities in the
            allowed set. This is some kind of anycast.
\end{itemize}
%
Even if the spec uses the strategy to not specify which is the case to
"allow for all possibilities" it needs to explain what to do in each of the
cases.
%
I don't believe leaving it undefined is a good idea.
%

%-------------------------------------------------------------------------- sec
\section{Comparison with existing frameworks}
\label{sec:mail-notes-noise}
It can be seen that the first two messages in the Static-DH mode of EDHOC correspond perfectly to the first two messages of the XX pattern of the NOISE framework. However, in the third message, the XX pattern requires the initiator to send their static key, followed by an encrypted payload using a key derived by a combination of the static key and an ephemeral key. In EDHOC, the static key and the payload are both encrypted in the same key, one depending on the key used for the second message, and on the static key of the initiator. This perhaps diverges from the XX pattern of NOISE, and one can no longer directly claim that EDHOC enjoys the same properties as XX. 
