% !TEX root =  main.tex

Next we describe our approach \vedit{at}{towards} formalizing the \mEdhoc{} protocol. We use the
symbolic (Dolev-Yao) model for verification, \vedit{using}{with} \mTamarin{} for tool support.
%
The next three subsections describe our threat model, briefly present the
\mTamarin{} tool, and our modeling choices.
%
Finally, we present the properties that we \vedit{proved in this effort}{consider and prove}.

\subsection{Threat model}\label{sec:threat-model}
We verify \mEdhoc{} in the symbolic Dolev-Yao model: as customary in this style of
modeling, we assume all cryptographic primitives to be ``perfect'', and hence
only allow the attacker to encrypt and decrypt messages when they know the key,
and exclude \vedit{hash}{all} collisions, for example; the attacker is \vedit{also}{} in control of the
communication channel, and can interact with unbounded sessions of the protocol,
dropping, injecting and modifying messages at their liking.

One important point of the modeling is that we allow the attacker to impersonate
dishonest and/or compromised endpoints, by revealing their long-term and session
key material at any given point.
%
\vedit{On the converse}{Conversely}, we say that a party is honest if they never reveal their
long-term key or session key material.

\kedit{Another important point is to define what the key material is.
    \mEdhoc{} does not result in an explicit session key, but a cryptographic
    state from which keys for \mOscore can be derived using \mHkdf.
    As will be seen below, depending on how the key material is defined, the
    different methods will have different authentication properties.
    In particular, all methods except those where the initiator uses the
    \mStat{} method provide a stronger form of authentication (injective
    agreement) for the initator.
}

\subsection{Desired Properties}
\label{sec:desired-properties}
Next we list the properties that will be considered during verification.

\paragraph{Secrecy}
We say that \vedit{a}{} \mEdhoc{} satisfies secrecy of the established session key $sk$
between two honest parties $A$ and $B$ if, for any run of the protocol $A$ and
$B$, the attacker does not get to know $sk$.
%
The attacker may passively observe---and actively interfere with---the
communication, and run any number of sessions with $A$ and $B$, in either role,
concurrently or otherwise.

\paragraph{Authentication}
To define \mEdhoc{}'s authentication properties we make use of Lowe's definition
of \emph{injective agreement}~\cite{DBLP:conf/csfw/Lowe97a}:
\begin{quote}
  ``We say that a protocol guarantees to an initiator $A$ [injective] agreement
  with a responder $B$ on a set of data items $ds$ if, whenever $A$ (acting as
  initiator) completes a run of the protocol, apparently with responder $B$,
  then $B$ has previously been running the protocol, apparently with $A$, and
  $B$ was acting as responder in his run, and the two agents agreed on the data
  values corresponding to all the variables in $ds$, and each such run of $A$
  corresponds to a unique run of $B$.''
\end{quote}

Different \mEdhoc{} methods offer different levels of authentication, namely
\emph{explicit authentication} and \emph{implicit authentication}.
\knote{I think we should try to make a point out of this. It was something we
    discovered during the modeling. The way this sentence is written, it sounds
    as if that it was a design choice that we just verified. We could treat it
    as a discovery and get bonus points :-)
}
We say that \mEdhoc{} in method $m$ satisfies \emph{explicit authentication} for
the initiator $A$ with a responder $B$, if injective agreement holds for $A$
with $B$ on the session key $sk$, when running method $m$.

Explicit authentication requires that both parties agree on the session key
\emph{at the end of a protocol run}.
%
This, however, does not hold for all \mEdhoc{} methods, in which cases we prove
\emph{implicit authentication} as defined
in~\cite{DBLP:journals/iacr/GuilhemFW19}.
%
In a nutshell, a protocol satisfies \emph{implicit authentication} if the
initiator and responder agree on the session key \emph{only after} a successful
execution of the protocol.
%
That is, authentication happens only implicitely, as there is no confirmation to
the initiator that the responder has computed the same session key.
%
More precisely, we adapt the definition of~\cite{DBLP:journals/iacr/GuilhemFW19}
to the symbolic model, and we prove that if an initiator $A$ and a responder $B$
complete the protocol deriving the same session key, then $A$ believes she is
talking to $B$ and $B$ believes \vedit{he's}{he is} talking to $A$.

\paragraph{Session independence}
A protocol satisfies session independence if \vedit{the knowledge of}{knowing} a session key does
not give the attacker any information about other sessions.  To model session
key independence of \mEdhoc, we allow leakage of session keys, and additionally
check security only of those sessions for which the session keys have not been
directly revealed to the attacker.

\paragraph{Perfect forward secrecy} (PFS) A protocol satisfies perfect forward
secrecy if, for any run of the protocol in which the initiator and the responder
agree on a session key $sk$, the attacker does not learn $sk$, even when the
long-term keys are revealed after the session is completed.

\paragraph{Key-compromise impersonation} (KCI) \vedit{}{This property} takes the perspective of one
of the endpoints of the protocol, say Alice running a session with Bob. A
protocol is secure under KCI if Alice can still establish a secure session with
Bob, even though Alice's keys are compromised at any time, and Bob's key
material is not leaked until the end of the session.

\paragraph{Post-compromise security} (PCS) A protocol that has
\emph{post-compromise security} (following definitions in~\cite{cohn2016post})
is capable of establishing a secure session even after one of the parties has
been compromised. Cohn-Cordon et al.~\cite{cohn2016post} presents two notions of
PCS, namely weak and strong PCS: here we focus on the latter.
%
A protocol guarantees \emph{weak PCS} if secrecy of any session key $sk$ holds
between the initiator and the responder, even if the run of the protocol that
established $sk$ happens after a \emph{limited compromise}, where the key
material is not leaked, but the attacker is capable of impersonating both
parties (i.e. has the ability to perform all cryptographic operations using the
initiator's and responder's long term keys, but has not access to the long term
keys).

\vnote{If we are focussing on strong PCS, it deserves a definition of its own. Also, why are we defining weak PCS if we do not talk about it here and don't even contrast it against strong PCS?}

\vnote{A minor note about style: It might be better to actually have each property be a subsubsection rather than a paragraph. That also typesets the ``headings'' neatly, unlike right now, where the parenthesized KCI and PCS appear in upright text, while the rest of the name is italicized.}

\subsection{Tamarin}
We chose \mTamarin{} to model and verify \mEdhoc{} \vedit{in the Symbolic model}{}.
%
\mTamarin{} is an interactive verification tool based on multi-set rewriting rules
with event annotations, which allows \vedit{}{the user} to check LTL temporal formulas on these
models.
%
Multi-set rewrite rules with events take the form:
%
\[ l \ifarrow[e] r \]
%
where $l$ and $r$ are multi-sets of facts, and $e$ is a multi-set of events.
%
Facts are \vedit{$n$ary}{$n$-ary} predicates over a term algebra, which defines a set of function
symbols $\mathcal F$, variables $\mathcal V$ and names $\mathcal N$. \mTamarin{}
checks equality of \vedit{thse}{these} terms under an equational theory $E$\vedit{, hence}{. For example,} one can
write \vedit{that}{}
%
\[ dec(enc(x,y),y) =_E x \]
%
to denote that symmetric decryption reverses the encryption operation \vedit{}{under this theory}\vedit{, and so
forth}{}. All operations on terms are defined under $E$, hence we omit the
subscript from now on as the equational theory is fixed per model.

\paragraph{Semantics and built-ins} \phantom{} \vedit{On a first approximation,}{} \mTamarin{} states
$S$, $S'$ are multisets of facts, and a semantic transition $S \semarrow[E] S'$
occurs if there is a rule $l \ifarrow[e] r$ and a substitution $\sigma$ such
that $S \supseteq \sigma(l)$ and $S' = S \setminus \sigma(l) \uplus \sigma(r)$
and $E = \sigma(e)$.

There are a few more details, such as persistent facts that are denoted by a $!$
and are never removed from the state.
%
The sorts fresh (denoted by $\sim$) and public (denoted by $\$$) denote fresh
constants and public values known to the attacker respectively, and are both
sub-sorts of a base sort. \vnote{Could put the sort names in the typing convention used for the code.}
%
Finally, \mTamarin{} has some built-in predicates ($\mIn,
\mOut$ to represent input and output of messages with the attacker,
and
$\mFr$ to denote a fresh constant created in the current rule, among
others), rules and equations that represent the attacker's knowledge
and standard equational theories in the symbolic model, \vedit{plus syntactic
sugar,}{} which we present later.

\paragraph{Notational conventions} In the remainder of this section we present
\mTamarin{} code as it appears in the models that we verify, in the style of
literate programming.  Whenever possible we match the style of the protocol
diagrams in Section~\ref{sec:edhoc} and the naming convention of the \mEdhoc{}
\vedit{draft}{\mSpec}~\cite{selander-lake-edhoc-01}, so that each element of the model is
traceable to the standard.  There are a few exceptions to this, most notably
some variable names that we introduce for the sake of the specification and are
not present in the original document, which will appear in \mT{camelCase}, and
the syntax for Diffie-Hellman exponentiation which is specific to \mTamarin{}.
\vnote{``for the sake of the specification'': Since so far we are referring to the Edhoc document as the specification, maybe use a different word here? I'm not quite sure what you mean here, so I'm not adding an edit.}

We also use \mT{xx} to name the ephemeral key for the initiator (resp. \mT{yy}
for the responder) as to avoid confusion with \mTamarin's builtin variable
names \mT{x} and \mT{y}.

\paragraph{Protocol rules and equations}
\vnote{Needs an introductory sentence before jumping into an example}
For example \vedit{}{,} in our model we have a symbol to denote authenticated encryption and
hence \mTamarin{} produces the rule:
%
\begin{lstlisting}
[ !KU(k), !KU(m), !KU(ad), !KU(al) ] --[]-> [ !KU(aeadEncrypt(k, m, ad, al)) ]
\end{lstlisting}
%
to denote that if the attacker knows a key \mT{k}, a message \mT{m}, the
authenticated data \mT{ad}, and an algorithm \mT{al}, then they can construct
the encryption using these parameters, hence get to know the message
\lstinline{aeadEncrypt(k, m, ad, al)}.

In our model we introduce a theory for authenticated encryption, plus the
built-in theories of XOR and Diffie-Hellmann.
%
Authenticated encryption, which is encryption with authentication data as
detailed in~\cite{aead}, has the following two equations:
\begin{lstlisting}
  aeadDecrypt(k, aeadEncrypt(k, m, ad, al), ad, al) = m
  decrypt(k, aeadEncrypt(k, m, ad, al), al) = m
\end{lstlisting}
With the first rule we allow the protocol to decrypt the message \mT{m} if the
encryption has matching key \mT{k}, authenticated data \mT{ad}, and uses the
same algorithm \mT{al}.
%
The second rule allows the attacker to decrypt the message \mT{m} with the key
\mT{k} and without the authenticated data \mT{ad}, and hence skip the check.

The built-in theories for XOR and Diffie-Hellman are a fair bit more complex
than authenticated encryption, hence we refer to the original
papers~\cite{xorTamarin,dhTamarin}  for a full reference. \vnote{Fix citations}
%
Suffices to say that the XOR theory introduces the symbol \mT{XOR}, for
expressing XOR operations \mT{x XOR y}, plus the necessary equational theory
including associativity, commutativity, and inverse.
%
The theory for Diffie-Hellman introduces exponentiation \mT{g^y} and product
\mT{x * y} as a built-in symbols in the language, plus the necessary equational
theory of associativity, commutativity, distributivity of exponentiation with
product, and inverse.

\vnote{Spacing is weird throughout for the code snippets. Especially in this x XOR y above. Please check.}

\paragraph{Syntactic sugar} In the following presentation we use some syntactic
sugar, which is necessary to understand to look at the concrete rules. First is
the use of let bindings (\mT{let ... in}), which are series of
definitions of patterns which are substituted in the rest of the rule. Another
prominent feature is the use of tuples (\mT{<t1, ..., tn>}) which are a
built-in concept in \mTamarin.

\subsection{Modeling \mEdhoc{}}
In this section we detail the modeling choices that we have made for this formal
verification effort.

We model the five different methods of \mEdhoc{} from a single specification
that derives all valid combinations: \mPskPsk, \mSigSig, \mSigStat, \mStatSig{}
and \mStatStat.
%
We use the M4 macro language to derive these different methods from a single
description of the protocol, thus enforcing uniformity in the presentation.
%
Other parameters to the model include the optional data of the \mEdhoc{}
specification, that is, the connection identifiers \mCi{} and \mCr{}, and
the authenticated data \mADone, \mADtwo{} and \mADthree.
%
To keep the presentation brief, we \vedit{detail only the setup of the model,
the symmetric and one asymmetric variant}{only present two variants, where one party uses a signature key and the other a static DH key} (\mSigStat{} and \mStatSig)\vedit{, h}{. H}owever the full
code can be inspected at
\url{https://github.com/hoheinzollern/EDHOC-Verification}.

\vnote{Fix the link to link to the exact folder for the current version -- this page contains the old code too.}

% - Explain details of model, which properties we have modeled, how,
% which trade-offs were made and why.

\paragraph{General setup}
\begin{lstlisting}
rule registerLTK_SIG:
 [Fr(~ltk)] --[UniqLTK($A, ~ltk)]->
  [!LTK_SIG($A, ~ltk), !PK_SIG($A, pk(~ltk)), Out(<!<$A, pk(~ltk)>!>)]
rule registerLTK_STAT:
 [Fr(~ltk)] --[UniqLTK($A, 'g'^~ltk)]->
  [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]
rule registerLTK_PSK:
 [Fr(~ltk)] --[UniqLTK(<$A, $B>, ~ltk)]-> [!LTK_PSK(<$A, $B>, ~ltk)]
\end{lstlisting}
    
These three rules express the registering of the long term keys for the \mSig,
\mStat{} and \mPsk{} methods respectively.
%
\vedit{The}{} \mT{registerLTK_PSK} registers a symmetric key for each pair of
agents \mT{A} and \mT{B}, while the other two rules register a
public key (for signing and encrypting, respectively) that are tied to the
\vedit{identities}{identity} of \vedit{one}{an} agent \mT{A}.
%
The event \mT{UniqLTK} marks that the long term key is unique for each
agent or pair of agents, as enforced by the following restriction:
\begin{lstlisting}
restriction uniqLTKs:
    "All id k1 k2 #i #j. (UniqLTK(id, k1)@i & UniqLTK(id, k2)@j) ==> k1 = k2"
\end{lstlisting}
\kedit{}This models that there is an external mechanism ensuring that the
long term keys are bound to the correct identity, e.g., a certificate authority,
and that the attacker cannot register new public keys for an existing identity.}

Long term keys are revealed to the attacker through specific rules
with the event \mT{LTKRev}.
\begin{lstlisting}
rule revealLTK_SIG:
  [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT:
  [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_PSK:
  [!LTK_PSK(<$A, $B>, ~ltk)] --[LTKRev(<$A, $B>)]-> [Out(~ltk)]
\end{lstlisting}
\vedit{these}{These} rules are used to check the different lemmas for authentication
and key secrecy, as we limit when the attacker is able to reveal the
keys to prove forward secrecy, as discussed in
Section~\ref{sec:threat-model}.
%
Each of the session keys is also revealed with similar rules,
depending on the method to check session independence.

\paragraph{\mPskPsk{}} \vedit{the}{The} following rules model the symmetric \vedit{key} variant of
the protocol and are derived from the M4 file, as presented in
Section~\ref{protocol-presentation}\footnote{link}.
\vnote{Broken link? Or TBD?}

First we present the rule \mT{I1_PSK_PSK}, which corresponds to the
Initiator starting a session:
\begin{lstlisting}
rule I1_PSK_PSK:
  let gx = 'g'^~xx
      ID_PSK = <$U, $V>
      m1 = <'PSK', 'PSK', $cSUITE0, gx, ID_PSK> 
  in
  [ !LTK_PSK(<$U, $V>, ~ltk), Fr(~xx), Fr(~tid) ]
  --[ I1(~tid, $U, $V, m1) ]->
  [ StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid), Out(m1)]
\end{lstlisting}

This rule uses the persistent predicate \mT{!LTK_PSK} to retrieve the long-term
symmetric key for the two parties U (the initiator) and V (the responder).  The
two predicates \mT{Fr(~xx)} and \mT{Fr(~tid)} denote the creation of a fresh
ephemeral key and a fresh session identifier.  Message 1 is then constructed as
a tuple in the let binder following the specification.

It is worth noting that there are some differences in the way \mT{m1} is
constructed when compared to the specification. In particular, the \emph{method}
field is divided into two fields representing the method for the initiator and
the responder, the connection identifier is omitted and the ciphersuite\vedit{s}{} is
represented by the public variable
\mT{$cSUITES0} (known to the attacker). We plan to introduce the connection
identifier \mCi in our ongoing verification effort, whereas the other two are
modeling choices that do not affect the behaviour of the model.

Finally, we use the fact \mT{StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid)} %
to save the internal state for the remainder of the initiator's protocol.

The next rule models the responder receiving \mT{m1} from the initiator,
constructing the Diffie-Hellman shared secret $g^{xy}$ and preparing \mT{m_2}.
\begin{lstlisting}
rule R2_PSK_PSK:
  let
    data_2 = <'g'^~yy>
    ID_PSK = <$U, $V>
    m1 = <'PSK', 'PSK', $cSUITE0, gx, ID_PSK>
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract(~ltk, gx^~yy)
    prk_3e2m = prk_2e
    extAad2 = TH_2
    plainText2 = 'emptyStr'
    K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
    CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)
    m2 = <data_2, CIPHERTEXT_2>
  in
    [ !LTK_PSK(<$U, $V>, ~ltk), In(m1), Fr(~yy), Fr(~tid) ]
    --[ ExpRunningR(~tid, $V, exp_sk)
      , R2(~tid, $V, m1, m2) ]->
    [ StR2_PSK_PSK($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2), Out(m2) ]
\end{lstlisting}

Here we obtain as input message 1 (\mT{m1}), create a fresh exponent \mT{yy} and
session identifier \mT{tid}.  The let bindings in this rule show how to
construct message \mT{m2}.  They can be easily mapped to the diagram in
Figure~\ref{fig:edhocpsk}.  We use the public constant \mT{'emptyStr'} instead
of an empty string since \mTamarin{} has no concept of strings (single quotes
denote constants).
\vnote{The macro \mT turns the open quote mark in 'emptyStr' into an orphan. Check about splitting across lines.}

Here we notice the introduction of the event \mT{ExpRunningR(~tid, $V, exp_sk)}
% 
which we \vedit{}{will} later use to show explicit authentication (hence the \vedit{exp}{\mT{Exp}} prefix) by
finding an injective correspondence between two events.

The next rule models the initiator receiving \mT{m2} and responding with the
final message \mT{m3}:
\begin{lstlisting}
rule I3_PSK_PSK:
  let
    data_2 = <gy> 
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract(~ltk, gy^~xx)
    prk_3e2m = prk_2e
    plainText2 = 'emptyStr' 
    extAad2 = TH_2
    K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
    CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)
    m2 = <data_2, CIPHERTEXT_2>
    data_3 = 'emptyStr' 
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    extAad3 = TH_3
    plainText3 = 'emptyStr'
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gy^~xx>
    imp_sk =  exp_sk
  in
  [ StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid), In(m2) ]
  --[ ExpCommitI(~tid, $U, $V, exp_sk)
    , CommitI(~tid, $U, $V, imp_sk)
    , I3(~tid, $U, $V, m1, m2, m3) ]->
   [ Out(m3) ]
\end{lstlisting}

Apart from observations similar to those already made for the previous messages,
we should mention here the two events %
\mT{ExpCommitI(~tid, $U, $V, exp_sk)} and \mT{CommitI(~tid, $U, $V, imp_sk)}. %
These events mark the completion of the protocol for the initiator, \vedit{which}{and} will
be used \vedit{for later}{later for} verifying explicit and implicit authentication, respectively.
The difference is the choice of key material on which we check authentication
(\mT{exp_sk} vs \mT{imp_sk})\vedit{, which in the case for the symmetric method is
null, but that will be crucial when the initiator runs the \mStat{} method.}{. In the case of the \mSig{} method, as above, these keys are the same, but there will be a crucial difference when the initiator runs the \mStat{} method.}
\anote{I found a discrepacy for cHash0, should use the public constant and not
  the nullary function!}
  \knote{ I fixed it in the code. How do you want to deal with code changes now?
      Should we treat the code inlined here in the papers as imported and hence
      needs to be pateched as well, or do you plan to bring in the sources from
      the TMP-files again?
  }
  \knote{In the spthy code I used Haskell-style indentation. Now
      that the font in the paper is no longer fixed width, that just looks plain
      ugly. If the current style of the listings is the one that we will use in
      the end, bringing the commas in lists from the front of a line to the end
      of the previous line would probably look better.
  }

Finally, we have the last rule for the responder:
\begin{lstlisting}
rule R4_PSK_PSK:
  let
    data_3 = 'emptyStr' 
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    extAad3 = TH_3
    plainText3 = 'emptyStr'
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gxy>
    imp_sk =  exp_sk
  in
  [ StR2_PSK_PSK($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2), In(m3) ]
  --[ ExpCommitR(~tid, $U, $V, exp_sk)
    , CommitR(~tid, $U, $V, imp_sk)
    , R4(~tid, $U, $V, m1, m2, m3) ]->
  []
\end{lstlisting}

This rule receives message 3, checks \vedit{against its local state}{} that the
Diffie-Hellman key $g^{xy}$ corresponds \vedit{with its local state}, then terminates the protocol.  As in
the previous message, we mark acceptance of the third message from the responder
with the two commit events, and conclude.

\vnote{If you are going with \mPskPsk for the first example, it would make sense to explain it in some detail. At least a connection to the earlier section describing the variables in the code is necessary, because so far there is no mention of $U$, $V$ etc. If you directly jump to the events, a casual reader has no idea what the variables even correspond to. Once these things are explained here, they need not be repeated for the next method.}
\anote{should be addressed now}

\paragraph{\mStatSig{}}
Next we present the mixed asymmetric method \mStatSig. We chose \mStatSig{} for
this presentation of the asymmetric methods as this configuration shows all
interesting features at once: mixed authentication methods, and implicit
authentication on the responder.

\begin{lstlisting}
rule I1_STAT_SIG:
  let gx = 'g'^~xx
      m1 = <'STAT', 'SIG', $cSUITE0, gx> 
  in
  [ !LTK_STAT($U, ~ltk), Fr(~xx), Fr(~tid) ]
  --[ I1(~tid, $U, $V, m1) ]->
  [ StI1_STAT_SIG($U, ~ltk, $V, ~xx, m1, ~tid) 
  , Out(m1)]
\end{lstlisting}
Like in the previous model, this rule starts the initiator and outputs the first
message \mT{m1}, this time looking up the public key for \mT{U} and using the
\mStatSig{} method.

Next we look at the rule for the responder:
\begin{lstlisting}
rule R2_STAT_SIG:
  let
    data_2 = <'g'^~yy>
    m1 = <'STAT', 'SIG', $cSUITE0, gx> 
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract('emptyStr', gx^~yy)
    prk_3e2m = prk_2e
    K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
    protected2 = $V // ID_CRED_V
    CRED_V = pkV
    extAad2 = <TH_2, CRED_V> 
    assocData2 = <protected2, extAad2>
    MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
    authV = sign(<assocData2, MAC_2>, ~ltk)
    plainText2 = <$V, authV>
    K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
    K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
    K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
    CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2> 
    m2 = <data_2, CIPHERTEXT_2>
    exp_sk = <gx^~yy>
  in
  [ !LTK_SIG($V, ~ltk), !PK_SIG($V, pkV)
  , In(m1), Fr(~yy), Fr(~tid) ]
  --[ ExpRunningR(~tid, $V, exp_sk), R2(~tid, $V, m1, m2) ]->
  [ StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) 
  , Out(m2) ]
\end{lstlisting}
Here is a place where the model and the original specification differ
slightly, the reason being that we must allow some behaviour that is
otherwise not covered by\vedit{}{the }symbolic handling of XOR encryption\vedit{:}{.} It must
be possible for the attacker to break apart the fields of
\mT{CIPHERTEXT_2}, and obtain part of the key \mT{K_2e}
if they know part of the plaintext, or viceversa.
%
Hence \mT{CIPHERTEXT_2} is not a direct XOR ``encryption'', but rather a tuple
where each field is XORed with a half-key expansion (\mT{K_2e_1} and
\mT{K_2e_2}).  Notice also the lack of \mT{exp_sk}, as the semi-static
Diffie-Hellman key $g^{iy}$ cannot be computed by the responder at this stage.

\vnote{Check that `semi-static' is consistent terminology throughout.}

Next we have the second rule for the initiator:
\begin{lstlisting}
rule I3_STAT_SIG:
  let
    data_2 = <gy> 
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract('emptyStr', gy^~xx)
    plainText2 = <$V, authR> 
    CRED_V = pkV
    prk_3e2m = prk_2e
    K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
    K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
    CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2> 
    m2 = <data_2, CIPHERTEXT_2>
    K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
    protected2 = $V // ID_CRED_V
    extAad2 = <TH_2, CRED_V> 
    assocData2 = <protected2, extAad2>
    MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
    data_3 = 'emptyStr' 
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    giy = gy^~ltk
    prk_4x3m = hkdfExtract(prk_3e2m, giy)
    K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
    protected3 = $U // ID_CRED_U
    CRED_U = pkU
    extAad3 = <TH_3, CRED_U>
    assocData3 = <protected3, extAad3>
    MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
    authU = MAC_3
    plainText3 = <$U, authU>
    extAad3Outer = TH_3
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gy^~xx>
    imp_sk = <exp_sk, giy>
  in
  [ StI1_STAT_SIG($U, ~ltk, $V, ~xx, m1, ~tid) 
  , !PK_SIG($V, pkV)
  , !PK_STAT($U, pkU)
  , In(m2) ]
  --[ ExpCommitI(~tid, $U, $V, exp_sk), CommitI(~tid, $U, $V, imp_sk)
  , I3(~tid, $U, $V, m1, m2, m3)
  , Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true) ]->
  [ Out(m3) ]
\end{lstlisting}
Here is a crucial difference that follows from our last observation: we notice
the addition of the semi-static Diffie-Hellman key to the term \mT{imp_sk}.
This will be used later to check implicit authentication, as is reflected by the
commit events.

\begin{lstlisting}
rule R4_STAT_SIG:
  let
    data_3 = 'emptyStr'
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    CRED_U = pkU
    extAad3 = TH_3
    plainText3 = <$U, authI>
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
    giy = CRED_U^~yy
    prk_4x3m = hkdfExtract(prk_3e2m, giy)
    K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
    protected3 = $U // ID_CRED_U
    extAad3 = <TH_3, CRED_U>
    assocData3 = <protected3, extAad3>
    MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gxy>
    imp_sk = <exp_sk, giy>
  in
  [ StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) 
  , !PK_STAT($U, pkU)
  , !PK_SIG($V, pkV)
  , In(m3) ]
  --[ ExpCommitR(~tid, $U, $V, exp_sk)
  , CommitR(~tid, $U, $V, imp_sk)
  , R4(~tid, $U, $V, m1, m2, m3)
  , Eq(authI, MAC_3) ]->
  []
\end{lstlisting}


% Let us focus on the interesting details of this model. First and
% foremost, it shows how to construct signatures in the static method and
% the signing method.
% %
% Looking at \mT{authU} how it is constructed in rule \mT{I3_STAT_SIG}, we can see
% that it uses \mT{K_3m}, which is an expansion of \mT{prk_4x3m} that in turn uses
% the semi-static Diffie-Hellman key \mGiy.
% %
\knote{Terminology: we need to harmonize terminology in the end. Here it is
  called semi statc DH key. Sometimes this is referred to as a "DH key share"
  and sometimes as a "DH half key". I don't care so much which we chose as long
  as it is consitent.  }
%
\anote{semi static DH key carries the notion that part of the key is long term
  and the other part is ephemeral. shall we keep this distinction? otherwise the
  rest should harmonize to the same notation (the text is removed)}
%
\footnote{\anote{I kept this out of the main text as it's covered already, however it might be useful to discuss implicit authentication in relation to OSCORE as future work, to be put in the discussion section}
On the same rule we can also see how \emph{implicit authentication}
differs from explicit authentication for the Initiator running the
static method: on \mT{imp_sk} the semi-static key
\mGiy{} is present, whereas \mT{exp_sk} does not include it
for injective agreement.
%
The reason for this is that, when sending message 2, the responder
does not yet know the identity of the initiator, hence an active
attacker can interfere with the protocol in such a way that the two
parties do not agree on the semi-static key
\mGiy{} until after the end of the protocol, when the responder
starts using the derived key material with the initiator.
%
This is outside the scope of the \mEdhoc{} protocol, hence we have left
this part out of the modeling and only focus on the key material that
both parties agree on.
%
In future work, it will be interesting to see the interaction of
\mEdhoc{} with \mOscore\vedit{, which is a transport standard that}{which} can use
\mEdhoc's keys.}

\vnote{You use the terms `initiator' and `responder' sometimes with the first letter capitalized and sometimes without. Stick to one uniform presentation.}

Looking at \mT{authV} in rule \mT{R2_STAT_SIG} we can
see how the signature \vedit{method}{message} is constructed: it is a signature of the
transcript including message 2, using the Responder's long term public
key.
%
Here lies \vedit{the main difference}{one of the two main differences} between the static and signature methods
in the model, the other being the corresponding authentication check\vedit{: a}{. A} simple matching of the MAC tag on the initiator side \vedit{}{suffices}
%
(\mT{Eq(authI, MAC_3)}), instead of verifying the public key
signature on the responder side
%
(\mT{Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)}).

The event \mT{Eq} has no special meaning in \mTamarin{}, but we use it to check
that the two arguments are equal by introducing the following restriction:
\begin{lstlisting}
restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"
\end{lstlisting}

\knote{We earlier agreed to use the macros for the constants in the model to get
    a consistent formatting and save time in the end, not having to go through
    everything and align formatting.
    Here a different format is used: lstinline.  Up until here in this section
    I have changed all the places where we have macros for the terms. But
    since I now noticed that you started usnig a different formatting, I ask you
    to please select the formatting you prefer, encode that into the macros and
    use them. Alternateively, please go through the rest of the paper and change
    the formatting to the new listinline format. I prefer to stick to the
    agreement we made and have followed in the rest of the sections, i.e.,
    the former.
}
%
\anote{I tried to be consistent and use lstinline (now mT) when referring to the
  code, and the macros otherwise, but maybe something slipped me. when I use it
  is because I really intend to point to the code, and when I don't I should use
  the macros}
% - Explain how we modeled inj-agree (a sentence or two).
% - Explain why it fails when $I$ uses \mStat-method and the implicit
% auth lemma we showed instead
% (cite~\cite{DBLP:journals/iacr/GuilhemFW19} here where I got the
% basic idea. It is then extended with the reveal queries in our
% model; obviously: if you know about other sources for this please
% cite them too). Include code/lemmas as you see fit.


\subsection{Properties}
\label{sec:properties}

In this section we present the properties that we have shown for \mEdhoc, and
show the lemmas that verify them. We refer to
Section~\ref{sec:desired-properties} for a full explanation of the properties
that we check. Here we focus on their formalization into \mTamarin{} lemmas.

\subsubsection{Explicit authentication}

We model explicit authentication between the the initiator and the
responder.
%
For this lemma, we use the events \mT{ExpCommitI} and
\mT{ExpRunningR}, and show that there is injective agreement
between the two events on the parameters \mT{tidI},
\mT{v} and the session key material \mT{expSk} (note
that the session key material changes between the different \mEdhoc{}
methods).

Additionally, we require that injective agreement must hold only when
no long term key material for the two parties has been revealed before
the end of the protocol.
%
This is achieved by the main disjunction in lines 5-10 on the right of
the implication, requiring to reveal the long term keys (i.e. one of
the three \mT{LtkRev} events must trigger) if the responder has
not been running a matching session with the initiator.

\begin{lstlisting}
lemma authInjAgreeGuaranteeForI:
  all-traces
  "All tidI u v expSk #i.
     ExpCommitI(tidI, u, v, expSk)@i ==>
     ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
       & not( Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2
        & not(#i = #i2) ) )
     | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
     | (Ex #j. LTKRev(u)@j & #j < #i)
     | (Ex #j. LTKRev(v)@j & #j < #i) )"
\end{lstlisting}
\anote{as this is a disjunction and the symmetric LTKRev happens only
  in the symmetric model and viceversa, this property is equivalent to
  the two properties for the sym and asym cases, so I put this for brevity}
\knote{That is logically true, but \mTamarin{} does not accept it. Try it out to see what
goes wrong. If you have proposals for better ways of modeling it, I'd love to
know.}
\anote{I made the change and it's not complaining for me}

Note that this property \emph{does not hold when} the initiator is
running the \mStat{} method.
%
For that case we need to prove implicit authentication, as detailed in
the next section.

Similarly to the previous lemma, we require that injective agreement also holds
in the reverse direction:

\begin{lstlisting}
lemma authInjAgreeGuaranteeForR:
  all-traces
  "All tidR u v sk #i.
     CommitR(tidR, u, v, sk)@i ==>
     ( ( (Ex tidI #j. CommitI(tidI, u, v, sk)@j & #j < #i)
       & not( Ex tidR2 u2 v2 #i2. CommitR(tidR2, u2, v2, sk)@i2
        & not(#i = #i2) ) )
     | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
     | (Ex #j. LTKRev(u)@j & #j < #i)
     | (Ex #j. LTKRev(v)@j & #j < #i) ) "
\end{lstlisting}

As the explicit and implicit authentication always correspond for the
responder authenticating with the initiator, here we do not need the
additional \mT{Exp} prefix to the running and commit events
(\mT{CommitI} and \mT{CommitR} respectively).
\anote{it would be nice to actually call CommitI -> RunningI for clarity}
\knote{I have added that now}

\subsubsection{Implicit authentication}

The following lemma proves implicit authentication:
\begin{lstlisting}
lemma authGIYImplicitAuthGuaranteeForI2:
  all-traces
  "All tidI u v impSk #i.
     CommitI(tidI, u, v, impSk)@i ==>
     ( (All tidR u2 v2 #j. CommitR(tidR, u2, v2, impSk)@j ==>
       (u = u2 & v = v2 & All tidR2 u3 v3 #j2.
	    CommitR(tidR2, u3, v3, impSk)@j2 ==> #j = #j2)
       & (not Ex #k. K(impSk)@k) )
     | (Ex #k. LTKRev(u)@k)
     | (Ex #k. LTKRev(v)@k)
     | (Ex #k. LTKRev(<u, v>)@k)
     )
  "
\end{lstlisting}
\anote{this is the reformulated implicit authentication turned into a positive implication (almost no negation). All models are verified and it saves 5 minutes in verification time on my machine}
\begin{lstlisting}
lemma authGIYImplicitAuthGuaranteeForI:
  all-traces
  "All tidI u v impSk #i.
     CommitI(tidI, u, v, impSk)@i ==>
     ( ( (All tidR u2 v2 #j. CommitR(tidR, u2, v2, impSk)@j ==> (u = u2  &  v = v2) )
       & (not Ex #k. K(impSk)@k)
       & (not( Ex tidR u v #j tidR2 u2 v2 #j2.
            ( CommitR(tidR,  u,  v,  impSk)@j
            & CommitR(tidR2, u2, v2, impSk)@j2
            & not(#j = #j2)
            ) ) )
       )
     | (Ex #k. LTKRev(u)@k)
     | (Ex #k. LTKRev(v)@k)
     | (Ex #k. LTKRev(<u, v>)@k) ) "
\end{lstlisting}

As opposed to lemma \mT{authInjAgreeGuaranteeForI}, here we prove that the two
parties implicitely authenticate on the keys \mT{impSk}. %
In this lemma we show that if any two parties (\mT{u} and \mT{v2} here) complete
a run of the protocol, and \mT{u} believes she is talking to \mT{v} and \mT{v2}
believes he is talking to \mT{u2}, then their identities match (that is, %
\mT{u = u2} and \mT{v = v2}). Furthermore there is an injective correspondence
between the \mT{CommitI} and \mT{CommitR} events, and the attacker does not
learn the session key material.

\subsubsection{Secrecy, Forward Secrecy and Session Key Independence}

Finally, we prove secrecy of session keys, perfect forward secrecy
(PFS) and session key independence. \vnote{Here is the perfect place to add the section about PCS, session independence etc.}
%
All these properties are validated by a unique lemma for each method,
as secrecy is a strictly weaker property than PFS (\vedit{}{and} hence \vedit{it}{} follows
directly), and session key independence can be proven along PFS.
%
This is done by allowing the revelation of long term keys after either
the initiator or the responder have completed the protocol, and by
allowing to reveal the session keys.
%
It still holds that the session keys are secret for all the other runs
of the protocol.

First we show the lemma for the symmetric method:
\begin{lstlisting}
lemma secrecyPFSGIYSessionKey:
  all-traces
  "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) ) &
   (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) )"
\end{lstlisting}

Next we present the lemma for the asymmetric methods:
\begin{lstlisting}
lemma secrecyPFSGIYSessionKey:
  all-traces
  "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j)
     | (Ex #l. SKRev(sk)@l)) ) &
   (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j)
     | (Ex #l. SKRev(sk)@l)) )"
\end{lstlisting}

% holds no matter which method user chooses.
%  -  PFS on session key for all methods.
%  -  Key secrecy (follows from PFS).
%  -  Session key independence (follows from how we modeled PFS).

% TODO: some statics of running time code size perhaps.
% TODO: Scan draft-selander and check what props are claimed there; see
% what we have covered and what we haven't.

%  -  Entity authentication - we show this in the same lemmas as we show
%     inj-agree on session key.  We don't have this property when $I$ uses
%     STAT method because $I$ then gets no confirmation of
%     Pre-specified peer model.
%  -  Key confirmation (except for when $I$ uses \mStat
%     method, then $I$ gets no key confirmation on \mGiy)

% See~\ref{sec:mail-notes-encr} for how encryption is modeled.
% \item Caveat: we have not modeled running all methods in parallel,
% so we don't know if an adversary can somehow trick $I$ into
% running one method and $R$ another, and by that causing some
% attack.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
