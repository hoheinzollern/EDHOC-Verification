% !TEX root =  main.tex
\fillhack
Next we describe our approach towards formalizing the \mEdhoc{} protocol. We use the
symbolic (Dolev-Yao) model for verification, with \mTamarin{} for tool support.
%
The next three subsections describe our threat model, briefly present the
\mTamarin{} tool, and our modeling choices.
%
Finally, we present the properties that we proved in this effort.

\spacehack
\subsection{Threat model}\label{sec:threat-model}
\fillhack
We verify \mEdhoc{} in the symbolic Dolev-Yao model: as customary in this style of
modeling, we assume all cryptographic primitives to be ``perfect'', and hence
only allow the attacker to encrypt and decrypt messages when they know the key,
and exclude hash collisions, for example; the attacker is in control of the
communication channel, and can interact with unbounded sessions of the protocol,
dropping, injecting and modifying messages at their liking.

One important point of the modeling is that we allow the attacker to impersonate
dishonest and/or compromised endpoints, by revealing their long-term and session
key material at any given point.
%
Conversely, we say that a party is honest if they never reveal their
long-term key or session key material.

Another important point is to define what the key material is.
    \mEdhoc{} does not result in an explicit session key, but a cryptographic
    state from which keys for \mOscore{} can be derived using \mHkdf.
    As will be seen below, depending on how the key material is defined, the
    different methods will have different authentication properties.
    In particular, all methods except those where the initiator uses the
    \mStat{} method provide a stronger form of authentication (injective
    agreement) for the initator.

\spacehack
\subsection{Desired Properties}
\label{sec:desired-properties}
\fillhack
Next we list the properties that will be considered during verification.

\spacehack
\subsubsection{Secrecy}
We say that \mEdhoc{} satisfies secrecy of the established session key $sk$
between two honest parties $A$ and $B$ if, for any run of the protocol $A$ and
$B$, the attacker does not get to know $sk$.
%
The attacker may passively observe---and actively interfere with---the
communication, and run any number of sessions with $A$ and $B$, in either role,
concurrently or otherwise.

\spacehack
\subsubsection{Authentication}
To define \mEdhoc{}'s authentication properties we make use of Lowe's definition
of \emph{injective agreement}~\cite{DBLP:conf/csfw/Lowe97a}:
\begin{quote}
  ``We say that a protocol guarantees to an initiator $A$ [injective] agreement
  with a responder $B$ on a set of data items $ds$ if, whenever $A$ (acting as
  initiator) completes a run of the protocol, apparently with responder $B$,
  then $B$ has previously been running the protocol, apparently with $A$, and
  $B$ was acting as responder in his run, and the two agents agreed on the data
  values corresponding to all the variables in $ds$, and each such run of $A$
  corresponds to a unique run of $B$.''
\end{quote}
%
We say that \mEdhoc{} in method $m$ satisfies \emph{explicit authentication} for
the initiator $A$ with a responder $B$, if injective agreement holds for $A$
with $B$ on the session key $sk$, when running method $m$.
%
The corresponding definition for the responder is analogous.
%
If both parties obtain explicit authentication we refer to it as mutual explicit
authentication or simply explicit authentication when it is clear from the
context.

A party obtains the explicit authentication guarantee when both parties agree
on the session key (and other parameters), when the party completes the protocol
run.
%
It turned out, however, that explicit authentication does not hold for all
\mEdhoc{} methods, in which cases we prove \emph{implicit authentication} as
defined in~\cite{DBLP:journals/iacr/GuilhemFW19}.
%
In a nutshell, a protocol satisfies \emph{implicit authentication} if the
initiator and responder agree on the session key \emph{only after} a successful
execution of the protocol.
%
That is, authentication happens only implicitly, as there is no confirmation to
the initiator that the responder has computed the same session key.
%
More precisely, we adapt the definition of~\cite{DBLP:journals/iacr/GuilhemFW19}
to the symbolic model, and we prove that if an initiator $A$ and a responder $B$
complete the protocol deriving the same session key, then $A$ believes she is
talking to $B$ and $B$ believes he is talking to $A$.

\spacehack
\subsubsection{Session independence}
A protocol satisfies session independence if knowing a session key does
not give the attacker any information about other sessions.  To model session
key independence of \mEdhoc, we allow leakage of session keys, and additionally
check security only of those sessions for which the session keys have not been
directly revealed to the attacker.

\spacehack
\subsubsection{Perfect forward secrecy} (PFS) A protocol satisfies perfect forward
secrecy if, for any run of the protocol in which the initiator and the responder
agree on a session key $sk$, the attacker does not learn $sk$, even when the
long-term keys are revealed after the session is completed.

\spacehack
\subsubsection{Key-compromise impersonation} (KCI) This property takes the perspective of one
of the endpoints of the protocol, say Alice running a session with Bob. A
protocol is secure under KCI if Alice can still establish a secure session with
Bob, even though Alice's keys are compromised at any time, and Bob's key
material is not leaked until the end of the session.

\spacehack
\subsubsection{Post-compromise security} (PCS) A protocol that has
\emph{post-compromise security} (following definitions in~\cite{cohn2016post})
is capable of establishing a secure session even after one of the parties has
been compromised. Cohn-Cordon et al.~\cite{cohn2016post} presents two notions of
PCS, namely weak and strong PCS: here we focus on the latter.
%
A protocol guarantees \emph{weak PCS} if secrecy of any session key $sk$ holds
between the initiator and the responder, even if the run of the protocol that
established $sk$ happens after a \emph{limited compromise}, where the key
material is not leaked, but the attacker is capable of impersonating both
parties (i.e. has the ability to perform all cryptographic operations using the
initiator's and responder's long term keys, but has not access to the long term
keys).

\spacehack
\subsection{\mTamarin{}}
\label{sec:tamarin}
\fillhack
We chose \mTamarin{} to model and verify \mEdhoc{} in the Symbolic model.
%
\mTamarin{} is an interactive verification tool based on multi-set rewriting rules
with event annotations, which allows the user to check Linear Temporal Logic
(LTL) formulas on these models.
%
Multi-set rewrite rules with events take the form $ l \ifarrow[e] r $,
where $l$ and $r$ are multi-sets of facts, and $e$ is a multi-set of events.
Facts are $n$-ary predicates over a term algebra, which defines a set of function
symbols $\mathcal F$, variables $\mathcal V$ and names $\mathcal N$. \mTamarin{}
checks equality of these terms under an equational theory $E$. For example,
one can write $ dec(enc(x,y),y) =_E x $
to denote that symmetric decryption reverses the encryption operation under this theory.
All operations on terms are defined under $E$, hence we omit the
subscript from now on as the equational theory is fixed per model.

\spacehack
\subsubsection{Semantics and built-ins} \phantom{} \mTamarin{} states
$S$, $S'$ are multisets of facts, and a semantic transition $S \semarrow[E] S'$
occurs if there is a rule $l \ifarrow[e] r$ and a substitution $\sigma$ such
that $S \supseteq \sigma(l)$ and $S' = S \setminus \sigma(l) \uplus \sigma(r)$
and $E = \sigma(e)$.

There are a few more details, such as persistent facts that are denoted by a $!$
and are never removed from the state.
%
The sorts fresh (denoted by $\sim$) and public (denoted by $\$$) denote fresh
constants and public values known to the attacker respectively, and are both
sub-sorts of a base sort.
%
Finally, \mTamarin{} has some built-in predicates ($\mIn,
\mOut$ to represent input and output of messages with the attacker,
and
$\mFr$ to denote a fresh constant created in the current rule, among
others), rules and equations that represent the attacker's knowledge
and standard equational theories in the symbolic model,
which we present later.

\anote{This can go, I make a shorter note later:\\
\subsubsection{Notational conventions} In the remainder of this section we present
\mTamarin{} code as it appears in the models that we verify, in the style of
literate programming.  Whenever possible we match the style of the protocol
diagrams in Section~\ref{sec:edhoc} and the naming convention of the \mEdhoc{}
\mSpec~\cite{selander-lake-edhoc-01}, so that each element of the model is
traceable to the standard.  There are a few exceptions to this, most notably
some variable names that we introduce for the sake of the \mTamarin{} model and are
not present in the original \mSpec{}, which will appear in \mT{camelCase}, and
the syntax for Diffie-Hellman exponentiation which is specific to \mTamarin{}.
We also use \mT{xx} to name the ephemeral key for the initiator (resp. \mT{yy}
for the responder) as to avoid confusion with \mTamarin's builtin variable
names \mT{x} and \mT{y}.}

\spacehack
\subsubsection{Protocol rules and equations}
\mTamarin{} allows users to define new function symbols and equational theories.
These user defined objects are then translated by \mTamarin{} into rewrite
rules, which are added to the set of considered rules during verification.
For example, in our model we have a symbol to denote authenticated encryption and
hence \mTamarin{} produces the rule:
%
\begin{lstlisting}
[!KU(k), !KU(m), !KU(ad), !KU(al)] --> [!KU(aeadEncrypt(k, m, ad, al))]
\end{lstlisting}
%
to denote that if the attacker knows a key \mT{k}, a message \mT{m}, the
authenticated data \mT{ad}, and an algorithm \mT{al}, then they can construct
the encryption using these parameters, hence get to know the message
\lstinline{aeadEncrypt(k, m, ad, al)}.

In our model we introduce a theory for authenticated encryption, and make use of
the built-in theories of exclusive-or and Diffie-Hellman operations.
%
Authenticated encryption, which is encryption with authentication data as
detailed in~\cite{aead}, has the following two equations:
\begin{lstlisting}
aeadDecrypt(k, aeadEncrypt(k, m, ad, al), ad, al) = m
decrypt(k, aeadEncrypt(k, m, ad, al), al) = m
\end{lstlisting}
With the first rule we allow the protocol to decrypt the message \mT{m} if the
encryption has matching key \mT{k}, authenticated data \mT{ad}, and uses the
same algorithm \mT{al}.
%
The second rule allows the attacker to decrypt the message \mT{m} with the key
\mT{k} and without the authenticated data \mT{ad}, and hence skip the check.

The built-in theories for XOR and Diffie-Hellman are a fair bit more complex
than authenticated encryption, hence we refer to the original
papers~\cite{DBLP:conf/csfw/DreierHRS18,DBLP:conf/csfw/SchmidtMCB12}
for a full reference.
%
Suffices to say that the XOR theory introduces the symbol \mT{XOR}, for
expressing XOR operations \mT{x} $\oplus$ \mT{y}, plus the necessary equational theory
including associativity, commutativity, and inverse.
%
The theory for Diffie-Hellman introduces exponentiation \mT{g^y} and product of
exponents \mT{x * y} as a built-in symbols in the language, plus the necessary equational
theory of associativity, commutativity, distributivity of exponentiation with
product, and inverse.

\spacehack
\subsubsection{Syntactic sugar} In the following presentation we use some syntactic
sugar, which is necessary to understand to look at the concrete rules. First is
the use of let bindings (\mT{let ... in}), which are series of
definitions of patterns which are substituted in the rest of the rule. Another
prominent feature is the use of tuples (\mT{<t1, ..., tn>}) which are a
built-in concept in \mTamarin.

\spacehack
\subsection{Modeling \mEdhoc{}}
\fillhack
In this section we detail the modeling choices that we have made for this formal
verification effort.
%
We model the five different methods of \mEdhoc{} from a single specification
using the M4 macro language to derive all valid combinations: \mPskPsk,
\mSigSig, \mSigStat, \mStatSig{} and \mStatStat.
%
Whenever possible we adhere with the variable names present in the standard and
in Section~\ref{sec:edhoc}. There are a few exceptions: we present in
\mT{camelCase} those names introduced with the modeling, and we use \mT{xx} and
\mT{yy} for the ephemeral keys, to avoid name clashes.
%
\anote{Do we need this: Other parameters to the model include the optional data of the \mEdhoc{}
specification, that is, the connection identifiers \mCi{} and \mCr{}, and
the authenticated data \mADone, \mADtwo{} and \mADthree.}
%
To keep the presentation brief, we only present the \mStatSig{} mode, as it
shows both asymmetric modes at the same time. The PSK case can be found in the
appendix and the full code at the GitHub repository~\cite{edhocTamarinRepo}.
\anote{Fix: give a dropbox link instead of the repo}
% - Explain details of model, which properties we have modeled, how,
% which trade-offs were made and why.
\spacehack
\subsubsection{General setup}
\vnote{Section name doesn't appear here! Needs some text before the rule.}
\begin{lstlisting}
rule registerLTK_SIG:
 [Fr(~ltk)] --[ UniqLTK($A, ~ltk) ]->
  [!LTK_SIG($A, ~ltk), !PK_SIG($A, pk(~ltk)), Out(<!<$A, pk(~ltk)>!>)]
rule registerLTK_STAT:
 [Fr(~ltk)] --[ UniqLTK($A, 'g'^~ltk) ]->
  [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]
\end{lstlisting}

These rules express the registering of the long term keys for the \mSig{} and
\mStat{} methods, respectively.
%
\mT{registerLTK_SIG} and \mT{registerLTK_STAT} register a public key (for
signing and encrypting, respectively) that are tied to the identity of an agent
\mT{A}. A similar rule \mT{registerLTK_PSK} registers symmetric keys for pairs
of agents.
%
The event \mT{UniqLTK} marks that the long term key is unique for each
agent.
% or pair of agents, as enforced by the following restriction:
% \begin{lstlisting}
% restriction uniqLTKs:
%     "All id k1 k2 #i #j. (UniqLTK(id, k1)@i & UniqLTK(id, k2)@j) ==> k1 = k2"
% \end{lstlisting}
This models that there is an external mechanism ensuring that the
long term keys are bound to the correct identity, e.g., a certificate authority,
and that the attacker cannot register new public keys for an existing identity.

In our model we introduce specific rules to give the attacker access to
long-term keys, session keys and the cryptographic interface of the device.
\begin{lstlisting}
rule revealLTK_SIG: [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT: [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealSessionKeyI: [CommitI(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
rule revealSessionKeyR: [CommitR(tid, u, v, sk)] --[SKRev(sk)]-> [Out(sk)]
rule forge_SIG: [!LTK_SIG($A, ~ltk), In(xx)] --[TEE($A)]-> [Out(sign(xx, ~ltk))]
rule exp_STAT: [!LTK_STAT($A, ~ltk), In('g'^x)] --[TEE($A)]-> [Out(('g'^x)^~ltk)]
\end{lstlisting}
These rules allow to check Perfect Forward Secrecy, Key Compromise Impersonation
and (weak) Post Compromise Security as defined in Section~\ref{sec:desired-properties},
by giving the attacker the ability to access to long term and session keys, or
to the cryptographic interface, at the appropriate time.

% \spacehack
% \subsubsection{\mPskPsk{}} The following rules model the symmetric key based
% \mPskPsk{} method and are derived from the M4 file, as presented in
% Section~\ref{sec:edhoc}.

% First we present the rule \mT{I1_PSK_PSK}, which corresponds to the
% Initiator starting a session:
% \begin{lstlisting}
% rule I1_PSK_PSK:
%   let gx = 'g'^~xx
%       ID_PSK = <$U, $V>
%       m1 = <'PSK', 'PSK', $cSUITE0, gx, ID_PSK> 
%   in
%   [ !LTK_PSK(<$U, $V>, ~ltk), Fr(~xx), Fr(~tid) ]
%   --[ I1(~tid, $U, $V, m1) ]->
%   [ StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid), Out(m1)]
% \end{lstlisting}

% This rule uses the persistent predicate \mT{!LTK_PSK} to retrieve the long-term
% symmetric key for the two parties U (the initiator) and V (the responder).  The
% two predicates \mT{Fr(~xx)} and \mT{Fr(~tid)} denote the creation of a fresh
% ephemeral key and a fresh session identifier.  Message 1 is then constructed as
% a tuple in the let binder following the specification.

% It is worth noting that there are some differences in the way \mT{m1} is
% constructed when compared to the specification. In particular, the \emph{method}
% field is divided into two fields representing the method for the initiator and
% the responder, the connection identifier is omitted and the ciphersuite is
% represented by the public variable
% \mT{$cSUITES0} (known to the attacker). We plan to introduce the connection
% identifier \mCi in our ongoing verification effort, whereas the other two are
% modeling choices that do not affect the behaviour of the model.

% Finally, we use the fact \mT{StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid)} %
% to save the internal state for the remainder of the initiator's protocol.

% The next rule models the responder receiving \mT{m1} from the initiator,
% constructing the Diffie-Hellman shared secret $g^{xy}$ and preparing \mT{m_2}.
% \begin{lstlisting}
% rule R2_PSK_PSK:
%   let
%     data_2 = <'g'^~yy>
%     ID_PSK = <$U, $V>
%     m1 = <'PSK', 'PSK', $cSUITE0, gx, ID_PSK>
%     TH_2 = h(<$cHash0, m1, data_2>)
%     prk_2e = hkdfExtract(~ltk, gx^~yy)
%     prk_3e2m = prk_2e
%     extAad2 = TH_2
%     plainText2 = 'emptyStr'
%     K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
%     CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)
%     m2 = <data_2, CIPHERTEXT_2>
%   in
%     [ !LTK_PSK(<$U, $V>, ~ltk), In(m1), Fr(~yy), Fr(~tid) ]
%     --[ ExpRunningR(~tid, $V, exp_sk)
%       , R2(~tid, $V, m1, m2) ]->
%     [ StR2_PSK_PSK($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2), Out(m2) ]
% \end{lstlisting}

% Here we obtain as input message 1 (\mT{m1}), create a fresh exponent \mT{yy} and
% session identifier \mT{tid}.  The let bindings in this rule show how to
% construct message \mT{m2}.  They can be easily mapped to the diagram in
% Figure~\ref{fig:edhocpsk}.  We use the public constant \mbox{\mT{'emptyStr'}} instead
% of an empty string since \mTamarin{} has no concept of strings (single quotes
% denote constants).

% Here we notice the introduction of the event \mT{ExpRunningR(~tid, $V, exp_sk)}
% % 
% which we later use to show explicit authentication (hence the \mT{Exp} prefix) by
% finding an injective correspondence between two events.

% The next rule models the initiator receiving \mT{m2} and responding with the
% final message \mT{m3}:
% \begin{lstlisting}
% rule I3_PSK_PSK:
%   let
%     data_2 = <gy> 
%     TH_2 = h(<$cHash0, m1, data_2>)
%     prk_2e = hkdfExtract(~ltk, gy^~xx)
%     prk_3e2m = prk_2e
%     plainText2 = 'emptyStr' 
%     extAad2 = TH_2
%     K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
%     CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)
%     m2 = <data_2, CIPHERTEXT_2>
%     data_3 = 'emptyStr' 
%     TH_3 = h(<$cHash0, TH_2, CIPHERTEXT_2, data_3>)
%     K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
%     extAad3 = TH_3
%     plainText3 = 'emptyStr'
%     CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)
%     m3 = <data_3, CIPHERTEXT_3>
%     exp_sk = <gy^~xx>
%     imp_sk =  exp_sk
%   in
%   [ StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid), In(m2) ]
%   --[ ExpCommitI(~tid, $U, $V, exp_sk)
%     , CommitI(~tid, $U, $V, imp_sk)
%     , I3(~tid, $U, $V, m1, m2, m3) ]->
%   [ Out(m3) ]
% \end{lstlisting}

% Apart from observations similar to those already made for the previous messages,
% we should mention here the two events %
% \mT{ExpCommitI(~tid, $U, $V, exp_sk)} and \mT{CommitI(~tid, $U, $V, imp_sk)}. %
% These events mark the completion of the protocol for the initiator, and will
% be used later for verifying explicit and implicit authentication, respectively.
% The difference is the choice of key material on which we check authentication
% (\mT{exp_sk} vs \mT{imp_sk}). In the case of the \mSig{} method, as above, these
% keys are the same, but there will be a crucial difference when the initiator runs the \mStat{} method.

% Finally, we have the last rule for the responder:
% \begin{lstlisting}
% rule R4_PSK_PSK:
%   let
%     data_3 = 'emptyStr' 
%     TH_3 = h(<$cHash0, TH_2, CIPHERTEXT_2, data_3>)
%     K_3ae = hkdfExpand(<$cAEAD0, TH_3, 'K_3ae'>, prk_3e2m)
%     extAad3 = TH_3
%     plainText3 = 'emptyStr'
%     CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)
%     m3 = <data_3, CIPHERTEXT_3>
%     exp_sk = <gxy>
%     imp_sk =  exp_sk
%   in
%   [ StR2_PSK_PSK($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2), In(m3) ]
%   --[ ExpCommitR(~tid, $U, $V, exp_sk)
%     , CommitR(~tid, $U, $V, imp_sk)
%     , R4(~tid, $U, $V, m1, m2, m3) ]->
%   []
% \end{lstlisting}

% This rule receives message 3, checks that the
% Diffie-Hellman key \mGxy{} corresponds to the local state, and then terminates
% the protocol.  As in
% the previous message, we mark acceptance of the third message from the responder
% with the two commit events, and conclude.

\spacehack
\subsubsection{\mStatSig{}}
Next we present the mixed asymmetric method \mStatSig. We chose\\ \mStatSig{} for
this presentation of the asymmetric methods as this configuration shows all
interesting features at once: mixed authentication methods, and implicit
authentication on the responder.

\begin{lstlisting}
rule I1_STAT_SIG:
  let gx = 'g'^~xx
      m1 = <'STAT', 'SIG', $cSUITE0, gx> 
  in
  [ !LTK_STAT($U, ~ltk), Fr(~xx), Fr(~tid) ]
  --[ I1(~tid, $U, $V, m1) ]->
  [ StI1_STAT_SIG($U, ~ltk, $V, ~xx, m1, ~tid), Out(m1)]
\end{lstlisting}
Like in the previous model, this rule starts the initiator and outputs the first
message \mT{m1}, this time looking up the public key for \mT{U} and using the
\mStatSig{} method.

Next we look at the rule for the responder:
% \begin{lstlisting}
% rule R2_STAT_SIG:
%   let
%     data_2 = <'g'^~yy>
%     m1 = <'STAT', 'SIG', $cSUITE0, gx> 
%     TH_2 = h(<$cHash0, m1, data_2>)
%     prk_2e = hkdfExtract('emptyStr', gx^~yy)
%     prk_3e2m = prk_2e
%     K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
%     protected2 = $V // ID_CRED_V
%     CRED_V = pkV
%     extAad2 = <TH_2, CRED_V> 
%     assocData2 = <protected2, extAad2>
%     MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
%     authV = sign(<assocData2, MAC_2>, ~ltk)
%     plainText2 = <$V, authV>
%     K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
%     K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
%     K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
%     CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2> 
%     m2 = <data_2, CIPHERTEXT_2>
%     exp_sk = <gx^~yy>
%   in
%   [ !LTK_SIG($V, ~ltk), !PK_SIG($V, pkV) , In(m1), Fr(~yy), Fr(~tid) ]
%   --[ ExpRunningR(~tid, $V, exp_sk), R2(~tid, $V, m1, m2) ]->
%   [ StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) 
%   , Out(m2) ]
% \end{lstlisting}
Here is a place where the model and the original specification differ
slightly, the reason being that we must allow some behaviour that is
otherwise not covered by the symbolic handling of XOR encryption. It must
be possible for the attacker to break apart the fields of
\mT{CIPHERTEXT_2}, and obtain part of the key \mT{K_2e}
if they know part of the plaintext, or viceversa.
%
Hence \mT{CIPHERTEXT_2} is not a direct XOR ``encryption'', but rather a tuple
where each field is XORed with a half-key expansion (\mT{K_2e_1} and
\mT{K_2e_2}).  Notice also the lack of \mT{exp_sk}, as the semi-static
Diffie-Hellman key $g^{iy}$ cannot be computed by the responder at this stage.

Next we have the second rule for the initiator:
% \begin{lstlisting}
% rule I3_STAT_SIG:
%   let
%     data_2 = <gy> 
%     TH_2 = h(<$cHash0, m1, data_2>)
%     prk_2e = hkdfExtract('emptyStr', gy^~xx)
%     plainText2 = <$V, authR> 
%     CRED_V = pkV
%     prk_3e2m = prk_2e
%     K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
%     K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
%     CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2> 
%     m2 = <data_2, CIPH3RTEXT_2>
%     K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
%     protected2 = $V // ID_CRED_V
%     extAad2 = <TH_2, CRED_V> 
%     assocData2 = <protected2, extAad2>
%     MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
%     data_3 = 'emptyStr' 
%     TH_3 = h(<$cHash0, TH_2, CIPHERTEXT_2, data_3>)
%     K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
%     giy = gy^~ltk
%     prk_4x3m = hkdfExtract(prk_3e2m, giy)
%     K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
%     protected3 = $U // ID_CRED_U
%     CRED_U = pkU
%     extAad3 = <TH_3, CRED_U>
%     assocData3 = <protected3, extAad3>
%     MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
%     authU = MAC_3
%     plainText3 = <$U, authU>
%     extAad3Outer = TH_3
%     CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
%     m3 = <data_3, CIPHERTEXT_3>
%     exp_sk = <gy^~xx>
%     imp_sk = <exp_sk, giy>
%   in
%   [ StI1_STAT_SIG($U, ~ltk, $V, ~xx, m1, ~tid) 
%   , !PK_SIG($V, pkV)
%   , !PK_STAT($U, pkU)
%   , In(m2) ]
%   --[ ExpCommitI(~tid, $U, $V, exp_sk), CommitI(~tid, $U, $V, imp_sk)
%     , I3(~tid, $U, $V, m1, m2, m3)
%     , Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true) ]->
%   [ Out(m3) ]
% \end{lstlisting}
Here is a crucial difference that follows from our last observation: we notice
the addition of the semi-static Diffie-Hellman key to the term \mT{imp_sk}.
This will be used later to check implicit authentication, as is reflected by the
commit events.

% \begin{lstlisting}
% rule R4_STAT_SIG:
%   let
%     data_3 = 'emptyStr'
%     TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
%     K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
%     CRED_U = pkU
%     extAad3 = TH_3
%     plainText3 = <$U, authI>
%     CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
%     giy = CRED_U^~yy
%     prk_4x3m = hkdfExtract(prk_3e2m, giy)
%     K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
%     protected3 = $U // ID_CRED_U
%     extAad3 = <TH_3, CRED_U>
%     assocData3 = <protected3, extAad3>
%     MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
%     m3 = <data_3, CIPHERTEXT_3>
%     exp_sk = <gxy>
%     imp_sk = <exp_sk, giy>
%   in
%   [ StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) 
%   , !PK_STAT($U, pkU)
%   , !PK_SIG($V, pkV)
%   , In(m3) ]
%   --[ ExpCommitR(~tid, $U, $V, exp_sk)
%     , CommitR(~tid, $U, $V, imp_sk)
%     , R4(~tid, $U, $V, m1, m2, m3)
%     , Eq(authI, MAC_3) ]->
%   []
% \end{lstlisting}

On the same rule we can also see how \emph{implicit authentication}
differs from explicit authentication for the Initiator running the
static method: on \mT{imp_sk} the semi-static key
\mGiy{} is present, whereas \mT{exp_sk} does not include it
for injective agreement.
%
The reason for this is that, when sending message 2, the responder
does not yet know the identity of the initiator, hence an active
attacker can interfere with the protocol in such a way that the two
parties do not agree on the semi-static key
\mGiy{} until after the end of the protocol, when the responder
starts using the derived key material with the initiator.
%
This is outside the scope of the \mEdhoc{} protocol, hence we have left
this part out of the modeling and only focus on the key material that
both parties agree on.
%
In future work, it will be interesting to see the interaction of
\mEdhoc{} with \mOscore{} which can use \mEdhoc{}'s keys.

Looking at \mT{authV} in rule \mT{R2_STAT_SIG} we can
see how the signature message is constructed: it is a signature of the
transcript including message 2, using the Responder's long term public
key.
%
Here lies one of the two main differences between the \mStat{} and \mSig{} methods
in the model, the other being the corresponding authentication check.
A simple matching of the MAC tag on the initiator side suffices.
%
This saving comes from the use of challenge-response signatures.
%
(\mT{Eq(authI, MAC_3)}), instead of verifying the public key
signature on the responder side
%
(\mT{Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)}).

The event \mT{Eq} has no special meaning in \mTamarin{}, but we use it to check
that the two arguments are equal by introducing the following restriction:
\begin{lstlisting}
restriction Eq: "All x y #i. Eq(x, y)@i ==> x = y"
\end{lstlisting}

\spacehack
\subsection{Properties}
\label{sec:properties}
\fillhack
In this section we present the properties that we have shown for \mEdhoc, and
show the lemmas that verify them. We refer to
Section~\ref{sec:desired-properties} for a full explanation of the properties
that we check. Here we focus on their formalization into \mTamarin{} lemmas.

\spacehack
\subsubsection{Explicit authentication}

We model explicit authentication between the initiator and the
responder.
%
For this lemma, we use the events \mT{ExpCommitI} and
\mT{ExpRunningR}, and show that there is injective agreement
between the two events on the parameters \mT{tidI},
\mT{v} and the session key material \mT{expSk} (note
that the session key material changes between the different \mEdhoc{}
methods).

Additionally, we require that injective agreement must hold only when
no long term key material for the two parties has been revealed before
the end of the protocol.
%
This is achieved by the main disjunction in lines 5-10 on the right of
the implication, requiring to reveal the long term keys (i.e. one of
the three \mT{LtkRev} events must trigger) if the responder has
not been running a matching session with the initiator.

\begin{lstlisting}
lemma authInjAgreeGuaranteeForI:
  all-traces
  "All tidI u v expSk #i.
     ExpCommitI(tidI, u, v, expSk)@i ==>
     ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
       & not( Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2
       & not(#i = #i2) ) )
     | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
     | (Ex #j. LTKRev(u)@j & #j < #i)
     | (Ex #j. LTKRev(v)@j & #j < #i) )"
\end{lstlisting}

Note that this property \emph{does not hold when} the initiator is
running the \mStat{} method.
%
For that case we need to prove implicit authentication, as detailed in
the next section.

Similarly to the previous lemma, we require that injective agreement also holds
in the reverse direction:

\begin{lstlisting}
lemma authInjAgreeGuaranteeForR:
  all-traces
  "All tidR u v sk #i.
     CommitR(tidR, u, v, sk)@i ==>
     ( ( (Ex tidI #j. RunningI(tidI, u, v, sk)@j & #j < #i)
       & not( Ex tidR2 u2 v2 #i2. CommitR(tidR2, u2, v2, sk)@i2
        & not(#i = #i2) ) )
     | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
     | (Ex #j. LTKRev(u)@j & #j < #i)
     | (Ex #j. LTKRev(v)@j & #j < #i) ) "
\end{lstlisting}

As the explicit and implicit authentication always correspond for the
responder authenticating with the initiator, here we do not need the
additional \mT{Exp} prefix to the running and commit events
(\mT{CommitI} and \mT{CommitR} respectively).

\spacehack
\subsubsection{Implicit authentication}

The following lemma proves implicit authentication:
\begin{lstlisting}
lemma authGIYImplicitAuthGuaranteeForI2:
  all-traces
  "All tidI u v impSk #i.
     CommitI(tidI, u, v, impSk)@i ==>
     ( (All tidR u2 v2 #j. CommitR(tidR, u2, v2, impSk)@j ==>
       (u = u2 & v = v2 & All tidR2 u3 v3 #j2.
	    CommitR(tidR2, u3, v3, impSk)@j2 ==> #j = #j2)
       & (not Ex #k. K(impSk)@k) )
     | (Ex #k. LTKRev(u)@k)
     | (Ex #k. LTKRev(v)@k)
     | (Ex #k. LTKRev(<u, v>)@k)
     )
  "
\end{lstlisting}

As opposed to lemma \mT{authInjAgreeGuaranteeForI}, here we prove that the two
parties implicitly authenticate on the keys \mT{impSk}. %
In this lemma we show that if any two parties (\mT{u} and \mT{v2} here) complete
a run of the protocol, and \mT{u} believes she is talking to \mT{v} and \mT{v2}
believes he is talking to \mT{u2}, then their identities match (that is,
\mT{u = u2} and \mT{v = v2}). Furthermore there is an injective correspondence
between the \mT{CommitI} and \mT{CommitR} events, and the attacker does not
learn the session key material.

\spacehack
\subsubsection{Secrecy, Forward Secrecy and Session Key Independence}

Finally, we prove secrecy of session keys, perfect forward secrecy
(PFS) and session key independence.
%
All these properties are validated by a unique lemma for each method,
as secrecy is a strictly weaker property than PFS (and hence follows
directly), and session key independence can be proven along PFS.
%
This is done by allowing the revelation of long term keys after either
the initiator or the responder have completed the protocol, and by
allowing to reveal the session keys.
%
It still holds that the session keys are secret for all the other runs
of the protocol.

First we show the lemma for the symmetric method:
\begin{lstlisting}
lemma secrecyPFSGIYSessionKey:
  all-traces
  "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) ) &
   (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) )"
\end{lstlisting}

Next we present the lemma for the asymmetric methods:
\begin{lstlisting}
lemma secrecyPFSGIYSessionKey:
  all-traces
  "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j)
     | (Ex #l. SKRev(sk)@l)) ) &
   (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
     ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j)
     | (Ex #l. SKRev(sk)@l)) )"
\end{lstlisting}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
