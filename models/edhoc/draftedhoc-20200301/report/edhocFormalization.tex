% !TEX root =  main.tex

Next we describe our approach at formalizing the \mEdhoc{} protocol. We use the
symbolic (Dolev-Yao) model for verification, using \mTamarin{} for tool support.
%
The next three subsections describe our threat model, briefly present the
\mTamarin{} tool, and our modeling choices.
%
Finally, we present the properties that we proved in this effort.

\subsection{Threat model}\label{sec:threat-model}
We verify \mEdhoc{} in the symbolic Dolev-Yao model: as customary in this style of
modeling, we assume all cryptographic primitives to be ``perfect'', and hence
only allow the attacker to encrypt and decrypt messages when they know the key,
and exclude hash collisions, for example; the attacker is also in control of the
communication channel, and can interact with unbounded sessions of the protocol,
dropping, injecting and modifying messages at their liking.

One important point here is that we allow the attacker to impersonate malicious
endpoints, by revealing their long-term and session key material at any given
point.
%
\mEdhoc{} should remain secure under these assumptions, as we detail below. \vnote{What does it mean for \mEdhoc{} to remain secure? Security of what?}

\paragraph{Post-compromise security}
Post-compromise security is a class of properties that relate to the ability of
a protocol to maintain security of previous and future sessions under a
compromise.
%
Cohn-Gordon et al.~\cite{cohn2016post} present a formal characterization of this
class of properties.
%
In this paper we adopt their terminology, hence we refer to them for a detailed
explanation.

Briefly speaking,~\cite{cohn2016post} defines the \emph{classical adversary
  model} as the model that considers only sessions ran by honest parties; other
parties may be dishonest and thus reveal their private information to the
attacker, however the honest parties remain honest.
%
Under the classical model security must be maintained for the parties
considered.
%
\emph{Perfect forward secrecy} (PFS) drops the assumption that the parties
involved in the sessions considered shall remain honest: hence long-term key
material may be leaked after the run of a session, but such session must remain
secure.
%
Further, \emph{key-compromise impersonation} (KCI) takes the perspective of one
of the endpoints of the protocol, say Alice running a session with Bob. A
protocol is secure under KCI if Alice can still establish a secure session with
Bob, even though Alice's keys are compromised at any time, and Bob's key
material is not leaked until the end of the session.
%
Finally, \emph{weak} and \emph{strong post-compromise security} (PCS) consider
only those sessions run by parties that are not under control of the
attacker. These same parties can be under the attacker's control even before and
after the session.
%
A protocol with \emph{weak PCS} must guarantee security under a limited
compromise, where the key material is not leaked, but the attacker has access to
the compormised party to perform cryptographic operations (e.g. through
interfacing with a trusted computing module).
%
A protocol with \emph{strong PCS} gurantees security even if the attacker has
complete access to the state of both parties involved, up until before the
execution of the session under consideration and even after.
%
This is usually achieved by maintaining some state and performing key rotations,
hence the attacker must be able to observe the internal state of the device as
the protocol runs.
%
\emph{We do not check strong PCS} for \mEdhoc, as it is not secure under these
assumptions.

\vnote{What does it even mean to check strong PCS for \mEdhoc? Possible reviewer comment: How do you know it is not secure if you haven't checked it?}

\vnote{When I think about modelling and verifying a protocol, I start with properties like (normal) secrecy of some value of interest, authentication, maybe session independence at most. It feels a little precipitous to immediately jump to PCS without any introduction at all to what values are of interest in \mEdhoc, and what obvious properties one might check for before moving to this rather advanced class of properties.}

\paragraph{Session independence}
Finally we model \emph{session independence} of \mEdhoc, that is, we allow
leakage of session key material, and additionally check security only of those
sessions for which the session key material has not been revealed. We check this
in conjunction with PCS properties.

\vnote{This feels like an oddball selection of the properties that are actually verified. Why not mention all of them, and maybe go into detail about PCS after the simpler ones have been tackled, in the Properties section later? The threat model there is more advanced, and can be dealt with later. In fact, a note about the basic Dolev-Yao attacker can be very well combined with the Tamarin section, in my opinion.}

\subsection{Tamarin}
We chose \mTamarin{} to model and verify \mEdhoc{} in the Symbolic model.
%
\mTamarin{} is an interactive verification tool based on multi-set rewriting rules
with event annotations, which allows to check LTL temporal formulas on these
models.
%
Multi-set rewrite rules with events take the form:
%
\[ l \ifarrow[e] r \]
%
where $l$ and $r$ are multi-sets of facts, and $e$ is a multi-set of events.
%
Facts are $n$ary predicates over a term algebra, which defines a set of function
symbols $\mathcal F$, variables $\mathcal V$ and names $\mathcal N$. \mTamarin{}
checks equality of thse terms under an equational theory $E$, hence one can
write that
%
\[ dec(enc(x,y),y) =_E x \]
%
to denote that symmetric decryption reverses the encryption operation, and so
forth. All operations on terms are defined under $E$, hence we omit the
subscript from now on as the equational theory is fixed per model.

\paragraph{Semantics and built-ins} On a first approximation, \mTamarin{} states
$S$, $S'$ are multisets of facts, and a semantic transition $S \semarrow[E] S'$
occurs if there is a rule $l \ifarrow[e] r$ and a substitution $\sigma$ such
that $S \supseteq \sigma(l)$ and $S' = S \setminus \sigma(l) \uplus \sigma(r)$
and $E = \sigma(e)$.

There are a few more details, such as persistent facts that are denoted by a $!$
and are never removed from the state.
%
The sorts fresh (denoted by $\sim$) and public (denoted by $\$$) denote fresh
constants and public values known to the attacker respectively, and are both
sub-sorts of a base sort.
%
Finally, \mTamarin{} has some built-in predicates ($\mIn,
\mOut$ to represent input and output of messages with the attacker,
and
$\mFr$ to denote a fresh constant created in the current rule, among
others), rules and equations that represent the attacker's knowledge
and standard equational theories in the symbolic model, plus syntactic
sugar, all of which we introduce as we see necessary.

For example in our model we have a symbol to denote authenticated encryption and
hence \mTamarin{} produces the rule:
%
\[ !\mKU( k ), !\mKU( m ), !\mKU( ad ), !\mKU( al ) \ifarrow !\mKU( \mAeadEncrypt(k, m, ad, al) ) \]
%
to denote that if the attacker knows a key $k$, a message
$m$, the authenticated data $ad$, and an algorithm
$al$, then they can construct the encryption using these parameters, hence get
to know the message $\mAeadEncrypt(k, m, ad, al)$.
%
There are two built-in persistent facts to denote attacker knowledge,
$!\mKU$ and
$!\mKD$, but we ignore their distinction for now as it is only necessary for
\mTamarin's termination properties.
\vnote{I don't think the above paragraph is necessary -- it feels like a distraction. A reference for \mTamarin{} and a note saying readers can refer to it for further details should be quite enough.}

In our model we introduce a theory for authenticated encryption, plus the
built-in theories of XOR and Diffie-Hellmann.
%
Authenticated encryption, which is encryption with authentication data as
detailed in~\cite{aead}, has the following two equations:
\begin{align*}
  \mAeadDecrypt(k, \mAeadEncrypt(k, m, ad, al), ad, al) = m\\
  \mDecrypt(k, \mAeadEncrypt(k, m, ad, al), al) = m
\end{align*}
With the first rule we allow the protocol to decrypt the message $m$ if the
encryption has matching key $k$, authenticated data $ad$, and uses the same
algorithm $al$.
%
The second rule allows the attacker to decrypt the message $m$ with the key $k$
and without the authenticated data $ad$, and hence skip the check.

The built-in theories for XOR and Diffie-Hellman are a fair bit more complex
than authenticated encryption, hence we refer to the original
papers~\cite{xorTamarin,dhTamarin} for a full reference.
%
Suffices to say that the XOR theory introduces the symbol $\oplus$, for
expressing XOR operations $x \oplus y$, plus the necessary equational theory
including associativity, commutativity, and inverse.
%
The theory for Diffie-Hellman introduces exponentiation $x^y$ and product
$x \cdot y$ as a built-in symbols in the language, plus the necessary equational
theory of associativity, commutativity, distributivity of exponentiation with
product, and inverse.

\subsection{Modeling \mEdhoc{}}
In this section we detail the modeling choices that we have made for this formal
verification effort.
%
\vnote{Karl and I have been referring to them as ``methods'', not ``modes''. Please follow the same terminology.}

We model the five different modes of \mEdhoc{} from a single specification
according to the five different combinations of authentication methods:
\mPskPsk, \mSigSig, \mSigStat, \mStatSig and \mStatStat.
%
We use the M4 macro language to derive these different modes from a single
description of the protocol, thus enforcing uniformity in the presentation.
%
Other parameters to the model include the optional data of the \mEdhoc{}
specification, that is the connection identifiers \mCi{} and \mCr{} and
the authenticated data \mADone, \mADtwo{} and \mADthree.
%
To keep the presentation brief, we detail only the setup of the model,
the symmetric and one asymmetric variant (\mSigStat), however the full
code can be inspected at
\url{https://github.com/hoheinzollern/EDHOC-Verification}.

\vnote{Fix the link to link to the exact folder for the current version -- this page contains the old code too.}

% - Explain details of model, which properties we have modeled, how,
% which trade-offs were made and why.

\paragraph{General setup}
\begin{lstlisting}
rule registerLTK_SIG:
  [Fr(~ltk)] --[UniqLTK($A, ~ltk)]->
    [!LTK_SIG($A, ~ltk), !PK_SIG($A, pk(~ltk)), Out(<!<$A, pk(~ltk)>!>)]
rule registerLTK_STAT:
  [Fr(~ltk)] --[UniqLTK($A, 'g'^~ltk)]->
    [!LTK_STAT($A, ~ltk), !PK_STAT($A, 'g'^~ltk), Out(<!<$A, 'g'^~ltk>!>)]
rule registerLTK_PSK:
  [Fr(~ltk)] --[UniqLTK(<$A, $B>, ~ltk)]-> [!LTK_PSK(<$A, $B>, ~ltk)]
\end{lstlisting}
\knote{We agreed to add a clarification that we use the variable names xx and yy
    because \mTamarin's output includes x's for variable names and it was not
    eaiser to distinguish the xx variables from \mTamarin's internal variable
names}
    
These three rules express the registering of the long term keys for the \mSig,
\mStat{} and \mPsk{} modes respectively.
%
The \lstinline{registerLTK_PSK} registers a symmetric key for each pair of
agents \lstinline{A} and \lstinline{B}, while the other two rules register a
public key (for signing and encrypting, respectively) that are tied to the
identities of one agent \lstinline{A}.
%
The event \lstinline{UniqLTK} marks that the long term key is unique for each
agent or pair of agents, as enforced by the following restriction:
\begin{lstlisting}
restriction uniqLTKs:
    "All id k1 k2 #i #j. (UniqLTK(id, k1)@i & UniqLTK(id, k2)@j) ==> k1 = k2"
\end{lstlisting}

Long term keys are revealed to the attacker through specific rules
with the event \lstinline{LTKRev}.
\begin{lstlisting}
rule revealLTK_SIG:
    [!LTK_SIG($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_STAT:
    [!LTK_STAT($A, ~ltk)] --[LTKRev($A)]-> [Out(~ltk)]
rule revealLTK_PSK:
    [!LTK_PSK(<$A, $B>, ~ltk)] --[LTKRev(<$A, $B>)]-> [Out(~ltk)]
\end{lstlisting}
these rules are used to check the different lemmas for authetication
and key secrecy, as we limit when the attacker is able to reveal the
keys to prove forward secrecy, as discussed in
Section~\ref{sec:threat-model}.
%
Each of the session keys is also revealed with similar rules,
depending on the mode to check session independence.

\paragraph{Implicit vs explicit authentication}
\knote{Need to agree on how we denote section headings. Now we are mixing
    paragraph and subsection for the same level it seems.
}
As we will discuss in Section~\ref{sec:properties}, not all modes of
\mEdhoc{} enjoy the same properties, and different guarantees are
provided for each method.
%
In particular we make a distinction between \emph{implicit and
  explicit authentication}, as defined
in~\cite{DBLP:journals/iacr/GuilhemFW19}.
%
Simply put, \emph{explicit authentication} occurs when the initiator
and responder parties agree on the session data (i.e. identities, key
material and so on) \emph{at the end of the protocol}, whereas for
\emph{implicit authentication} the two parties may only agree after
the protocol has ended when the first message encrypted with the
session key is being transmitted.
\vnote{This last sentence is confusing, restructure?}
%
We will discuss this concept again, however we mention it here as
certain aspects of the modeling directly follow from it.

\anote{Implicit authentication: note that comparing implicit
  authentication from the Guilhelm paper with injective agreement is a
  bit misleading. Quoting Lowe: ``We say that a protocol guar- antees
  to an initiator A agreement with a responder B on a set of data
  items ds if, whenever A (acting as initiator) com- pletes a run of
  the protocol, apparently with responder B, then B has previously
  been running the protocol, apparently with A, and B was acting as
  responder in his run, and the two agents agreed on the data values
  corresponding to all the variables in ds, and each such run of A
  corresponds to a unique run of B.''. Technically injective agreement
  holds when you choose the proper ds, as you do. If you include more,
  that only works in the implicit mode. That is, implicit vs explicit
  refers to when a protocol is considered to be completed, i.e. after
  the first encrypted message is being sent vs. at the end of the key
  agreement, whereas injective agreement is parametric on all this
  stuff, including when a protocol is completed and what data should
  be agreed upon.}

  \paragraph{\mPskPsk{}} the following rules model the symmetric variant of
the protocol and are derived from the M4 file, as presented in
Section~\ref{protocol-presentation}\footnote{link}.

\begin{lstlisting}
rule I1_PSK_PSK:
  let gx = 'g'^~xx
      ID_PSK = <$U, $V>
      m1 = <'PSK', 'PSK', $cSUITE0, gx, ID_PSK> 
  in
  [ !LTK_PSK(<$U, $V>, ~ltk), Fr(~xx), Fr(~tid) ]
  --[ I1(~tid, $U, $V, m1)
    , DHInvI1(~tid, 'g', ~xx, 'g'^inv(~xx), 'g'^~xx, 'g'^inv(~ltk))
    , InvI1(~tid, ~xx, inv(~xx), ~ltk, inv(~ltk))
    ]->
  [ StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid), Out(m1)]

rule R2_PSK_PSK:
  let
    data_2 = <'g'^~yy>
    ID_PSK = <$U, $V>
    m1 = <'PSK', 'PSK', $cSUITE0, gx, ID_PSK>
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract(~ltk, gx^~yy)
    prk_3e2m = prk_2e
    extAad2 = TH_2
    plainText2 = 'emptyStr'
    K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
    CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0)
    m2 = <data_2, CIPHERTEXT_2>
  in
    [ !LTK_PSK(<$U, $V>, ~ltk), In(m1), Fr(~yy), Fr(~tid) ]
    --[ ExpRunningR(~tid, $V, exp_sk)
      , R2(~tid, $V, m1, m2)
      , InvR2(~tid, ~yy, inv(~yy), ~ltk, inv(~ltk))
      ]->
    [ StR2_PSK_PSK($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2), Out(m2) ]


rule I3_PSK_PSK:
  let
    data_2 = <gy> 
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract(~ltk, gy^~xx)
    prk_3e2m = prk_2e
    plainText2 = 'emptyStr' 
    extAad2 = TH_2
    K_2ae = hkdfExpand(<$cAEAD0, TH_2, 'K_2ae'>, prk_2e)
    CIPHERTEXT_2 = aeadEncrypt(plainText2, K_2ae, extAad2, $cAEAD0) // MAC check by pattern matching
    m2 = <data_2, CIPHERTEXT_2>
    data_3 = 'emptyStr' 
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    extAad3 = TH_3
    plainText3 = 'emptyStr'
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gy^~xx> // SIG_SIG or PSK_PSK
    imp_sk =  exp_sk
  in
  [ StI1_PSK_PSK($U, ~ltk, $V, ~xx, m1, ~tid), In(m2) ]
  --[ ExpCommitI(~tid, $U, $V, exp_sk)  // standard running/commit
    , CommitI(~tid, $U, $V, imp_sk)  // Requires R to complete
    , I3(~tid, $U, $V, m1, m2, m3)
    , DHInvI3(~tid, 'g'^~xx)
   ]->
   [ Out(m3) ]

rule R4_PSK_PSK:
  let
    data_3 = 'emptyStr' 
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    extAad3 = TH_3
    plainText3 = 'emptyStr'
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3, $cAEAD0) // MAC check by pattern matching
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gxy> // SIG_SIG or PSK_PSK
    imp_sk =  exp_sk
  in
  [ StR2_PSK_PSK($U, $V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2), In(m3) ]
  --[ ExpCommitR(~tid, $U, $V, exp_sk)
    , CommitR(~tid, $U, $V, imp_sk)
    , R4(~tid, $U, $V, m1, m2, m3)
    ]->
    []
\end{lstlisting}

Here we won't dive into all the details to avoid repetition, however a
few things are worth mentioning.  First is the introduction of the
syntactic sugar \lstinline{let ... in}, which presents a series of
definitions of patterns which are substituted in the rest of the
rule. Each rule corresponds to one action of the protocol, hence rule
\lstinline{I1_PSK_PSK} represents the Initiator sending the first
message, whereas \lstinline{R2_PSK_PSK} represents the responder
receiving the first message and responding with the second, and so on. \vnote{I feel like these two are features of \mTamarin, and not the modelling of \mEdhoc, so should go in the previous section.}

Two other important details are the events which are used for checking
authentication, and the facts which store the local state of the
endpoints. \anote{we also have some events which are not checked in
  any lemma, like InvR2. In my understanding they don't serve any
  purpose, should they be in there? certainly not in the
  presentation.}
\knote{I have clean that up now, so these two notes can be deleted.}
%
The event \lstinline{ExpRunningR} denotes the start of the Responder's
protocol, whereas \lstinline{ExpCommitI} and \lstinline{CommitI}
denote both that the Initiator is running the protocol with the
Responder and that she agreed on (i.e. committed to) the session key.
%
The \lstinline{Exp} prefix refers to explicit authentication, wheras
the events lacking this prefix contain only those parameters which are
agreed upon by the modes that only allow implicit authentication, as
we discuss in Section~\ref{sec:properties}.
%
The facts \lstinline{StI1_PSK_PSK} and \lstinline{StR2_PSK_PSK} are
used to represent the local knowledge of the initiator and the
responder, when they are waiting for the second and third message to
arrive, respectively.

\vnote{If you are going with \mPskPsk for the first example, it would make sense to explain it in some detail. At least a connection to the earlier section describing the variables in the code is necessary, because so far there is no mention of $U$, $V$ etc. If you directly jump to the events, a casual reader has no idea what the variables even correspond to. Once these things are explained here, they need not be repeated for the next method.}

\paragraph{\mStatSig{}}
Next we present the mixed asymmetric mode \mStatSig. We chose \mStatSig{}
for this presentation of the asymmetric modes as it's the
\knote{Question on academic language: you use contractionns here "it's". Is that
acceptable?  It sounds quite informal to me}
configuration that shows all interesting features at once: mixed
authentication methods, and implicit authentication on the responder.

\begin{lstlisting}
rule I1_STAT_SIG:
  let gx = 'g'^~xx
      m1 = <'STAT', 'SIG', $cSUITE0, gx> 
  in
  [ !LTK_STAT($U, ~ltk)
  , Fr(~xx)
  , Fr(~tid)  /* Thread ID */
  ]
  --[ I1(~tid, $U, $V, m1) ]->
  [ StI1_STAT_SIG($U, ~ltk, $V, ~xx, m1, ~tid) 
  , Out(m1)
  ]

rule R2_STAT_SIG:
  let
    data_2 = <'g'^~yy>
    m1 = <'STAT', 'SIG', $cSUITE0, gx> 
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract('emptyStr', gx^~yy)
    prk_3e2m = prk_2e
    K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
    protected2 = $V // ID_CRED_V
    CRED_V = pkV
    extAad2 = <TH_2, CRED_V> 
    assocData2 = <protected2, extAad2>
    MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
    authV = sign(<assocData2, MAC_2>, ~ltk)
    plainText2 = <$V, authV>
    K_2e = hkdfExpand(<$cAEAD0, TH_2, 'K_2e'>, prk_2e)
    K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
    K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
    CIPHERTEXT_2 = <$V XOR K_2e_1, authV XOR K_2e_2> 
    m2 = <data_2, CIPHERTEXT_2>
    exp_sk = <gx^~yy>
  in
  [ !LTK_SIG($V, ~ltk)
  , !PK_SIG($V, pkV)
  , In(m1)
  , Fr(~yy)
  , Fr(~tid)
  ]
  --[ ExpRunningR(~tid, $V, exp_sk), R2(~tid, $V, m1, m2) ]->
  [ StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gx^~yy, ~tid, m1, m2) 
  , Out(m2)
  ]

rule I3_STAT_SIG:
  let
    data_2 = <gy> 
    TH_2 = h(<$cHash0, m1, data_2>)
    prk_2e = hkdfExtract('emptyStr', gy^~xx)
    plainText2 = <$V, authR> 
    CRED_V = pkV
    prk_3e2m = prk_2e
    K_2e_1 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '1'>, prk_2e)
    K_2e_2 = hkdfExpand(<$cAEAD0, TH_2, 'K_2e', '2'>, prk_2e)
    CIPHERTEXT_2 = <$V XOR K_2e_1, authR XOR K_2e_2> 
    m2 = <data_2, CIPHERTEXT_2>
    K_2m = hkdfExpand(<$cAEAD0, TH_2, 'K_2m'>, prk_3e2m)
    protected2 = $V // ID_CRED_V
    extAad2 = <TH_2, CRED_V> 
    assocData2 = <protected2, extAad2>
    MAC_2 = aeadEncrypt('emptyStr', K_2m, assocData2, $cAEAD0)
    data_3 = 'emptyStr' 
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    giy = gy^~ltk
    prk_4x3m = hkdfExtract(prk_3e2m, giy)
    K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
    protected3 = $U // ID_CRED_U
    CRED_U = pkU
    extAad3 = <TH_3, CRED_U>
    assocData3 = <protected3, extAad3>
    MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
    authU = MAC_3
    plainText3 = <$U, authU>
    extAad3Outer = TH_3
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gy^~xx>
    imp_sk = <exp_sk, giy>
  in
  [ StI1_STAT_SIG($U, ~ltk, $V, ~xx, m1, ~tid) 
  , !PK_SIG($V, pkV)
  , !PK_STAT($U, pkU)
  , In(m2) ]
  --[ ExpCommitI(~tid, $U, $V, exp_sk), CommitI(~tid, $U, $V, imp_sk)
  , I3(~tid, $U, $V, m1, m2, m3)
  , Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)
  ]->
  [ Out(m3) ]

rule R4_STAT_SIG:
  let
    data_3 = 'emptyStr'
    TH_3 = h(<cHash0, TH_2, CIPHERTEXT_2, data_3>)
    K_3ae = hkdfExpand(<$cAEAD0, TH_2, 'K_3ae'>, prk_3e2m)
    CRED_U = pkU
    extAad3 = TH_3
    plainText3 = <$U, authI>
    CIPHERTEXT_3 = aeadEncrypt(plainText3, K_3ae, extAad3Outer, $cAEAD0) // MAC check by pattern matching
    giy = CRED_U^~yy
    prk_4x3m = hkdfExtract(prk_3e2m, giy)
    K_3m = hkdfExpand(<$cAEAD0, TH_3, 'K_3m'>, prk_4x3m)
    protected3 = $U // ID_CRED_U
    extAad3 = <TH_3, CRED_U>
    assocData3 = <protected3, extAad3>
    MAC_3 = aeadEncrypt('emptyStr', K_3m, assocData3, $cAEAD0)
    m3 = <data_3, CIPHERTEXT_3>
    exp_sk = <gxy>
    imp_sk = <exp_sk, giy>
  in
  [ StR2_STAT_SIG($V, ~ltk, ~yy, prk_3e2m, TH_2, CIPHERTEXT_2, gxy, ~tid, m1, m2) 
  , !PK_STAT($U, pkU)
  , !PK_SIG($V, pkV)
  , In(m3)
  ]
  --[ ExpCommitR(~tid, $U, $V, exp_sk)
  , CommitR(~tid, $U, $V, imp_sk)
  , R4(~tid, $U, $V, m1, m2, m3)
  , Eq(authI, MAC_3)
  ]->
  []
\end{lstlisting}

Let us focus on the interesting details of this model. First and
foremost, it shows how to construct signatures in the static mode and
the signing mode.
%
Looking at \lstinline{authU} how it is constructed in rule
\lstinline{I3_STAT_SIG}, we can see that it uses \lstinline{K_3m},
which is an expansion of \lstinline{prk_4x3m} that in turn uses the
semi-static Diffie-Hellman key \mGiy.
\knote{Terminology: we need to harmonize terminology in the end. Here it is called semi
    statc DH key. Sometimes this is referred to as a "DH key share" and sometimes
    as a "DH half key". I don't care so much which we chose as long as it is
    consitent.
}
%
On the same rule we can also see how \emph{implicit authentication}
differs from explicit authentication for the Initiator running the
static mode: on \lstinline{imp_sk} the semi-static key
\mGiy{} is present, whereas \lstinline{exp_sk} does not include it
for injective agreement.
%
The reason for this is that, when sending message 2, the responder
does not yet know the identity of the initiator, hence an active
attacker can interfere with the protocol in such a way that the two
parties do not agree on the semi-static key
\mGiy{} until after the end of the protocol, when the responder
starts using the derived key material with the initiator.
%
This is outside the scope of the \mEdhoc{} protocol, hence we have left
this part out of the modeling and only focus on the key material that
both parties agree on.
%
In future work, it will be interesting to see the interaction of
\mEdhoc{} with \mOscore, which is a transport standard that can use
\mEdhoc's keys.

Looking at \lstinline{authV} in rule \lstinline{R2_STAT_SIG} we can
see how the signature mode is constructed: it is a signature of the
transcript including message 2, using the Responder's long term public
key.
%
Here lies the main difference between the static and signature modes
in the model, the other being the corresponding authentication check:
a simple matching of the MAC tag on the initiator side
%
(\lstinline{Eq(authI, MAC_3)}), instead of verifying the public key
signature on the responder side
%
(\lstinline{Eq(verify(authR, <assocData2, MAC_2>, CRED_V), true)}).

Finally, it's worth mentioning the construction of
\lstinline{CIPHERTEXT_2}.
\knote{We earlier agreed to use the macros for the constants in the model to get
    a consistent formatting and save time in the end, not having to go through
    everything and align formatting.
    Here a different format is used: lstinline.  Up until here in this section
    I have changed all the places where we have macros for the terms. But
    since I now noticed that you started usnig a different formatting, I ask you
    to please select the formatting you prefer, encode that into the macros and
    use them. Alternateively, please go through the rest of the paper and change
    the formatting to the new listinline format. I prefer to stick to the
    agreement we made and have followed in the rest of the sections, i.e.,
    the former.
}
%
Here is a place where the model and the original specification differ
slightly, the reason being that we must allow some behaviour that is
otherwise not covered by symbolic handling of XOR encryption: it must
be possible for the attacker to break apart the fields of
\lstinline{CIPHERTEXT_2}, and obtain part of the key \lstinline{K_2e}
if they know part of the plaintext, or viceversa.
%
Hence \lstinline{CIPHERTEXT_2} is not a direct XOR ``encryption'', but
rather a tuple where each field is XORed with a half-key expansion
(\lstinline{K_2e_1} and \lstinline{K_2e_2}).

% - Explain how we modeled inj-agree (a sentence or two).
% - Explain why it fails when $I$ uses \mStat-method and the implicit
% auth lemma we showed instead
% (cite~\cite{DBLP:journals/iacr/GuilhemFW19} here where I got the
% basic idea. It is then extended with the reveal queries in our
% model; obviously: if you know about other sources for this please
% cite them too). Include code/lemmas as you see fit.


\subsection{Properties}
\label{sec:properties}

In this section we present the properties that we have shown for
\mEdhoc, and show the lemmas that verify them.

\subsubsection{Explicit authentication}

We model explicit authentication between the the initiator and the
responder.
%
For this lemma, we use the events \lstinline{ExpCommitI} and
\lstinline{ExpRunningR}, and show that there is injective agreement
between the two events on the parameters \lstinline{tidI},
\lstinline{v} and the session key material \lstinline{expSk} (note
that the session key material changes between the different \mEdhoc
methods).
%
This is a standard adaptation of the injective agreement property as
proposed by Lowe~\cite{lowes-paper}, which is widely used in symbolic
models. \vnote{I believe a one-line description of injective agreement here, at least for the sake of completeness, would be good to have.}

Additionally, we require that injective agreement must hold only when
no long term key material for the two parties has been revealed before
the end of the protocol.
%
This is achieved by the main disjunction in lines 5-10 on the right of
the implication, requiring to reveal the long term keys (i.e. one of
the three \lstinline{LtkRev} events must trigger) if the responder has
not been running a matching session with the initiator.

\begin{lstlisting}
lemma authInjAgreeGuaranteeForI:
    all-traces
    "All tidI u v expSk #i.
         ExpCommitI(tidI, u, v, expSk)@i ==>
         ( ( (Ex tidR #j. ExpRunningR(tidR, v, expSk)@j & #j < #i)
           & not( Ex tidI2 u2 v2 #i2. ExpCommitI(tidI2, u2, v2, expSk)@i2
                & not(#i = #i2) ) )
         | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
         | (Ex #j. LTKRev(u)@j & #j < #i)
         | (Ex #j. LTKRev(v)@j & #j < #i) )"
\end{lstlisting}
\anote{as this is a disjunction and the symmetric LTKRev happens only
  in the symmetric model and viceversa, this property is equivalent to
  the two properties for the sym and asym cases, so I put this for brevity}
\knote{That is logically true, but \mTamarin{} does not accept it. Try it out to see what
goes wrong. If you have proposals for better ways of modeling it, I'd love to
know.}

Note that this property \emph{does not hold when} the initiator is
running the static method.
%
For that case we need to prove implicit authentication, as detailed in
the next section.

Similarly, we require that injective agreement also holds in the
reverse direction:

\begin{lstlisting}
lemma authInjAgreeGuaranteeForR:
    all-traces
    "All tidR u v sk #i.
         CommitR(tidR, u, v, sk)@i ==>
         ( ( (Ex tidI #j. CommitI(tidI, u, v, sk)@j & #j < #i)
           & not( Ex tidR2 u2 v2 #i2. CommitR(tidR2, u2, v2, sk)@i2
                & not(#i = #i2) ) )
         | (Ex #j. LTKRev(<u, v>)@j & #j < #i)
         | (Ex #j. LTKRev(u)@j & #j < #i)
         | (Ex #j. LTKRev(v)@j & #j < #i) ) "
\end{lstlisting}

As the explicit and implicit authentication always correspond for the
responder authenticating with the initiator, here we do not need the
additional \lstinline{Exp} prefix to the running and commit events
(\lstinline{CommitI} and \lstinline{CommitR} respectively).
\anote{it would be nice to actually call CommitI -> RunningI for clarity}
\knote{I have added that now}

\subsubsection{Implicit authentication}

The following lemma proves implicit authentication:
\begin{lstlisting}
lemma authGIYImplicitAuthGuaranteeForI:
    all-traces
    "All tidI u v impSk #i.
         CommitI(tidI, u, v, impSk)@i ==>
         ( ( (All tidR #j. CommitR(tidR, u, v, impSk)@j)
           & (not Ex #k. K(impSk)@k)
           & (not( Ex tidR u v #j tidR2 u2 v2 #j2.
                      ( CommitR(tidR,  u,  v,  impSk)@j
                      & CommitR(tidR2, u2, v2, impSk)@j2
                      & not(#j = #j2)
                      ) ) )
           )
         | (Ex #k. LTKRev(u)@k)
         | (Ex #k. LTKRev(v)@k)
         | (Ex #k. LTKRev(<u, v>)@k) ) "
\end{lstlisting}
\anote{I changed the lemma removing u2, v2 on line 5, this is equivalent, and allows to remove the two expressions u = u2 and v = v2}
\anote{I actually think that the formulation in lines 7-10 is a bit weird. It actually says that there are no two events with the same impSk but different tidR, u, V etc. Is that because of some problem verifying the lemma as in explicit agreement? Also, why is line 6 necessary?}

The main difference between lemma
\lstinline{authInjAgreeGuaranteeForI} and lemma\\
\lstinline{authGIYImplicitAuthGuaranteeForI} presented here is that
the latter proves injective agreement on the reduced set of keys
\lstinline{impSk}, which only differs from the explicit set when the
initiator runs in static mode.

\subsubsection{Secrecy, Forward Secrecy and Session Key Independence}

Finally, we prove secrecy of session keys, perfect forward secrecy
(PFS) and session key independence. \vnote{Here is the perfect place to add the section about PCS, session independence etc.}
%
All these properties are validated by a unique lemma for each method,
as secrecy is a strictly weaker property than PFS (hence it follows
directly), and session key independence can be proven along PFS.
%
This is done by allowing the revelation of long term keys after either
the initiator or the responder have completed the protocol, and by
allowing to reveal the session keys.
%
It still holds that the session keys are secret for all the other runs
of the protocol.

First we show the lemma for the symmetric mode:
\begin{lstlisting}
lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) ) &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(<u, v>)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) )"
\end{lstlisting}

Next we present the lemma for the asymmetric modes:
\begin{lstlisting}
lemma secrecyPFSGIYSessionKey:
        all-traces
        "(All tid u v sk #i #j. (K(sk)@i & CommitI(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) ) &
         (All tid u v sk #i #j. (K(sk)@i & CommitR(tid, u, v, sk)@j) ==>
            ((Ex #l. LTKRev(u)@l & #l < #j) | (Ex #l. LTKRev(v)@l & #l < #j) | (Ex #l. SKRev(sk)@l)) )"
\end{lstlisting}

Note that in case the responder is using the static mode, the lemma
fails.  \anote{this is actually from the comments in the code, is that
  correct? then we should find a formulation that succeeds. Also, if
  one of the two sides holds and the other does not, it is equivalent
  to splitting this lemma in two and proving each part separately. You
  can prove a stronger lemma for the static responder mode.}
  \knote{Please check which version of edhocM4.spthy you look at. The one from
      June 12, does not include that comment. The comment may refer to an
  artifact of the incomplete addition of C\_I, C\_R switches}

% holds no matter which method user chooses.
%  -  PFS on session key for all methods.
%  -  Key secrecy (follows from PFS).
%  -  Session key independence (follows from how we modeled PFS).

% TODO: some statics of running time code size perhaps.
% TODO: Scan draft-selander and check what props are claimed there; see
% what we have covered and what we haven't.

%  -  Entity authentication - we show this in the same lemmas as we show
%       inj-agree on session key.  We don't have this property when $I$ uses
%       STAT method because $I$ then gets no confirmation of
%       Pre-specified peer model.
%  -  Key confirmation (except for when $I$ uses \mStat
%     method, then $I$ gets no key confirmation on \mGiy)

% See~\ref{sec:mail-notes-encr} for how encryption is modeled.
% \item Caveat: we have not modeled running all methods in parallel,
% so we don't know if an adversary can somehow trick $I$ into
% running one method and $R$ another, and by that causing some
% attack.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
