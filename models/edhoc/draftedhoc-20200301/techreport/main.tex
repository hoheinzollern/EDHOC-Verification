\documentclass[runningheads,draft,x11names]{llncs}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[scaled=0.8]{helvet}    % Less huge \textsf{functionName}
\usepackage{enumitem}       % compacts lists and stuff
\usepackage[subtle]{savetrees}
\usepackage{soul}           % \hl for highlighting text; \st for strike-through
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage{tikz,tikzpeople}
\usetikzlibrary{trees,snakes,arrows}
\usetikzlibrary{shapes,chains}
\usetikzlibrary{positioning}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
    final, % Uncomment to remove all links (useful for printing in black and white)
    colorlinks=true, breaklinks=true, bookmarks=false,bookmarksnumbered,
    urlcolor=blue, linkcolor=black, citecolor=green, % Link colors
    pdfkeywords={}, % PDF Keywords
    pdfcreator={PdfLaTeX}, % PDF Creator
  }

\input{macros}

\begin{document}
\title{Formal Analysis of EDHOC Key Establishment for Constrained IoT Devices}
%\author{ Karl Norrman\inst{1,2}\orcidID{0000-0003-0164-1478} \and
% Vaishnavi Sundararajan\inst{3} \and
% Alessandro Bruni\inst{4}
%}
%
% \authorrunning{K. Norrman et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
% \institute{
%     KTH Royal Institute of Technology, Stockholm, Sweden \and
%     Ericsson Research, Security, Stockholm, Sweden,
%     \email{karl.norrman@ericsson.com} \and
%     Ericsson Research, Int. Auton. Systems, Bangalore, India, \email{vaishnavi.sundararajan} \and
%     IT University of Copenhagen, Copenhagen, Denmark, \email{brun@itu.dk}
% }
%
\maketitle
%

\begin{abstract}
%\hl{250 words}
    IETF is standardizing a key establishment protocol named \mEdhoc{} for
constrained IoT devices~\cite{selander-lake-edhoc-01}.
%
In contrast to more powerful IoT devices, such as web cameras and cars,
which receive most attention from media, constrained devices often have severe
restrictions on energy consumption.
%
Additionally, they often use specialized wireless communication links with
demanding constraints on message sizes, which may also vary between messages.
%
\mEdhoc{} was first formally analyzed by
Bruni~et.~al.~\cite{DBLP:conf/secsr/BruniJPS18}.
%
Since then, the protocol has been significantly extended and is now a
framework with a number of cryptographic cores, called methods.
%
The initial version of \mEdhoc{} contained only two out of the current five
methods~\cite{selander-ace-cose-ecdhe-08}.
%
In this paper we formally analyze all methods of \mEdhoc{} in a symbolic
Dolev-Yao model, using the \mTamarin{} verification tool.
%
We show that the different methods provide sensible, but also rather
heterogeneous security properties, and discuss consequences of this.
%
\end{abstract}
%

%-------------------------------------------------------------------------- sec
\section{Introduction}
\label{sec:introduction}
%-------------------------------------------------------------------------- sub
\subsection{Background and motivation}
\label{sec:motivation}
IoT security threats involving cars, web-cameras and other resourceful devices
receive most attention from media and academia.
%
These devices are computationally strong with no severe bandwidth or energy
consumption restrictions.
%
Securing the communication between such devices can readily be done using
\mDandTls.
%
Constrained devices, on the other hand, on which bandwidth and
energy consumption restrictions are common, have received much less attention.
%
These devices may be simple sensors with the only task of relaying
measurements of their physical environment to a server every hour, but doing so
autonomously for a decade without maintenance.
%
To keep energy consumption down, highly specialized radio links with small
and heterogeneous frame sizes are sometimes used.
%
IETF defined the Constrained Application Protocol (\mCoap{}) protocol for data
transport in such situations~\cite{rfc7252}.
%
\mCoap{} does not include security protection on its own.
%
In some cases, \mDandTls{} messages are too large to fit into the radio frames.
%
This is one of the reasons IETF standardized the Object Security for
Constrained RESTful Environments (\mOscore{}) protocol to secure
communications between constrained devices, as a complement for when
\mDandTls{} is too heavy weight~\cite{rfc8613}.
%

The \mOscore{} protocol requires a pre-established security context.
%
For a couple of years, the IETF Lightweight Authenticated Key Exchange (LAKE)
working group has been developing requirements and mechanisms for a key
exchange protocol, named \mEdhoc~\cite{selander-lake-edhoc-01}, capable of
establishing \mOscore{} security contexts.
%
Naturally, \mEdhoc{} must work under the same constrained requirements as
\mOscore{} itself.
%

While use cases for \mEdhoc{} are not firmly set,
the overall goal of \mEdhoc{} is to establish an \mOscore{} security
context, keeping messages small being the most prominent driver for the
design.
%
Discussions on the LAKE working group mailing list explored whether a
compressed version of \mTls, named \mCtls~\cite{ietf-tls-ctls-00}, would suffice
for the same situations that
the combination of \mOscore{} and \mEdhoc{} aim for.
%
They concluded to proceed developing \mEdhoc{} in parallel to the \mTls{}
working groups efforts to develop \mCtls.
%

The \mEdhoc{} protocol has evolved significantly over time to cater for smaller
messages and more use cases.
%
The first incarnation of \mEdhoc{} appeared in March 2016.
%
It contained two different cryptographic cores, one based on a
pre-shared key Diffie-Hellman and a second following a draft of the
challenge-response signatures, in the style of the \mNoise{}
framework~\cite{perrin2016noise}.
%
The latter was then replaced by \mSigma, and this version, from May 2018, was
formally analyzed by Bruni~et.~al.~\cite{DBLP:conf/secsr/BruniJPS18}.
%
The protocol has now further evolved and variants using challenge-response
signatures have been added again by integrating the cryptographic core of
\mOptls{}.
%
On top of this, mixed variants where one party uses a challenge-response
signature and the other a regular signature have also been added.
%
Consequently, there are now five cryptographic cores in total, and it is prudent
to formally analyze them all to ensure a higher level of security assurance for
\mEdhoc.
%
This is especially important, since the \mSpec{} itself lacks a description
of the intended security model and overall security goals.
%
Discussing how this gap can be filled, and how to identify what the expected
security goals should be, is an important part of this paper.
%

%-------------------------------------------------------------------------- sub
\subsection{Contributions}
\label{sec:contributions}
We have reviewed and analyzed the \mEdhoc{} protocol, which has continuously
evolved, at times based on our feedback.
%
The analysis spanned over roughly five months, but the formal models and proven
properties are based on to the version specified in the draft as it was
2020-03-01~\cite{selander-lake-edhoc-01}.
%

Our main contributions are the following.
\begin{itemize}
    \item We provide formalization of all five cryptographic cores of \mEdhoc{}
        using \mTamarin~\cite{DBLP:conf/cav/MeierSCB13}.
    \item We give an explicit security model for the protocol and have verified
        essential security properties, such as session key and entity
        authentication, as well as Perfect Forward Secrecy (PFS), within that
        model.
        From these explicitly proven properties other properties follow, e.g.,
        session key independence.
    \item We discuss the relation between proven properties, potentially missing
        properties and the lack of clear design goals and security model for
        \mEdhoc{}.
        Based on this we give recommendations for the future standards
        development in regards to clarity, not only in terms of under which
        technical restrictions the protocol must work, but also what its
        envisioned uses are.
    \item Our discussions with members of the IETF LAKE working group have already
        lead to improvements and clarifications of the standard \mSpec{} based
        on observations we made during the construction of our formal model.
\end{itemize}

%-------------------------------------------------------------------------- sub
\subsection{Related work}
\label{sec:relatedWork}
The work closest to ours is Bruni~et.~al.~\cite{DBLP:conf/secsr/BruniJPS18},
which used \mProverif~\cite{DBLP:conf/csfw/Blanchet01} to analyze an earlier,
two-cryptographic core, version of \mEdhoc~\cite{selander-ace-cose-ecdhe-08}.
%
We consider our work to be a sort of follow-up to that, doing a similar kind of
analysis of the most recent, and more elaborate, version of \mEdhoc{} with its
five cores.
%
We do, however, take a clean slate approach and look at the protocol as new.
%
For example, since the model has undergone so much change, the set of properties
which we verify is also different.
%
The \mTamarin{} tool has been used to verify many other protocols, perhaps
closest to our work is Cremers~et.~al's analysis of
\mTls~\cite{DBLP:conf/ccs/CremersHHSM17}.
%
Some of the cryptographic cores themselves have been analyzed in the
computational model, e.g., \mSigma{} by Canetti and
Krawczyk~\cite{DBLP:conf/crypto/CanettiK02}, \mOptls{} by Krawczyk and
Wee~\cite{DBLP:conf/eurosp/KrawczykW16}, and \mNoise{} by
Kobeissi~et.~al.~\cite{DBLP:conf/eurosp/KobeissiNB19}.
%
Computational models often rely on implicit session key authentication
(see for example the definition of SK-security in the Canetti-Krawczyk
model~\cite{DBLP:conf/crypto/CanettiK02}).
%
Although symbolic models predominantly rely on correspondence properties in the
style of Lowe~\cite{DBLP:conf/csfw/Lowe97a}, there are examples where implicit
authentication has been used.
%
For example, Schmidt~et.~al.~\cite{DBLP:conf/csfw/SchmidtMCB12} use a
symbolized version of an extended Canetti-Krawzcyk model.
%

%-------------------------------------------------------------------------- sec
\section{The \mEdhoc{} protocol}
\label{sec:edhoc}
\input{edhocProtocol}

%-------------------------------------------------------------------------- sec
\section{Formalization and results}
\label{sec:formalization}
\input{edhocFormalization}

%-------------------------------------------------------------------------- sec
\section{Discussion}
\label{sec:discussion}
%-------------------------------------------------------------------------- sub
\subsection{Unclear protocol use}
\label{sec:unclearProtocolUse}
In this section we discuss why formal verification of industrial standards
aiming for general purpose use, like \mEdhoc{} often is difficult because their
goals are vague~\cite{DBLP:conf/ccs/BasinDHRSS18}.
%
The basic premise for \mEdhoc{} is simple: establish an \mOscore{} security
context with few roundtrips and small messages.
%
Starting from there, the design of \mEdhoc{} seems to be mainly driven by what
can be achieved given certain technical restrictions.
%

There is a clash between formal verification activities, which aims to verify
whether well-specified security goals are met within a given security model, and
an industrial standard, where the overall goal is clear, but lacks
specificity.
%
Further, the clash is emphasized by that formal verification requires settling
on specific security models, in terms of attacker capabilities, assumptions on
storage and processing by parties etc., whereas, the security model in
industrial standards often arises from resistance to attacks identified
attacks during the design.
%
The latter makes the assumptions required for the protocol unclear and hard to
verify.
%
In our analysis we have made assumptions we believe represent useful models,
and extracted properties that \mEdhoc{} has or does not have.
%
On the one hand, this approach is aligned with the basic premises that
\mEdhoc{} should establish
an \mOscore{} security context with generally useful security properties.
%
On the other, without a clearer picture of the intended uses of the
protocol, whether these properties, or the ones claimed in the \mSpec{} are
the most important ones for constrained IoT use cases cannot be determined.
%

Similarly to \mDandTls{}, \mEdhoc{} is intended to solve a variety of use cases,
many not known today, and therefore, it is not possible to collect all types
of use cases that need to be considered.
%
However, this is not a valid argument against collecting typical use cases and
user stories to capture at least \emph{some} of the security properties a
solution must exhibit.
%

Having a better understanding of the security properties required by these use
cases would clearly help, not only verification activities, but also  guiding
the design of \mEdhoc{}.
%
It may also help reducing the number of methods to only the ones that are needed.
%
The current security model is vague and largely implicitly defined by attacks
that the protocol should withstand, so better understanding the intended use of
\mEdhoc{} would also help in defining a clearer security model.
%

We propose that the application usage of \mEdhoc{} is better explored
via user stories or use cases to identify security properties that are most
commonly needed, or are essential for important applications.
%
In fact, while constructing our model, we came up with simple user stories to
identify security properties of interest.
%
Several of these revealed undefined aspects of \mEdhoc{} that were then included
in the \mSpec.
%
We now give a few examples to demonstrate where some of our use cases and user
stories uncovered blind spots in the \mSpec.
%

\paragraph{Credentials stored in a trusted execution environment (TEE)}
The question is whether there will be applications where the device is
deployed in a hostile environment, and where it is reasonable to assume it can
be equipped with a TEE.
%
In our analysis we have chosen not to model TEEs, by making use of session
state reveal queries.
%
This is because we received indications from the \mSpec{} authors (personal
correspondence) that it was not
necessary to consider reveal of the session state, in particular the ephemeral
secret keys, with the rationale that \mSigma{} cannot protect against such an
attack (presumably based on the fact that the \mSigSig{} method is closely based on
\mSigmaI{} and that it would be preferable to obtain some kind of homogeneity
among the \mEdhoc{} methods when it comes to what security properties they
provide).
%
That argument is however only true if one restricts attention to session key
confidentiality of an ongoing session.
%
TEEs do provide value by, for example, allowing weak PCS guarantees.
%
Further, for protocols in the style of \mOptls{}, on which the \mStat{}-based
methods are modeled, a static long-term
key and an ephemeral one are typically mixed to obtain the session key material.
%
This design is intentional, especially in the \mOptls{} case, where the protocol
is designed to be provably secure in the Canetti-Krawczyk model.
%

\paragraph{Non-repudiation}
An access control solution for a nuclear power-plant may need to log who is
passing through a door, whereas it may be undesirable for, say, a coffee machine
to log a list of people and their coffee preferences.
%
When we did that simple thought experiment we caught that the \mSpec{} did not
consider non-repudiation.
%
The authors of the \mSpec{} added a paragraph about which methods provided which
types of (non)-repudiation in response.
%
It would, however, be helpful for application developers to also document
example use cases showing the consequences of choosing the different methods,
perhaps in the security considerations section.

%-------------------------------------------------------------------------- sub
\subsection{Security claims}
\label{sec:securityClaims}
The \mSpec{} makes a number of detailed claims about the properties that
the protocol provides (see Section 8.1~\cite{selander-lake-edhoc-01}).
%
The intention may be that if the academic protocol \mSigma{} is re-used as a
cryptographic core of \mEdhoc, then all the properties listed
in the paper analyzing \mSigma~\cite{DBLP:conf/crypto/CanettiK02} are the
necessary and sufficient ones and can be copied into the \mSpec.
%
(Note: presumably the intention is the same for the other reused cryptographic
cores based on \mOptls{} and \mNoise{}, but since the \mSpec{} is still work in
progress, it is not yet written down).
%
Section~8.1. states \emph{``EDHOC inherits its security properties
from the theoretical SIGMA-I''}.
%
Designing a standard specification by re-using existing well-studied academic
components is good practice.
%
But when doing so, it is important to relate any changes made to the referred
cryptographic core or give justification as to why the changes are appropriate.
%
Otherwise, one cannot draw the conclusions that a protocol inherits properties
from another.
%
The specification may not be the appropriate place for such analysis, but strong
claims about security properties require justification.
%

%-------------------------------------------------------------------------- sub
\subsection{Unintended authentication confusion}
\label{sec:usableSecurity}
Section 3.2 of the \mSpec{} states that a parties are required to be configured
with a policy restricting the set of peers an they are allowed to run \mEdhoc{}
with.
%
The intention is to configure groups which devices are allowed to connect to.
%
However, because the initiator is not required to verify that the \mIdcredr{}
received in message 2 is the same as the one the application intended when
initiating the \mEdhoc{} run, this is insufficient for a general purpose
key exchange protocol.
%
The following thought experiment shows why.

%
Assume someone has configured all devices in their home to be in the allowed
set of devices, but that one of the devices $A$ has been compromised.
%
If another device $B$, unaware of the compromise, initiates a connection to a
third device $C$, the compromised device $A$ may interfere.
%
$A$ may respond in $C$'s place, blocking the legitimate response from $C$.
%
Since $B$ does not check that it is $C$'s identity in message 2, and device $A$
is part of the allowed set, $B$ will complete and accept the \mEdhoc{} run
with device $A$ instead of the intended $C$.

%
The obvious solution is for the initiator to match \mIdcredr{} to the intended
identity provided by the application.
%
Note that it is insufficient to let \mEdhoc{} report to the application which
identity it established a security context with, because, even though the
application could reject the connection when there is a mismatch, the
application must be able to instruct \mEdhoc{} to not accept the same identity
in the next attempt, or there would be an infinite loop.
%

This is yet another example of where a small user story uncovers
potential lacks in the \mSpec, and shows that it would be a useful for
standardization to explore such and which security properties they reveal
suitable for \mEdhoc{} to have.
%

%-------------------------------------------------------------------------- sub
\subsection{Session key material}
\label{sec:sessionKeyMaterial}
\mEdhoc{} establishes a session key state as output, from which session keys for
\mOscore{} can be derived using \mHkdf{}.
%
As discussed in Section~\ref{sec:threat-model}, there are various
possibilities for defining which parameters from the \mEdhoc{} run should
provide the secret input to the session key state.

While we show bidirectional injective agreement on \mGx{} and \mGy{}
for all methods, initiators cannot obtain injective agreement on \mGiy{} when
using the \mStat{} method themselves.
%
Therefore, \mGiy{} cannot be considered part of the key material if mutual
injective agreement is considered an important property for \mEdhoc{}.
%
Excluding \mGiy{} would deviate from \mOptls{}, which is the cryptographic core
used for these methods.
%
Specifically, the proof of session key confidentiality in the face of long-term
key compromise for \mOptls{} cannot be adapted for \mEdhoc{} because the
underlying assumption that \mGiy{} is part of the key material would no longer
be true.
%
Other security properties of \mOptls{} may also fail to be true if
\mGiy{} were excluded.
%

Another option is to include a fourth message from responder to initiator
carrying a message authentication code using a key derived from session key
material including \mGiy{}.
%
This would give the initiator sufficient guarantee that the responder indeed
uses the same \mGiy{} as the initiator.
%
The cost is an additional message, and our understanding is that this is
unacceptable (personal correspondence with the \mSpec{} authors).
%

In some use-cases there will be a such as message as part of
the subsequent \mOscore{} protocol run.
%
It would, however, create an additional dependence between the two protocols,
increasing complexity and the risk for insecure implementations.
%

Yet another option is to include \mGi{}, a hash of it, or a hash of \mIdcredi{}
if there is a one-to-one mapping between \mIdcredi{} and \mGi{}, in messages one
and two.
%
This would however increase message sizes, a grave concern for \mEdhoc{}, and
would prevent initiator identity protection.
%
While identity protection is important in general, the \mSpec{} nor the
requirements document give any rationale why the initiator's identity would be
more important to protect compared to the responder's.
%
The \mSpec{} states that the
initiator's identity is protected against active attacks and the responder's
against passive attacks, but that the roles should be assigned to the \mCoap{}
peers to protect the most sensitive identity the most (see
Section~8~\cite{selander-lake-edhoc-01}).
%
Roles could hence be swapped, so identity protection is not a strong argument
against this option.
%

We have shown implicit agreement on \mGx{}, \mGy{} for all methods, and also on
\mGiy{} and \mGrx{} when these are used, see Section~\ref{sec:formalization}.
%
If this weaker security guarantee is sufficient, both ephemeral and long-term
keys can be part of the session key material.
%
Whether it is sufficient or not, depends on the intended uses of \mEdhoc{}.
%

%-------------------------------------------------------------------------- sub
\subsection{Cipher suite negotiation}
\label{sec:ciphersuiteNegotiation}
%
Cipher suite negotiation in \mEdhoc{} spans two or more executions of the
protocol.
%
That is, an initiator keeps state between protocol runs and proposes an updated
set of cipher suites if the first run resulted in a rejection of the
cipher suite from the responder (see Section~\ref{sec:edhoc}).
%
Our model does not cover this and leave it for future work.
%

We note that keeping state between protocol runs implicitly creates a long-lived
meta-session covering multiple \mEdhoc{} sessions.
%
While the spirit of the description in Section 4.2.2 of the \mSpec{} is that
within some kind of meta-session, presumably controlled by an application,
there is a re-negotiation due to
cipher suite mismatch between the initator and responder, the \mSpec{} does not
describe for how long the initator should remember a rejected cipher suite for a
given party.
%
From a security perspective, remembering the rejected cipher suite for the
next \mEdhoc{} run within a given application session would be sufficient.
%
It would also result in that, if the responder is updated with a new cipher
suite before the next application session, this would be taken into account.
%
On the other hand, caching the rejected cipher suite between application
sessions would reduce the number of round-trips for subsequent runs, should
the responder not have been updated.
%
Regardless, these considerations would be helpful to cover in the security
considerations section of the \mSpec{}.
%

%-------------------------------------------------------------------------- sec
\section{Conclusions}
\label{sec:conclusions}
We have formally modeled all the five
methods of the \mEdhoc{} key establishment protocol using the \mTamarin{} tool.
%
Using the model, we identified and defined several important security properties
and verified these.
%
We also identified security properties that does not hold for all
methods.
%
Most importantly, injective agreement on \mGiy{} does not hold for
initiators when they use the \mStat{} method, so this property cannot be claimed
for the entire key material in those situations.
%
Further, we identified a situation where initiators may establish an \mOscore{}
security context with a different party than the application using \mEdhoc{}
intended, and proposed a simple mitigation.
%
We discussed possible actions that IETF may take to extract and better define
security properties to make better use of verification techniques.
%

%-------------------------------------------------------------------------- ack
% Should be a run-in heading.  subsubsection works in llncs2e document class
\subsubsection*{Acknowledgments} This work was partially supported by
the Wallenberg AI, Autonomous Systems and Software Program (WASP) funded by
the Knut and Alice Wallenberg Foundation.
%
We are grateful to G\"oran Selander, John Mattsson and Francesca Palombini for
clarifications regarding the specification.
%

%-------------------------------------------------------------------------- bib
\bibliographystyle{plain}
\bibliography{ref}
\end{document}
