(* types *)
free c: channel.
free c2: channel.
free s: channel[private].
free s2: channel[private].
type host. (* U, V *)
type key. (* E_U, E_V *)
 (* skU, skV *)
 (* K_i *)
type dhElt.
type exponent. (* x & y *)
type pkID.(*  id(pkU) & id(pkV)  *)
type algorithmID.
type ctxID.

(* Message Types *)
free T1: bitstring. free T4: bitstring.
free T2: bitstring. free T5: bitstring.
free T3: bitstring. free T6: bitstring.

(* AlgorithmIDs *)
free OSCORE: bitstring.
free EDHOC_PSK_Chaining: algorithmID.
free EDHOC: algorithmID.
free EDHOC_PRESHARED: algorithmID.

free empty: key.

type textString.
type byteString.
type hexString.
const emptyTextString: bitstring.
const emptyHexString: bitstring.
const emptyByteString: bitstring. (* KARL: this is input to HKDF_extract, which
                                          takes other input types as well, making
                                          them all bitstring seems simplest.
                                          Further, from a modelling perspective
                                          I don't think we will test any properties
                                          that depends on the encoding so I propse
                                          we use only one emptyString of type
                                          bitstring.
                                  *)

(* Creating public keys *)
fun pk(key): key.

(* Shared Key Encryption *)
fun aeadEncrypt(bitstring, key, bitstring): bitstring.
reduc forall x: bitstring, y: key, aad: bitstring; aeadDecrypt(aeadEncrypt(x, y, aad), y, aad) = x.
reduc forall x: bitstring, y: key, aad: bitstring; decrypt(aeadEncrypt(x, y, aad), y) = x.

(* Signing *)
fun sign(bitstring, key): bitstring.
(* def for message recovery: reduc forall x: bitstring, y: skey; verify(sign(x, y), pk(y)) = x. *)
reduc forall x: bitstring, y: key; verify(x, sign(x, y), pk(y)) = true;
forall x: bitstring, y: key; verify(x, aeadEncrypt(emptyHexString, y, x), y) = true. 

(* Identifier function for the public keys *)
fun idI(key): pkID[private].
fun idR(key): pkID[private].

fun APP_2A(key, key, bitstring, key): bitstring [private].
fun APP_2A'(key, key, bitstring, key): bitstring [private].
fun APP_3A(key, key, bitstring, key): bitstring [private].

fun APP_2S(key, bitstring, key): bitstring [private].
fun APP_2S'(key, bitstring, key): bitstring [private].
fun APP_3S(key, bitstring, key): bitstring [private].


(* Hash function *)
fun hash(bitstring): bitstring.

(* Diffie Hellman *)
const g: dhElt.
fun exp(dhElt, exponent): dhElt.
equation forall x: exponent, y: exponent; exp(exp(g, x), y) = exp(exp(g, y), x).

(* Authentication events Symmetric *)
event startInitiatorS(host, host, key, dhElt).
event startResponderS(host, host, key, dhElt).
event midInitiatorS(host, host, key, dhElt).
event endInitiatorS(host, host, key, dhElt).
event endResponderS(host, host, key, dhElt).

(* Authentication events Asymmetric *)
event startInitiatorA(host, host, dhElt, key, ctxID).
event startResponderA(host, host, dhElt, key, ctxID).
event midInitiatorA(host, host, dhElt).
event endInitiatorA(host, host, dhElt).
event endResponderA(host, host, dhElt).

(* Authentication events Symmetric *)
event agreeHashStart3S(host, host, key, bitstring, key).
event agreeHashStart2S(host, host, key, bitstring, key).

event agreeHashEnd2S(host, host, key, bitstring).
event agreeHashEnd3S(host, host, key, bitstring).

(* Authentication events Asymmetric *)
event agreeHashStart3A(host, host, key, bitstring, key).
event agreeHashStart2A(host, host, key, bitstring, key).

event agreeHashEnd2A(host, host, key, bitstring).
event agreeHashEnd3A(host, host, key, bitstring).

event LTK_Reveal(key).
event PSK_Reveal(key).
event SessK2A_Reveal(key, key).
event SessK3A_Reveal(key, key).
event SessK2S_Reveal(key).
event SessK3S_Reveal(key).

(* Methods. After prefix follows the credential type used by initiator
 * and then the credential type used by responder.
 *)
(*
 * KARL: These are probably no longer needed that we use a two-dimensional 
 * view of the method
const EH_PSK_PSK:bitstring.
const EH_SIG_SIG:bitstring.
const EH_STATIC_SIG:bitstring.
const EH_SIG_STATIC:bitstring.
const EH_STATIC_STATIC:bitstring.
*)

const METHOD_STATIC:bitstring.
const METHOD_SIG:bitstring.
const METHOD_PSK:bitstring.

(* HKDF
 * Both the extract and expand functions take a salt as first parameter.
 * The second parameter of the extract function is an element from the
 * DH-group (e.g., g^xy).
 * The second parameter of the expand function is a key.
 *)
fun HKDF_extract(bitstring, dhElt): bitstring.
fun HKDF_expand(bitstring, bitstring): bitstring.

(* Intermediate keys ("PRKs"), see Section 3.8 of EDHOC
 *
 * When both I and R use PSK, use the PRK_psk_psk_2e function.
 * If any of I and R use static or sign method, use the PRK_asym_2e function.
 *)
letfun PRK_asym_2e(G_XY: dhElt) = HKDF_extract(emptyByteString, G_XY).
letfun PRK_psk_psk_2e(PSK: bitstring, G_XY: dhElt) = HKDF_extract(emptyByteString, G_XY).

(* KARL: I don't haromize the naming further even though sig_sig and stat_sig
 *       could be the same function here and stat_stat and sig_stat could
 *       be the same function. Rationale: I prefer to do the thinking here
 *       once and for all and then just call the correct function from the
 *       protocol models based on an obvious name, inseatd of having to redo
 *       the thinking for each method-let-definition.
 *)
letfun PRK_sig_sig_3e2m(G_XY: dhElt) = PRK_asym_2e(G_XY).
letfun PRK_psk_psk_3e2m(PSK: bitstring, G_XY: dhElt) = PRK_psk_psk_2e(PSK, G_XY).
letfun PRK_stat_stat_3e2m(G_XY: dhElt, G_RX: dhElt) = HKDF_extract(PRK_asym_2e(G_XY), G_RX).
letfun PRK_sig_stat_3e2m(G_XY: dhElt, G_RX: dhElt) = HKDF_extract(PRK_asym_2e(G_XY), G_RX).
letfun PRK_stat_sig_3e2m(G_XY: dhElt) = PRK_asym_2e(G_XY).

(* KARL: can lose one level of indirection in the right hand side. *)
letfun PRK_3e2m_deriv(G_XY: dhElt, PSK: bitstring, G_RX: dhElt, methodI: bitstring, methodR: bitstring) =
    if (methodI, methodR) = (METHOD_SIG, METHOD_SIG) then PRK_sig_sig_3e2m(G_XY) else
    if (methodI, methodR) = (METHOD_PSK, METHOD_PSK) then PRK_psk_psk_3e2m(PSK, G_XY) else
    if (methodI, methodR) = (METHOD_STAT, METHOD_STAT) then PRK_stat_stat_3e2m(G_XY, G_RX) else
    if (methodI, methodR) = (METHOD_SIG, METHOD_STAT) then PRK_sig_stat_3e2m(G_XY, G_RX) else
    if (methodI, methodR) = (METHOD_STAT, METHOD_SIG) then PRK_stat_sig_3e2m(G_XY)

letfun PRK_sig_sig_4x3m(G_XY: dhElt) = PRK_sig_sig_3e2m(G_XY).
letfun PRK_psk_psk_4x3m(PSK: bitstring, G_XY: dhElt) = PRK_psk_psk_3e2m(PSK, G_XY).
letfun PRK_stat_stat_4x3m(G_XY: dhElt, G_RX: dhElt, G_IY: dhElt) =
             HKDF_extract(PRK_stat_stat_3e2m(G_XY, G_RX), G_IY).
letfun PRK_sig_stat_4x3m(G_XY: dhElt, G_RX: dhElt) = PRK_sig_stat_3e2m(G_XY, G_RX).
letfun PRK_stat_sig_4x3m(G_XY: dhElt, G_RX: dhElt, G_IY: dhElt) =
             HKDF_extract(PRK_stat_sig_3e2m(G_XY), G_IY).

(* KARL: can lose one level of indirection in the right hand side. *)
letfun PRK_4x3m_deriv(G_XY: dhElt, PSK: bitstring, G_RX: dhElt, G_IY:dhElt, methodI: bitstring, methodR: bitstring) =
    if (methodI, methodR) = (METHOD_SIG, METHOD_SIG) then PRK_sig_sig_4x3m(G_XY) else
    if (methodI, methodR) = (METHOD_PSK, METHOD_PSK) then PRK_psk_psk_4x3m(PSK, G_XY) else
    if (methodI, methodR) = (METHOD_STAT, METHOD_STAT) then PRK_stat_stat_4x3m(G_XY, G_RX, G_IY) else
    if (methodI, methodR) = (METHOD_SIG, METHOD_STAT) then PRK_sig_stat_4x3m(G_XY, G_RX) else
    if (methodI, methodR) = (METHOD_STAT, METHOD_SIG) then PRK_stat_sig_4x3m(G_XY, G_IY)

(* Encryption/Integrity key and IV derivations (see Section 3.8) *)
type label.
const LABEL_K_2m: label.
const LABEL_IV_2m: label.   (* for completeness only, not used in model *)
const LABEL_K_2e: label.    (* KARL: mentioned in spec, but not used by spec? *)
const LABEL_K_2ae: label.
const LABEL_IV_2ae: label.  (* for completeness only, not used in model *)
const LABEL_K_3m: label.
const LABEL_IV_3m: label.   (* for completeness only, not used in model *)
const LABEL_K_3ae: label.
const LABEL_IV_3ae: label.  (* for completeness only, not used in model *)
(* KARL: spec lists IV_2ae twice, but it should probably be IV_3ae the last time *)

(* The key length for the AEAD transforms are defined by the cipher suite.
 * That is, there each single code-point corresponds to a fixed set algorithms
 * and key lengths (see Section 3.4). Therefore, we can model both selected
 * AEAD and selected key-length with a single term: the key length is
 * implicit from the identifier of the AEAD.
 *
 * We probably will have to model cipher suites as well later on.
 * Some cipher suites have the same AEAD so we cannot use the cipher suite ID
 * as input to these key derivations: there could be collisions on AEAD
 * identifiers even if the cipher suite identifiers differ.
 *
 * The KDF needs to be able to take AEAD IDs, but also other types as input
 * for its fourth parameter. Therefore we model all elements that are passed
 * as arguments to the fourth parameter as bitstring.
 *)
const aead0: bitstring.      (* There are only two AEADs defined *)
const aead1: bitstring.

(* The info structure is modeled by the tuple (ALGO, TH, LABEL).
 * Note that the lenth is excluded because it is implied by the
 * algoID (see comment on type algoID above).
 *
 * The AEADs take both a key and an IV as input. Both the key and
 * the IV are derived by applying the KDF to a PRK, but with different labels.
 * Becuase of this, both of them are essentially keys and we can view the pair
 * as a single long key. Further, because we don't
 * take key-lengths into account in the symbolic model, we may just as well
 * model the pair as a single object. In fact, to simplify the model even more,
 * may even ignore the IVs, and this is what we do.
 *
 * Macro parameter names indicate which key and TH to use.
 *)
letfun KDF(PRK: bitstring, TH: bitstring, LABEL: label, AEAD: bitstring) =
    HKDF_expand((AEAD, TH, LABEL), PRK).

letfun K_2ae_KDF(PRK_2e: bitstring, TH_2: bitstring, AEAD: bitstring) =
    KDF(PRK_2e, TH_2, LABEL_K_2ae, AEAD).

letfun K_2m_KDF(PRK_3e2m: bitstring, TH_2: bitstring, AEAD: bitstring) =
    KDF(PRK_3e2m, TH_2, LABEL_K_2m, AEAD).

letfun K_3ae_KDF(PRK_3e2m: bitstring, TH_3: bitstring, AEAD: bitstring) =
    KDF(PRK_3e2m, TH_3, LABEL_K_3ae, AEAD).

letfun K_3m_KDF(PRK_4x3m: bitstring, TH_3: bitstring, AEAD: bitstring) =
    KDF(PRK_4x3m, TH_3, LABEL_K_3m, AEAD).

(* Key exporter interface (section 3.8.1).
 * The LABEL and the LENGTH are values supplied by the application.
 *)
letfun EDHOC_exporter(PRK_4x3m: bitstring, TH_4: bitstring, LABEL: label, LENGTH: bitstring) =
    KDF(PRK_4x3m, TH_4, LABEL, LENGTH).

